---
title: XMeta 模型
description: 了解 Nop 平台中 XMeta 的模型结构
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

XMeta 为 Nop 平台提供的标准化的**对象元数据**模型，所有需要定义对象结构的地方都统一使用 XMeta 模型来定义。

> XMeta 和 XDef 可以相互转换。XDef 对应于 XML 结构，而 XMeta 对应于对象属性结构。

XMeta 定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改，是否可以查询等信息。
NopGraphQL 引擎返回的对象信息也完全由 XMeta 来定义。

<!-- https://plantuml.com/object-diagram -->

```plantuml
object "/nop/schema/xmeta.xdef" as xmeta {
  orderBy => /nop/schema/query/order-by.xdef
}
object "/nop/schema/schema/schema-node.xdef" as schema_node {
}
object "/nop/schema/schema/obj-schema.xdef" as obj_schema {
}
object "/nop/schema/query/order-by.xdef" as order_by {
}

xmeta -down-> obj_schema: xdef:ref 引用
obj_schema -down-> schema_node: xdef:ref 引用

xmeta::orderBy -> order_by
```

> - `xdef:name` 代表节点对应的 Java 类名；
> - `xdef:ref` 代表当前节点类的基类；

## XMeta 结构 {#structure}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| displayName | string | 显示名 | 否 | 方便人阅读 |
| displayProp | string | 显示属性 | 否 | 指定用于显示对象名称的_对象属性_，用于下拉列表等只显示对象名称的地方 |
| description | string | 描述说明 | 否 | 说明对象用途、使用注意事项等 |
| entityName | class-name | ORM 实体类名（全名） | 否 | 仅在映射了 ORM 实体时指定 |
| primaryKey | word-set | ORM 实体主键列表 | 否 | 逗号分隔的作为 ORM 实体主键的_对象属性_列表。只能包含映射了 ORM 表字段的_对象属性_ |
| [keys / key](#attr_keys_key) | `ObjKeyModel` | ORM 实体唯一键列表 | 否 | 在新增或修改 ORM 实体时，将自动检查该唯一键不冲突 |
| filter | filter-bean | 默认的 ORM 实体过滤条件 | 否 | 指定在对象级别始终自动添加的过滤条件，如，`<eq name="status" value="1" />`，用于过滤活跃状态的实体对象。新增或修改 ORM 实体时会自动设置 filter 中对应的属性值，确保查询时不会突破过滤条件限制 |
| [orderBy / field](#attr_orderBy_field) | `OrderFieldBean` | 默认的 ORM 实体排序条件列表 | 否 | 指定在对象级别的缺省排序条件 |
| [tree](#attr_tree) | `ObjTreeModel` | ORM 实体树形结构配置 | 否 | 用于补充 ORM 实体的树形结构相关的属性信息。根据此结构查询和维护树形结构的实体数据和父子关联。详细用例可参考 [这里](/practice/demo/v2#create-tree) |
| [selections / selection](#attr_selections_selection) | `ObjSelectionMeta` | GraphQL 字段选择集合 | 否 | 用于控制 GraphQL 返回对象所包含的属性结构，即，指定哪些属性的值需要返回 |
| [props / prop](#attr_props_prop) | ObjPropMetaImpl | 对象属性列表 | 否 |  |

### 实体唯一键列表：`keys / key` {#attr_keys_key}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| displayName | string | 唯一键显示名 | 否 | 方便人阅读 |
| name | string | 唯一键名 | 是 | 对应数据库层面的 `UNIQUE KEY` 名称，仅包含字母、数字和下划线 |
| props | word-set | 唯一键属性列表 | 是 | 逗号分隔的具有唯一性约束的_对象属性_列表。只能包含映射了 ORM 表字段的_对象属性_ |

### 实体排序条件列表：`orderBy / field` {#attr_orderBy_field}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| name | string | 属性名 | 是 | 映射了 ORM 表字段的_对象属性_ |
| desc | boolean | 是否降序排序 | 是 | 默认为 `false`，即，升序排序 |
| nullsFirst | boolean | NULL 值优先 | 否 | 在其值为 `true` 时，表示 `NULL` 值小于所有非 `NULL` 值；在其值为 `false` 时，表示 `NULL` 值大于所有非 `NULL` 值 |

### 实体树形结构配置：`tree` {#attr_tree}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| parentProp | string | 指向父实体的属性名 | 是 | 这里填写的不是与父实体同类型的属性名，如 `parent`，而是与 ORM 表字段直接映射的属性名，如 `parentId` |
| childrenProp | string | 指向子实体的属性名 | 否 | 在父实体中对应的子实体的集合类型的属性名，如 `children` |
| levelProp | string | 表示节点级别的属性名 | 否 | 其值对应的属性须为整数类型。若其值为 `level`，则 `level = 1` 表示一级节点，`level = 2` 表示二级节点 |
| rootLevelValue | string | 根节点所对应的节点级别属性的值 | 否 | 若 `levelProp` 所对应的属性的值为该属性的值时，表示得到的实体数据为根节点。例如，其值为 `0` 则表示 `level = 0` 的结果为根节点，若未指定该值，则以 `rootParentValue` 对应的结果为根节点 |
| rootParentValue | string | 根节点的初始值 | 否 | 若 `parentProp` 所对应的属性的值为该初始值时，表示得到的实体数据为根节点。例如，其值为 `0` 则表示 `parentId = 0` 的结果为根节点，若未指定该值，则表示 `parentId is null` 的结果为根节点 |
| sortProp | string | 排序属性名 | 否 | 用于对树形数据排序的_对象属性_，默认为 `XMeta#primaryKey` 指定的单一_对象属性_（复合主键将抛异常） |
| isLeafProp | string | 表示叶子节点的属性名 | 否 | 用于指示实体数据是否为叶子节点的_对象属性_，该属性须为 `Boolean` 类型。**暂时不确定其用途！** |

根据 `tree` 配置拼接 SQL 的逻辑见 `io.nop.biz.crud.TreeEntityHelper#buildTreeEntityBaseSql`，
也可以参考文档 [树形结构相关](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/orm/tree-structure.md)。

根节点默认以条件 `o.{parentProp} is null` 来过滤。如果指定了 `rootParentValue`
或 `rootLevelValue`，则以条件 `o.{parentProp} = ${rootParentValue}`
或 `o.{levelProp} = ${rootLevelValue}`，且以 `rootLevelValue` 来过滤根节点的优先级高于
`rootParentValue`。

### GraphQL 字段选择集合：`selections / selection` {#attr_selections_selection}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| id | string | 选择集合唯一标识 | 是 | 用于区分其他字段选择集合 |
| displayName | string | 显示名 | 否 | 方便人阅读 |

`<selection/>` 标签的 body 为
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
语法：

```xml
<meta>
  <selections>
    <selection id="F_defaults">
      userId, userName, status
    </selection>

    <selection id="F_moreFields">
      userId, userName, status, relatedRoleList{ roleId, roleName, permissionList{ id, name } }
    </selection>

    <selection id="copyForNew">
      status, description
    </selection>
  </selections>
</meta>
```

关于 `selection` 有如下内置约定：

- `id` 为 `copyForNew`：特定用于接口 `@mutation:{BizObjName}__copyForNew/id`
  做 ORM 实体的复制新增，指定默认的可被复制的属性。其实现逻辑见
  `io.nop.biz.crud.CrudBizModel#copyForNew`
  - 为了安全性，可复制内容不允许前端指定
- `id` 以 `F_` 为前缀：表示查询接口可以使用的 GraphQL Fragment 定义。其中，`F_defaults`
  表示默认可返回的字段集合，若未配置该 selection，则返回所有的缺省字段（非 lazy 加载的字段）
- `id` 为其余名称：其用途可根据业务需求自行决定。比如，通过
  `getObjMeta().getFieldSelection("my_selection")` 获得配置的字段，再调用
  `io.nop.biz.crud.CrudBizModel#doSave` 保存指定字段的数据

关于 `selection` 的使用：

- 指定返回默认字段：

```graphql
// 等价于 REST 调用: /r/Book__get?id=123
query {
  Book__get(id:123) {
    ...F_defaults
  }
}

// 等价于 REST 调用: /r/Book__get?id=123&@selection=...F_defaults,author
query {
  Book__get(id:123) {
    ...F_defaults,
    author {
      ...F_defaults
    }
  }
}

// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_defaults,groupMappings
query {
  NopAuthUser__findList {
    ...F_defaults, groupMappings{ ...F_defaults }
  }
}
```

- 指定返回其他字段：

```graphql
// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_moreFields
query {
  NopAuthUser__findList {
    ...F_moreFields
  }
}
```

### 对象属性列表：`props / prop` {#attr_props_prop}

<!-- prettier-ignore -->
| 属性 | 值类型 | 属性名 | 必填 | 说明 |
| --- | ------- | ---- | ---- | --- |
| name | prop-path | 属性名 | 是 | Java 复合属性名，可以由一个或者多个 `prop-name` 构成，通过字符 `.` 来分隔。注：`prop-name` 为 Java 属性名，一般由字母和数字、下划线组成，不包含字符 `.` 和 `$` |
| [schema](#attr_props_prop_schema) | `ISchema` | 属性 Schema | 否 | 对当前属性值类型、值精度等的约束定义 |
| displayName | string | 显示名 | 否 | 方便人阅读 |
| description | string | 属性描述 | 否 | 描述属性 |
| defaultValue | any | 属性默认值 | 否 |  |
| propId | int | 属性的顺序标识 | 否 | 可以对应于 protobuf 标准中的 `propId` 属性，同时也与 ORM 实体上的 `propId` 对应 |
| mapToProp | prop-path | 映射到 ORM 实体的指定属性 | 否 | 也就是为 ORM 实体的属性（注意，**不是当前对象的属性**）映射一个别名，如，将 ORM 实体的属性 `a.b` 映射到别名 `b` 上，在 GraphQL 返回结果时，会通过 `OrmDependsPropFetcher` 从 ORM 实体上获取 `a.b` 的值后赋值给对象的属性 `b`  |
| depends | csv-set | 当前属性所依赖的属性列表 | 否 | 逗号分隔的属性列表（需在 ORM 实体上有映射）。在获取当前属性的值时，需要依赖其他字段。例如，在批量加载当前属性时，需要把依赖的属性也进行批量加载 |
| mandatory | boolean | 属性值必填？ | 是 | 指示当前属性是否为必填项。默认为 `false` |
| internal | boolean | 是否内部属性？ | 是 | 内部属性一般仅在后端使用，对前端不可见。默认为 `false` |
| deprecated | boolean | 是否已废弃？ | 是 | 已废弃的属性将不再被使用。默认为 `false` |
| insertable | boolean | 是否可新增？ | 是 | 若为 `false`，则新增的 ORM 实体将不会插入该属性数据。默认为 `true` |
| updatable | boolean | 是否可更新？ | 是 | 若为 `false`，则更新的 ORM 实体将不会更新该属性数据。默认为 `true` |
| virtual | boolean | 是否虚拟字段？ | 是 | 虚拟字段不会被复制到 ORM 实体上。默认为 `false` |
| published | boolean | 是否对外开放？ | 是 | 为 `false` 时，则在 GraphQL 返回的对象中将不包含该属性，对外不可见，比如，密码等敏感属性。默认为 `true` |
| ~~readable~~ | boolean | 是否可查看？ | 是 | 若为 `false`，则在 GraphQL 返回的对象中将不包含该属性，该属性只能作为输入由前端传给后端，且能够复制到 ORM 实体上。默认为 `true`。**注意，其与 `published` 存在功能重复，可能会被移除！** |
| sortable | boolean | 是否可排序？ | 是 | 是否可以被作为排序字段出现在 SQL 的 `order by` 语句中。默认为 `false` |
| queryable | boolean | 是否可查询？ | 是 | 该属性对应的 ORM 表字段是否可以被作为查询字段出现在 SQL 的 `where` 语句中，与 `allowFilterOp` 配合，可限制在该属性对应的 ORM 表字段上能够应用的过滤运算。默认为 `false` |
| allowFilterOp | word-set | 允许的过滤运算 | 否 | 可以在该属性对应的 ORM 表字段上执行哪些查询运算，如 `gt`、`ge`、`contains`、`like`等，默认只允许 `in`、`eq` |
| lazy | boolean | 是否懒加载？ | 是 | 默认为 `false` |
| ext:kind | string |  | 否 | 可选值：<br />- `to-one`：当前对象与属性对应的对象为一对一关联；<br />- `to-many`：当前对象与属性对应的对象为一对多关联；<br />- `alias`：表示其为在 ORM 实体上定义的别名，通过该属性名，可以找到别名映射的源属性；<br />- `component`：表示其为 ORM 实体中的组件字段，比如，JSON 字段。注意，对于文件字段，会通过 `mapToProp` 映射到 ORM 实体对应组件字段的 `fileStatus`/`fileStatusList` 属性上，不再设置 `ext:kind="component"`； |
| tagSet | tag-set | 附加标识列表 | 否 | 逗号分隔的自定义标识列表。用于 CodeGen 在通过 `app.orm.xml` 生成 xmeta 时，会根据这些标识来设置其他属性的值。其实际来自于设置在 ORM 实体属性上的 `tagSet`。注意，**若是以 XMeta 为中心设计模型，是不需要该属性的** |
| graphql:type | string |  | 否 |  |
| graphql:mapper | string |  | 否 |  |
| graphql:labelProp | string |  | 否 |  |
| graphql:joinLeftProps | word-set |  | 否 |  |
| graphql:joinRightProps | word-set |  | 否 |  |
| graphql:connectionProp | prop-name |  | 否 |  |
| graphql:queryMethod | `dict:core/std-query-method` |  | 否 |  |
| graphql:datePattern | string |  | 否 |  |
| graphql:maxFetchSize | int |  | 否 |  |
| graphql:jsonComponentProp | string |  | 否 |  |
| graphql:dictName | string |  | 否 |  |
| graphql:dictValueProp | prop-path |  | 否 |  |
| graphql:authObjName | string |  | 否 |  |
| graphql:filter | filter-bean |  | 否 |  |
| graphql:orderBy | string |  | 否 |  |
| graphql:selection | field-selection |  | 否 |  |
| graphql:inputType | class-name |  | 否 |  |
| graphql:transFilter | `xpl-fn:(filter,query,forEntity)=>any` |  | 否 |  |
| ui:maskPattern | string | 掩码模式 | 否 | GraphQL 返回的数据会自动按照其指定的模式调用 `StringHelper#maskPattern` 函数对当前属性的值做掩码处理，如，`ui:maskPattern="3*4"` 表示保留前 3 位以及后 4 位字符，中间部分用\*来代替。可应用于安全性要求较高的属性上 |
| ui:labelProp | string |  | 否 |  |
| biz:moduleId | string |  | 否 |  |
| biz:codeRule | string |  | 否 |  |
| orm:manyToManyRefProp | string | 多对多关联的中间模型中另一方的属性名 | 否 | 仅用于多对多关联，其指向在中间模型中用于映射对端模型的属性。详细说明见 [XMeta 对象关联配置 - 多对多](#relations-many-to-many) |
| ext:relation | string | 关联映射到的属性名 | 否 | 详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one) |
| ext:joinLeftProp | string | 关联的源端对象的属性名 | 否 | 详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one) |
| ext:joinRightProp | string | 关联的目标端对象的属性名 | 否 | 详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one) |
| ext:joinRightDisplayProp | string | 关联的目标端对象的显示属性名 | 否 | 详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one) |
| transformIn | xpl |  | 否 |  |
| transformOut | xpl |  | 否 |  |
| getter | xpl |  | 否 |  |
| setter | xpl |  | 否 |  |
| [auth](#attr_props_prop_auth) | `ObjPropAuthModel` |  | 否 |  |
| [arg](#attr_props_prop_arg) | `ObjPropArgModel` |  | 否 |  |
| [autoExpr](#attr_props_prop_autoExpr) | `ObjConditionExpr` |  | 否 |  |

## XMeta 属性 Schema {#attr_props_prop_schema}

## XMeta 对象关联配置 {#relations}

### 一对一 {#relations-one-to-one}

```plantuml
class Left {
  + id: int
  + rightId: int
  + right: Right
}

class Right {
  + id: int
  + displayName: string
}

Left "1" -right-> "1" Right
```

根据以上图例所生成的 XMeta 为：

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

- `ext:relation` 用在 `Left`（关联的源端）直接与关联目标端（`Right`）建立关联的属性上，
  其指向在 `Left` 中与映射到关联目标端对象的属性上，如，`rightId -> right`；
- 在与关联目标端对象映射的属性上声明关联关系，包括：`ext:kind`、`ext:joinLeftProp`、`ext:joinRightProp` 等；
- `ext:kind` 设置为 `to-one`（一对一）模式关联 `Right`；
- `ext:joinLeftProp` 表示在 `Left`（关联的源端）中用于与 `Right`（关联的目标端）建立关联的属性；
- `ext:joinRightProp` 表示在 `Left`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
  `Right`（关联的目标端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Right`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 一对多 {#relations-one-to-many}

> 注意，一对多和一对一是互为反方向的关联配置，因此，二者是分别配置在关联的源端和目标端中的。

```plantuml
class Left {
  + id: int
  + rightId: int
  + displayName: string
}

class Right {
  + id: int
  + leftList: List<Left>
}

Right "1" -left-> "0..*" Left
```

根据以上图例所生成的 XMeta 为：

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftList"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
  </props>
</meta>
```

- `ext:kind` 设置为 `to-many`（一对多）模式关联 `Left`；
- `ext:joinRightProp` 表示在 `Left`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
- `ext:joinLeftProp` 表示在 `Left`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
  `Right`（关联的源端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Left`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 多对多 {#relations-many-to-many}

在 Nop 中是通过中间模型来建立多对多的关联，并通过中间模型将多对多分解为中间模型与关联双方的一对多关联：

> 详细的说明文件见 [多对多关联](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/orm/many-to-many.md)。

```plantuml
class Left {
  + id: int
  + rightMappings: List<Ref>
}

map Ref {
  leftId => rightId
}

class Right {
  + id: int
  + leftMappings: List<Ref>
}

Ref "1" -left-> "1" Left::id
Ref "1" -right-> "1" Right::id
```

根据以上图例所生成的 XMeta 分别为：

- 配置 `Left` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Right`

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="leftId"
          orm:manyToManyRefProp="rightId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedRightIdList"
          ext:relation="relatedRightList"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedRightList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Right"/>
      </schema>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Left`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Left`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Right`（即，多对多的目标端模型）建立关联的属性；
> - `relatedRightList` 和 `relatedRightIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Left` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Right` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Left`

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          orm:manyToManyRefProp="leftId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedLeftIdList"
          ext:relation="relatedLeftList"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedLeftList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Right`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Left`（即，多对多的目标端模型）建立关联的属性；
> - `relatedLeftList` 和 `relatedLeftIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Right` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Ref` 与 `Left` 和 `Right` 的一对一关联

```xml title="Ref.xmeta"
<meta>
  <props>
    <prop name="leftId" ext:relation="left">
      <schema type="java.lang.Integer"/>
    </prop>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="left"
          ext:kind="to-one"
          ext:joinLeftProp="leftId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Left"/>
    </prop>
    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-one`（一对一）模式关联 `Left` 或 `Right`；
> - `ext:joinLeftProp` 表示在 `Ref`（关联的源端）中用于与关联目标端（`Left` 或 `Right`）建立关联的属性；
> - `ext:joinRightProp` 表示在 `Ref`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
>   关联目标端（`Left` 或 `Right`）的属性；
> - `ext:relation` 用在 `Ref`（关联的源端）直接与关联目标端（`Left` 或 `Right`）建立关联的属性上，
>   其指向在 `Ref` 中与映射到关联目标端对象的属性上，如，`leftId -> left`、`rightId -> right`；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

## XMeta 解析 {#parser}
