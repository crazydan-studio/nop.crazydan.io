---
title: 什么是可逆计算？
description: 深入理解可逆计算所揭示的软件本质
draft: true
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

> 注意，此文还在整理中，可能存在错误，将来也会存在较大变动，请谨慎阅读。


**「可逆计算」**揭示了软件的本质 —— **一切皆树**，
也就是，软件世界内的所有形式都可以用**树结构**表示，
或者说，无论是数据还是代码，无论它们的存储形式是二进制还是文本，
其本质都是树结构在不同领域（或者说是「空间」）内的不同表现形式。

其明确和强化了树、领域空间、坐标系等概念，引入应用构造和演化的重要工具 —— **差量运算**，
并指出不同领域能力融合的本质是树结构的**形式变换**，从而将软件世界彻底地统一了起来。

其统一性体现在如下几个方面：

- 对 DSL 树结构的演化和定制机制是统一的，通过差量机制，便可以实现任意程度的组件复用和功能定制；
- 不同领域空间内的 DSL 在形式上是统一的，都是树形结构，都可以以一致的方式进行相互转换；
- 不同领域的能力可以以统一的方式实现集成和融合，不需要再为各个领域编写专有的解析器和执行器，
  通过 Nop 的元编程能力便可无缝引入其他领域的能力；

## 一切皆树 {#everything-is-tree}

可执行的二进制文件，是由指令和数据组成的，其本质是一棵描述指令执行和数据读写过程的树。

JSON、YAML 等是以文本形式表示某种树形结构的数据，目的只是为了方便人阅读和编写，
其本质完全相同，只是受限于编辑器的能力，会丢失或无法表示某些附加信息。

哪怕是文档，其必然也存在章节、段落、样式等结构信息，因此，其同样可用树结构进行表示。

代码则更不用说，其本质便是抽象语法树（AST）。

```
# 中心为树，周边为不同的表示形式，如，pdf、json、docx、AST 等
```

所以，树才是软件和数据的本质结构，其余的形式都是对树结构在不同空间内的不同表达和展现方式。

## 领域空间 {#domain-space}

不同的领域必然自动形成独立的**「领域空间」**，在该空间内拥有特定的树结构 —— DSL 树，
众多的 DSL 树将会形成 **DSL 森林**。

```
     O
    / \
  /    \
O1      O2
```

不同的领域空间之间是有明确的**边界**的，领域空间之间不能存在重叠部分，
不能将其他领域空间的问题和复杂性引入到当前领域空间中。

领域空间之间只能交互各自空间内所能识别和处理的 DSL，不同领域之间要实现能力共享，
则必须在 DSL 进入领域空间之间完成转换。

**编译**和**运行**，是软件开发所涉及的两个阶段。
编译阶段一般是从文本形式的源代码转换为物理计算机或编程语言虚拟机可执行的二进制文件，
在运行阶段，物理机或虚拟机便会根据编译后的结构进行指令执行和数据读写。

可以看到，编译和运行在本质上是两个不同的领域空间，前者处理的是程序语言的 DSL 结构，
后者处理的则是计算机指令 DSL。

而若要实现在运行时具备热加载或热更新的能力，则可以实时地将编译器编译后的可执行 DSL
交给运行时，而运行时并不需要内置动态的编译能力，其只需要通过通用形式的 DSL 加载器，
再由加载器根据 DSL 的路径或类型调用相应的编译器得到运行时的 DSL 结果即可。

## 坐标系 {#coordinate-system}

「空间」除了要求独立性之外，还必然需要用到**「坐标系」**这一强大的定位工具，
只有通过坐标系才能轻松地定位到 DSL 树中任意节点，然后，才能在节点上实施差量运算，并作形式变换。

在坐标系中，任何可以定位到目标节点的表示形式都可以视为**坐标**。
常见的有：文件路径、节点 ID、节点名称等。

## 什么是 DSL？ {#what-is-dsl}

DSL（Domain-Specific Language）意为领域设计语言，其用于设计和表示领域内的数据结构。

- DSL 编译器
- DSL 引擎
- DSL 虚拟机

## 树的转化

既然是「一切皆树」，那么不同的树之间必然存在相似性，以及可相互转换性。
**差量运算**便是可逆计算所提供的树之间的转换工具。

通过差量运算，可以实现对基础树的无限扩展和**版本演化**。

通过**形式变换**，则可以实现不同树之间的结构转换，从而保证不同领域空间的独立性和纯净性。
在领域空间内仅需关注和处理自己领域内的业务逻辑，在需要**融合**其他领域的能力时，
只需要通过形式变换，将外部领域的树结构变换为当前领域的树结构即可，
在当前领域内完全不需要学习和了解其他领域内的知识。

## 应用空间结构与状态迁移

- DSL 定义了应用的空间结构
- 某个应用版本就是一个确定的 DSL 结构的空间状态
- 应用的不同版本的开发过程，就是不同 DSL 状态的迁移过程
- 应用版本状态的迁移过程，就是状态迁移的运算规则的制定过程，而该过程可以有多种实现途径和方式
- 从项目管理角度，先确定每个版本的 DSL 状态，再按状态迁移推进项目进度，
  可能会有很大助益，并可避免开发过程的反复和不确定性

## 指导意义

在软件开发过程中，仅需按照理想的 DSL 结构进行设计和驱动逻辑的开发，
而不需要过于关注其在其他领域的表现形式。

在需要对接其他领域的能力时，也只需要通过 Nop 的 `x:gen-extends`
元编程能力对理想的 DSL 做形式变换，将其转换为目标领域的 DSL 即可。
不需要专门为目标领域编写特有的转换代码，更不需要实现特有的解释器。

理想的软件世界是，不再需要为各个领域反复编写各种形式的解析器，通过
Nop 等可逆计算的实现，便可以很方便地向自己的软件中引入不同领域的能力，
可以无缝地支持多种编辑器、设计器等展现工具。

代码生成并不意味着一定要把代码拆分为类和方法来生成，类空间不过是通用的模型空间的一种，
我们可以采用其他的领域模型空间来表达逻辑。
