---
title: NopGraphQL 引擎
description: 分析 NopGraphQL 引擎的设计与实现
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

NopGraphQL 引擎为 Nop 平台的业务层实现方案，其负责对业务对象的业务处理，
并最终调用 [NopORM 引擎](./orm)进行数据存取。

与传统的 MVC 架构模式不同的是，NopGraphQL
引擎同时替代了控制器层（Controller）和服务层（Service）的职能，
让应用的层级结构变得更加简单。并且，NopGraphQL 引擎自身是
[框架中立](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/theory/framework-agnostic.md)
的，没有依赖于 Web Servlet、Hibernate 等具体实现，
因此，在自动化测试，非 Web 应用开发，以及与其他框架集成等方面，具有更加灵活的优势。

下图为 NopGraphQL 引擎在业务处理过程中的数据流转情况：

<!-- https://plantuml.com/deployment-diagram -->

```plantuml
actor " " as client_1
actor " " as client_2
actor " " as client_3
actor " " as client_n

rectangle "NopGraphQL" as graphql {
  port "GraphQL" as api_p1
  port "REST" as api_p2
  port "gRPC" as api_p3
  port "..." as api_pn

  control "GraphQL\nAdaptor" as api_graphql_adaptor
  control "RPC Adaptor" as api_rpc_adaptor

  component "GraphQLEngine" as engine {
    port "~#executeGraphQLAsync()" as api_call_graphql
    port "~#executeRpcAsync()" as api_call_rpc
    port " " as api_return_graphql
    port " " as api_return_rpc

    component biz_obj_man [
      <b>BizObjectManager
    ]
    component "GraphQLExecutor" as executor {
      port "~#executeAsync()" as action_graphql
      port "~#executeOneAsync()" as action_rpc

      component op [
        <b>GraphQLOperation
      ]
      component selection [
        <b>GraphQLFieldSelection
      ]

      component action [
        <b>ServiceActionFetcher
        ====
        实际调用函数 <b>{bizModel}#{action}
        并返回执行结果 <b>Object
      ]

      op -down(0)->> selection: 调用\n~#getSelections()
      selection -up(0)->> action: 调用\n~#getFetcher()

      action -up-> action_graphql: Object
      action -up-> action_rpc: Object

      action_graphql -> api_return_graphql: GraphQLResponseBean
      action_rpc -> api_return_rpc: ApiResponse
    }

    file "{\nquery: 'query ...',\nvariables: { ... }\n}" as query
    file "~*.xmeta" as xmeta
    file "~*.xbiz" as xbiz

    api_call_graphql -> query
    api_call_rpc -> query

    api_return_graphql .> api_graphql_adaptor
    api_return_rpc .> api_rpc_adaptor

    query -down-> biz_obj_man: GraphQLDocument
    xmeta -up-> biz_obj_man: IObjMeta
    xbiz -up-> biz_obj_man: IBizModel

    biz_obj_man ..|> op: 缓存\nGraphQLOperation
  }

  api_p1 <-down-> api_graphql_adaptor
  api_p2 <-down-> api_rpc_adaptor
  api_p3 <-down-> api_rpc_adaptor
  api_pn <-down-> api_rpc_adaptor

  api_graphql_adaptor -down-> api_call_graphql: GraphQLRequestBean
  api_rpc_adaptor -down-> api_call_rpc: ApiRequest\n+ operationName\n+ operationType
}

client_1 <-down-> api_p1: /graphql
client_2 <-down-> api_p2: /r/\n/p/\n/f/
client_3 <-down-> api_p3
client_n <-down-> api_pn: ...
```

> - GraphQL/RPC Adaptor 包括 `io.nop.graphql.core.web.GraphQLWebService`
>   的实现类、`io.nop.rpc.grpc.server.GraphQLServerCallHandler` 等

**业务对象**（`BizObject`）为 NopGraphQL 引擎所驱动的核心模型。

<!--
Nop 平台的后端服务使用 NopGraphQL 引擎实现。NopGraphQL 引擎没有使用 graphql-java 包，
是完全从零开始实现的一个新的 GraphQL 引擎。相比于 graphql-java，它充分利用了可逆计算原理，
极大减少了需要手工编写的代码量，提高了运行时性能。此外，NopGraphQL 支持模型动态加载，
支持 REST 调用接口与 GraphQL 调用接口。

Nop 平台是可逆计算理论的实现，因此，其业务组件必然是围绕组件的 DSL 进行设计和开发的，而
NopGraphQL 引擎实际上便是 XMeta 的执行引擎，负责客户端和服务端的业务数据交互和存储相关的工作。

XMeta 对应的业务对象并没有生成相应的 Java Class，因为，其核心作用是描述业务结构和数据约束，
在 NopGraphQL 只需要对客户端提交的数据以 Map 形式表达，再按 XMeta 结构进行字段校验和数据转换，
最终转换结果也仅需遍历 Map 并复制到 ORM Entity 的对象实例上即可，没有必要再通过中间的 Class
对象做转换数据的承载工作。

以 [XMeta](../../manual/xmeta) 为蓝本，构造**聚合根**，客户端的操作均以聚合根为中心展开？

> 注意，无论是浏览器、移动应用，还是普通的接口调用，其请求发送方，均统称为**客户端**，而
> NopGraphQL 所在的位置则为**服务端**。

XMeta 为 Nop 平台提供了标准化的**对象元数据**模型，所有需要定义对象结构的地方都统一使用 XMeta 模型来定义。

> XMeta 和 XDef 可以相互转换。XDef 对应于 XML 结构，而 XMeta 对应于对象属性结构。

NopGraphQL 会根据 XMeta 配置生成对外暴露的 GraphQL 类型。

XMeta 定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改、是否可以用于查询等信息。
NopGraphQL 引擎返回的对象信息也完全由 XMeta 来定义。

- 实体元数据
  > Nop 平台的代码生成器会自动根据 ORM 模型为每个实体生成一个对应的 XMeta 文件，
  > 每个实体属性都会对应生成一个对象 prop 配置，在此基础上还会根据一对多、多对多等关联配置生成生成一些辅助属性。
- 对象元数据
  > xmeta 文件定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改，是否可以查询等信息。
  > NopGraphQL 引擎返回的对象信息完全由 XMeta 来定义。如果一个属性在 XMeta 中没有定义，则即使实体上具有这个字段，
  > 前台 GraphQL 和 REST 请求也无法访问到该字段。

Nop 平台内置了一个自动化的后台管理软件生产线，它的输入是用户需求（以 Excel 文档的形式表达），
输出是可运行的应用系统，主要通过系统化的增量式代码生成方案来实现生产线的运转。这其中，GraphQL
Schema 是根据 Meta 元数据定义和 BizModel 业务模型定义自动生成的一种中间产物，
我们并不会手工编写 GraphQL 类型定义，在编写业务代码的过程中也不需要具有任何 GraphQL 相关的知识，
不需要实现 GraphQL 特有的 DataFetcher、DataLoader 等接口。
-->

XMeta 只是定义了聚合根的结构，并未创建相应的 Java Class 实体，而其关联的
`<entityName />` 只是其结构中一部分需持久化的映射，并且，其实际可由多个
ORM 实体映射而成，只是会以某个 ORM 实体作为主体。当然，XMeta 也可以不映射任何
ORM 实体，仅仅是一个过程处理对象。

## BizObject {#biz-object}

```plantuml
interface "IBizObject" as biz_obj {
  bizModel: IBizModel
  objMeta: IObjMeta
}

interface "IBizModel" as biz_model {
  actions: List<IBizActionModel>
}

interface "IBizActionModel" as biz_action {
}

interface "IObjMeta" as obj_meta {
  props: List<IObjPropMeta>
}

interface "IObjPropMeta" as obj_prop_meta {
}

interface "IOrmEntity" as orm_entity {
}

biz_obj "1" *-- "1" biz_model: 包含 >
biz_obj "1" *-- "1" obj_meta: 包含 >

biz_model "1" *-- "*" biz_action: 包含 >
obj_meta "1" *-- "*" obj_prop_meta: 包含 >

obj_meta -right- orm_entity: 映射
```

<!-- https://plantuml.com/sequence-diagram -->

```plantuml

autonumber "<b>[000]"

actor "User" as user
entity "GraphQLEngine" as graphql
entity "ObjMeta" as meta
entity "BizModel" as biz
entity "OrmEntity" as orm

```

## GraphQL 协议 {#proto-graphql}

```plantuml
class "GraphQLDocument" as doc {
}
class "GraphQLOperation" as op {
}
class "GraphQLFieldDefinition" as field {
}
class "GraphQLFieldSelection" as field_selection {
}
class "GraphQLFragmentSelection" as fragment_selection {
}
class "GraphQLDirectiveDefinition" as directive {
}
class "GraphQLVariableDefinition" as var {
}
```

```json
{
  "operationId": "",
  "operationName": "",
  "query": "query Xxx__findList($query:QueryBeanInput){\nXxx__findList(query:$query){\nvalue:id,label:displayName,code\n}\n}",
  "variables": {
    "query": {}
  }
}
```

<!--
## 聚合根

聚合不是为了实现事务

- 主分解维度，门面模式
  面向对象而不是面向 DTO，不是面向 ID
- 全局关系 + 内部的局部关系。不同比例尺的地图
- 信息尽在指尖
- 实体 + 延迟加载 + session 缓存：结构聚合
- BizObject: 行为聚合
- GraphQL: 结构的选择和组合

聚合根首先是逻辑的聚合，BizModel 的切片构造就是一种聚合方式，
这种做法不是传统的面向对象中的继承方式和组合方式。
另外聚合的对偶概念是动态切片，GraphQL 恰好提供了一种在获取信息时的一种动态切片能力，
使得我们可以在概念层面上维持一个庞大的聚合根概念，但是在实际层面每次都只加载少量数据。
没有对偶的切片概念，本身聚合根就会非常臃肿，成为性能的拖累。

## 利用 XMeta 元数据模型统一动态处理模式

一般的函数复用只是复用一模一样的处理逻辑，最多是通过几个回调函数来提供有限的扩展点，
但很多时候并不存在完全一样的处理逻辑，**我们能够抽象只是一种处理模式**。
例如，save 函数的基本处理逻辑如下：

1. 验证前台提交的字段信息
2. 对于支持逻辑删除的实体，需要检查是否存在标记为删除的实体
3. 检查数据库中不存在重复的记录，比如不允许多个用户具有同样的身份证等
4. 根据请求数据创建实体对象，对于复杂的主子表结构需要进行特殊处理

每种不同实体的 save 逻辑的整体结构是完全一致的，但具体的细节不同。
比如每个字段的类型和校验规则都不同，部分字段还需要执行转换逻辑，
将前台传入的值转换为后台要求的格式等。不同实体上用于区分唯一性的字段也不同。
在 Nop 平台中每个业务对象都可以关联一个 XMeta 文件，通过它可以定义业务对象的元数据。

> XMeta 元数据比 Java 的注解要更加灵活和强大，它支持元编程和自定义扩展，
> 通过 XDef 元模型自动进行结构校验。

使用 XMeta 还有一个好处是支持 Delta 定制。
我们在不同的应用中对于同一个业务对象可以使用不同的 XMeta 模型，
从而定制实际处理的内容。如果使用强类型的 DTO 对象就很难在不修改基础产品源码的情况下实现逻辑定制。

GraphQL 的对象组合能力与 XMeta 的对象结构抽象能力，
以及可逆计算的差量化能力结合在一起，可以将大部分 CRUD 相关的逻辑固化下来。
一般不需要编写 CRUD 相关的代码，也不需要针对不同的场景生成大量代码，
通过统一的实现即可完成主体需求，我们最多只需要向 CRUD 模型补充偏离标准 CRUD 处理过程的差量信息即可。

CrudBizModel 采用的是元数据驱动的实现方式，它会读取 xmeta 配置文件中的内容，
内置实现了数据验证、自动初始化、级联删除、逻辑删除、数据权限等多种常见需求，
所以一般情况下只需要调整 xmeta 和 xbiz 配置文件，并不需要编写定制逻辑。

1. 数据验证：类似于 GraphQL 的输出选择，NopGraphQL 可以对输入字段进行选择性验证和转换，这体现了**输入和输出的对偶性**。

   ```js
   validatedData = new ObjMetaBasedValidator(
     bizObjManager,
     bizObjName,
     objMeta,
     context,
     checkWriteAuth
   ).validateForSave(input, inputSelection);
   ```

2. 自动初始化：在 meta 中可以配置字段的 autoExpr 表达式，
   更新或者修改的时候可以根据该配置自动初始化字段值。autoExpr
   表达式可以根据数据模型中的 domain 配置自动生成。

3. 自动转换：根据 meta 中配置 transformIn 表达式，对输入的属性值进行适配转换。
   transformIn 表达式可以根据数据模型中的 domain 配置自动生成。

4. 级联删除：标记为 cascade-delete 的子表数据会随着主表数据的删除一并删除，
   而且会执行子表对应的 BizObject 业务对象上的定义的删除逻辑。

5. 逻辑删除：如果启用 delFlag 逻辑删除标记字段，则底层的 ORM
   引擎会自动将删除调用转换为修改 delFlag 的操作，并且对所有查询都自动应用
   delFlag=0 的过滤条件，除非明确在 SQL 对象上设置 disableLogicalDelete 属性。

6. 数据权限：所有读取到的实体记录都会自动验证是否满足数据权限要求。

## GraphQL 对象：BizModel {#biz-model}

NopGraphQL 引擎在初始化的时候会利用 IoC 容器的动态扫描能力发现所有标记了`@BizModel`注解的
bean，并把它们按照 BizObjName 配置进行归类合并。

NopAuthUserBizModel 和 NopAuthUserBizModelEx 的 BizObjectName 都是
NopAuthUser，它们的方法会叠加在一起共同生成 NopAuthUser 业务对象上的方法。当出现同名的函数时，会按照`@Priority`
优先级配置选择优先级更高的实现。如果优先级相同且函数名相同，则会抛出异常。

NopGraphQL 引擎在构造 BizObject 的时候还会检查 xbiz 扩展模型，我们可以通过在 NopAuthUser.xbiz
模型文件中增加方法来扩展 BizObject，这个模型文件可以在线更新，更新后会即时起效，无需重新初始化 GraphQL
类型定义。xbiz 文件中定义的方法优先级最高，它会自动覆盖 JavaBean 中定义的业务方法。

如果把对象名相同的 BizModel 看作是对象的一个切片，则 NopGraphQL
引擎相当于是在系统初始化的时候动态收集这些对象切片，然后像 docker
镜像一样把它们叠加在一起，构成完整的对象定义。在运行时，最上层的
xbiz 切片可以被动态修改，并覆盖下层切片的功能。

> BizModel 切片的概念有些类似于游戏开发领域中的 Entity Component System (ECS)模式，只是它累加的是动态行为而不是局部状态。

与 Gather 对偶的能力是 Scatter：我们经常需要做一些全局规则的抽象，
需要将某些公共知识自动推送到不同的业务对象中。NopGraphQL 主要通过
AOP 机制和元编程机制来实现信息的分发：

1. 公共的机制可以作为 AOP 拦截器作用于符合条件的业务方法上

2. xbiz 文件中可以通过 XLang 中通用的 x:gen-extends 元编程机制动态生成方法定义。
   也可以使用外部的 CodeGenerator 来生成代码。

在 xbiz 文件中可以直接编写 query,muation, loader 等函数定义，它们会覆盖 Java 的 BizModel 中的相应函数实现。
也就是说，对外暴露的 BizObject 是由所有的 BizModel 类以及 XBiz 模型文件中定义的所有函数所组成的，在 BizObjectManager 启动的时候会扫描
系统中所有的 BizModel 类，以及 XBiz 模型文件，生成对应的 BizObject 对象。

**XBiz 中定义的函数优先级最高，如果与已有的函数同名，则会自动覆盖**

- nop-graphql-core 提供了 GraphQL 的执行引擎，协调多个 DataFetcher 并行获取数据，并且提供了 RPC 调用接口封装

- nop-graphql-orm 提供了使用 NopORM 引擎实现的各种 DataFetcher

- nop-dao 提供了 JDBC 封装、事务封装以及数据库 Dialect 机制

- nop-orm-model 提供了实体模型定义，而 nop-orm-eql 提供了 EQL 语法的解析器。这两个模块可以独立于 nop-orm 引擎被使用

- nop-orm 实现了一个包含 Hibernate 和 MyBatis 所有核心功能的 ORM 引擎

- nop-biz 中的 BizObjectManager 提供了 IGraphQLSchemaLoader 接口的实现，将 GraphQL 调用映射到 BizModel 的方法上。
  这个过程类似于 REST 框架将 URL 链接映射到 Controler 类的方法上。nop-biz 模块内置了 CRUD 服务和字典表服务。

- nop-biz 通过 nop-fsm 内置了有限自动机机制，可以描述某些简单的业务流程

- nop-biz 并不强依赖于 NopIoC 容器，但是依赖 nop-ioc 模块可以利用模块内置的 beans.xml 配置。

**服务函数可以看作是某种执行 DSL 的虚拟机，传入的参数不同会指导虚拟机执行不同的处理逻辑**。
举个具体的例子，CrudBizModel 中提供的 findPage/findList 等通用查询函数，
它们所接收的查询条件对象 QueryBean 就可以看作是一种 DSL，它描述了针对一个复杂对象结构的组合查询条件。

### 通过元编程增强 XBiz 模型

一旦引入 XBiz 这样的 DSL 模型文件，就可以立刻施展标准化的元编程套路，
为 DSL 模型引入更多的自定义扩展。例如，在 XBiz 文件中，我们可以通过如下方式引入逻辑编排支持。

```xml
<biz>
  <x:post-extends>
    <biz-gen:TaskFlowSupport xpl:lib="/nop/core/xlib/biz-gen.xlib"/>
  </x:post-extends>

  <actions>
    <mutation name="callTask" task:name="test/DemoTask"/>
  </actions>
</biz>
```

- `x:post-extends`在模型解析的编译期自动执行，通过`<biz-gen:TaskFlowSupport>`
  标签会自动对具有`task:name`的函数节点进行变换，自动生成调用 TaskFlowManager 的代码。

- 我们可以使用可视化的逻辑编排设计器来设计`Task`，然后在 XBiz 模型中只要为服务函数指定它所关联的`task:name`即可。

### BizLoader {#biz-model-biz-loader}

1. `@BizQuery`表示本方法将被映射为 GraphQL 中的 query 调用，`@BizMutation`
   将被映射为 GraphQL 中的 mutation 调用。

2. `@BizLoader`为 GraphQL 类型的属性提供 fetcher 和 loader 定义。
   注意，为了保证概念的简单性，NopGraphQL 要求所有属性都必须在 xmeta 文件中声明，
   BizModel 中仅是为已定义的属性提供定制的加载器。

3. 如果返回值类型为 CompletionStage，则表示该方法异步执行

4. 如果标注了`@BizLoader`注解的方法的 ContextSource 参数为 List
   类型，则表示它对应 GraphQL 的 DataLoader 实现，支持批量加载。

### 没有实体定义的情况下也可以写 BizModel 吗？

可以，Nop 平台的整体设计是分层的，后一层不依赖于前一层。
自己写一个 BizModel 类即可，参见 LoginApiBizModel。

通过 Nop 平台的代码生成器，我们可以根据 Excel 中的数据模型定义一路推导得到前端页面，
但是每个推导步骤都是可选步骤，并不一定需要前一个步骤的存在。

参考 LoginApiBizModel 的实现，我们可以在 Java 中直接编写一个 BizModel 类，
然后在某个 beans.xml 中注册，即可通过 NopGraphQL 引擎来调用。

> LoginApiBizModel 实现 ILoginSpi 接口仅仅是为了提高代码可读性和可维护性，
> 并不是必须的。一个 BizModel 类可以不继承任何基类，也不需要实现任何接口，
> 本质上 BizModel 与 Spring 框架中的 Controller 类似，只是它不依赖于任何 Web 运行时环境，
> 返回结果也不要求是 POJO 等可以直接进行 JSON 序列化的对象。
> （BizModel 中函数的返回值会经过 NopGraphQL 引擎处理后得到返回值）

使用 NopGraphQL，一般没有必要再区分 Controller 和 Service，
直接在 Service 上增加@BizModel 注解（并注册在 beans.xml）中即可直接将服务发布为 Web 服务。
通过 meta 层可以进行返回结果增强和后处理等，即 NopGraphQL 本身提供了一个弹性适配层，
很多情况下都没有必要再增加一个对象来实现适配。

## 数据权限控制 {#data-auth}

## 在 Biz 模型中调用 validator 模型 {#biz-validator}

Nop 平台中的后台服务函数不一定在 Java 类中实现。在进行无代码开发的时候，
后台服务函数可以写在 xbiz 模型文件中，biz 模型支持在线编辑、动态加载，
在不停机的情况下可以增加后台 GraphQL 服务函数，并立刻起效。

testValidator3 函数通过`biz:RunValidator`标签函数来装载外部的 validator 模型文件，
并执行验证逻辑。这样做的好处是未来可以通过 Delta 定制机制来修改验证逻辑，而不用修改 Demo.xbiz 文件。

```xml
<biz:RunValidator xpl:lib="/nop/core/xlib/biz.xlib"
                  validatorPath="/nop/demo/validator/process-card.validator.xml"
                  obj="${{entity,firstProductionOrder:entity.productionOrder,firstMaterial}}"/>

```

> Biz 模型是 XML 格式，因此可以通过一个可视化设计器来在线设计 Biz 模型。
> 对于具体的 Action，也可以通过可视化拖拽的方式来实现。
> 例如，将`<biz:RunValidator>`标签看作是一个组件，validatorPath 等是组件的属性，
> 可以从面板中拖拽对应的组件到 Action 容器中，从而实现可视化的逻辑编排

### 通过元编程将 Validator DSL 嵌入到 Biz 模型中

Demo.xbiz 文件中的 testValidator2 函数演示了另外一种执行 Validator 验证逻辑的方式。
它通过宏标签将 Validator 模型嵌入到 Biz 模型中，
在编译宏标签的时候将会把对应节点的内容传入 ValidatorParser 中进行解析得到 ValidatorModel，
在运行期直接使用作为全局变量存在的 ValidatorModel 即可。

```xml
<biz:Validator xpl:lib="/nop/core/xlib/biz.xlib" fatalSeverity="100"
               obj="${{entity,firstProductionOrder:entity.productionOrder,firstMaterial}}">

    <check id="checkTransferCode" errorCode="test.not-transfer-code"
           errorDescription="扫入的码不是流转码">
        <eq name="entity.flowMode" value="1"/>
    </check>
</biz:Validator>
```
-->

## 时序图

以 Quarkus 集成并发送如下请求为例：

```json title="/graphql"
{
  "query": "query PageProvider__getPage($path:String){\nPageProvider__getPage(path:$path)\n}",
  "variables": {
    "path": "/xxx/pages/Xxx/main.page.yaml"
  }
}
```

请响应逻辑如下：

<!-- https://plantuml.com/sequence-diagram -->

```plantuml
autonumber "<b>[000]"

entity "浏览器" as browser
entity "QuarkusGraphQLWebService" as service
entity "GraphQLEngine" as engine
entity "GraphQLExecutor" as executor

browser -> service: /graphql:\n在请求 body 中携带\nJSON 格式的 GraphQL 数据
activate service
  service -> service: ~#graphql(body)
  activate service
    service -> service: ~#runGraphQL(body)
    activate service
      service -> service: BeanContainer#getBeanByType(\n  IGraphQLEngine.class\n):\n -> GraphQLEngine
      service -> service: 将 body 反序列化为\nGraphQLRequestBean: request

      service -> engine: ~#newGraphQLContext(request)
      activate engine
        engine -> engine: ~#parseOperation(\n  request.getQuery(): query\n)
        activate engine
          engine -> engine: ~#parseOperationFromText(query):\n-> GraphQLDocument

          engine -> engine: 返回 GraphQLDocument
        deactivate engine

        engine -> service: 返回携带 GraphQLDocument 的\nGraphQLExecutionContext: context
      deactivate engine

      service -> engine: ~#executeGraphQLAsync(context)
      activate engine
        engine -> executor: ~#executeAsync(context)
        activate executor
          executor -> executor: ~#invokeOperations
          activate executor
            executor -> executor: ~#_invokeOperations
            activate executor
              executor -> executor: ~#invokeOperationOrTry
              activate executor
                executor -> executor: GraphQLFieldDefinition\n~#getFetcher():\n-> ServiceActionFetcher

                executor -> executor: 返回异步 OperationResult:\n其由异步调用\nServiceActionFetcher#get\n得到
              deactivate executor

              executor -> executor: 返回异步 OperationResult
            deactivate executor

            executor -> executor: 返回异步 OperationResult
          deactivate executor

          executor -> executor: 异步转换 OperationResult\n为 GraphQLResponseBean
          executor -> engine: 返回异步\nGraphQLResponseBean
        deactivate executor

        engine -> service: 返回异步 GraphQLResponseBean
      deactivate engine

      service -> service: 异步转换 GraphQLResponseBean\n为 Response
      service -> service: 返回异步 Response
    deactivate service

    service -> service: 返回异步 Response
  deactivate service

  service -> browser: 返回 JSON 数据
deactivate service
```

`ServiceActionFetcher` 与对应的 `@BizModel` 进行绑定（在调用
`GraphQLEngine#parseOperationFromText` 时做的绑定），
在调用其 `#get` 函数时，将实际调用绑定的 `@BizModel`
对应的 `@BizQuery` 函数。

`GraphQLEngine#parseOperationFromText` 的执行逻辑如下：

```plantuml
autonumber "<b>[000]"

entity "GraphQLEngine" as engine
entity "GraphQLSelectionResolver" as resolver
entity "BizObjectManager" as biz_man
entity "BizObjectBuilder" as biz_builder

engine -> engine: ~#parseOperationFromText(query)
activate engine
  engine -> engine: GraphQLDocumentParser\n~#parseFromText(query):\n-> GraphQLDocument: doc

  engine -> engine: ~#initDocument(doc)
  activate engine
    engine -> engine: ~#resolveSelections(doc)

    engine -> resolver: ~#resolveSelection(doc)
    activate resolver
      resolver -> resolver: ~#resolveOperation(\n  doc, GraphQLOperation: op\n)

      resolver -> engine: ~#getOperationDefinition:\n获取 GraphQLFieldSelection\n的 GraphQLFieldDefinition
      activate engine
        engine -> biz_man: ~#getOperationDefinition
        activate biz_man
          biz_man -> biz_man: ~#getBizObject(bizObjName)
          activate biz_man
            biz_man -> biz_man: ~#buildBizObject(bizObjName)

            biz_man -> biz_builder: ~#buildBizObject(bizObjName)
            activate biz_builder
              biz_builder -> biz_builder: ~#loadBizObjFromModel(bizObjName):\n-> BizObjectImpl: bizObj

              biz_builder -> biz_builder: ~#buildOperations(bizObj)
              activate biz_builder
                biz_builder -> biz_builder: ~#buildActionOperation(bizObj)
                activate biz_builder
                  biz_builder -> biz_builder: BizModelToGraphQLDefinition\n~#toOperationDefinition:\n构造 GraphQLFieldDefinition，\n并与 ServiceActionFetcher 绑定

                  biz_builder -> biz_builder: 返回 GraphQLFieldDefinition
                deactivate biz_builder

                biz_builder -> biz_builder: BizObjectImpl 与\nGraphQLFieldDefinition 绑定
                biz_builder -> biz_builder:
              deactivate biz_builder

              biz_builder -> biz_man: 返回 BizObjectImpl
            deactivate biz_builder

            biz_man -> biz_man: 返回 BizObjectImpl
          deactivate biz_man

          biz_man -> biz_man: BizObjectImpl\n~#getOperationDefinition
          biz_man -> engine:
        deactivate biz_man

        engine -> resolver:
      deactivate engine

      resolver -> resolver: ~#resolveFieldSelection:\n绑定 GraphQLFieldSelection\n与 GraphQLFieldDefinition
      resolver -> engine:
    deactivate resolver

    engine -> engine:
  deactivate engine

  engine -> engine: 返回 GraphQLDocument
deactivate engine
```

在 `BizObjectBuilder#buildBizObject` 中会构造 `@BizModel`
的 GraphQL 对象结构，并与其 xmeta 定义进行合并。

## 注意事项

## 参考资料

- [面向对象的 GraphQL](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/graphql-java.md)
- [低代码平台中的分布式 RPC 框架](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/microservice/rpc-design.md)
- [Nop 入门：极简服务层开发](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/simple/1-simple-service.md)
- [从可逆计算看后端服务函数的可扩展设计](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/biz-customization.md)
- [Biz 模型](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/xbiz.md)
- [GraphQL 为什么流行不起来？是设计不足还是设计过度？](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/qa-about-graphql.md)
- [验证模型](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/validator.md)
- [CrudBizModel 中的自动验证](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/validate.md)
