---
title: NopGraphQL 引擎
description: 分析 NopGraphQL 引擎的设计与实现
authors:
  - flytreleft
---

import Header from '@site/docs/\_header.md';

<Header />

:::warning

本文还在编写中，内容随时会发生变化，也会存在大量错误，请谨慎阅读！

:::

NopGraphQL 引擎为 Nop 平台的业务层实现方案，其负责对业务对象的业务处理，
还可以通过 [NopORM 引擎](./orm)对数据进行存取操作。

与传统的 MVC 架构模式不同的是，NopGraphQL
引擎同时替代了控制器层（Controller）和服务层（Service）的职能，
让应用的层级结构变得更加简单。并且，NopGraphQL 引擎自身是
[框架中立](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/theory/framework-agnostic.md)
的，没有依赖于 Web Servlet、Hibernate 等具体实现，
因此，在自动化测试，非 Web 应用开发，以及与其他框架集成等方面，具有更加灵活的优势。

## 术语解释 {#term}

- **客户端**：浏览器、第三方调用等 Web 接口调用的发起方，均统称为客户端；
- **业务对象**：描述并承载应用业务数据的对象；
- **业务处理函数**：对业务对象进行相关处理的代码实现；

## 关于 GraphQL {#about-graphql}

> - 关于 GraphQL 的详细介绍请阅读 [《GraphQL 从入门到起飞》](https://juejin.cn/post/6897173001373483021)
> - [Nop 平台采用 GraphQL 作为服务实现的原因？](https://chatglm.cn/share/Fj0iT)

顾名思义，NopGraphQL 引擎本质是 [GraphQL](https://graphql.org/learn/) 的服务端实现，
其会按照客户端给定的 [GraphQL Document](https://spec.graphql.org/October2021/#sec-Document)
执行 [GraphQL Operation](https://spec.graphql.org/October2021/#sec-Language.Operations)
并返回相应的 [GraphQL Field](https://spec.graphql.org/October2021/#sec-Language.Fields)
数据。当然，NopGraphQL 对 GraphQL 也做了增强处理，同时去掉了一些无关的设计，让 GraphQL
更加适配 Nop 平台的要求。

GraphQL Document（GraphQL 文档）语法的主要结构如下：

```plantuml
@startmindmap
top to bottom direction

<style>
mindmapDiagram {
  .opt {
    LineStyle 2
  }
  .scalar {
    LineThickness 0
  }
}
</style>

* Document
  * Operation
    * OperationType
      * query <<scalar>>
      * mutation <<scalar>>
      * subscription <<scalar>>
    * [[https://spec.graphql.org/October2021/#Name Name]] <<opt>>
    * VariableDefinitions <<opt>>
      * ( <<scalar>>
      * VariableDefinition
        * Variable
          * $ <<scalar>>
          * [[https://spec.graphql.org/October2021/#Name Name]] <<scalar>>
        * : <<scalar>>
        * [[https://spec.graphql.org/October2021/#Type Type]] <<scalar>>
        * DefaultValue <<opt>>
          * <U+003D> <<scalar>>
          * [[https://spec.graphql.org/October2021/#Value Value]] <<scalar>>
      * , <<scalar>>
      * VariableDefinition
      * , <<scalar>>
      * ...
      * ) <<scalar>>
    * <b>SelectionSet</b>
      * { <<scalar>>
      * Selection
        * Field
          * Alias <<opt>>
            * [[https://spec.graphql.org/October2021/#Name Name]] <<scalar>>
            * : <<scalar>>
          * [[https://spec.graphql.org/October2021/#Name Name]] <<scalar>>
          * Arguments <<opt>>
            * ( <<scalar>>
            * Argument
              * [[https://spec.graphql.org/October2021/#Name Name]] <<scalar>>
              * : <<scalar>>
              * [[https://spec.graphql.org/October2021/#Value Value]] <<scalar>>
            * , <<scalar>>
            * Argument
            * , <<scalar>>
            * ...
            * ) <<scalar>>
          * <b>SelectionSet</b> <<opt>>
      * , 或 \\n <<scalar>>
      * Selection
      * , 或 \\n <<scalar>>
      * ...
      * } <<scalar>>
@endmindmap
```

例如，在 GraphQL Document 中定义一个 `OperationType`（操作类型）为 `query`，
但未指定 `Name`（名字）的 `Operation`（操作）：

<!-- prettier-ignore -->
```graphql
# 定义 Operation
query (
  # 定义 VariableDefinition，其中，QueryBeanInput 为 NopGraphQL 的内置输入类型
  $query: QueryBeanInput
) {
  # 定义 Field
  UserEntity__findPage(
    # 定义 Argument，并引用 Operation 中的变量 $query 作为参数 query 的值
    query: $query
  ) {
    total
    items {
      id, name
      # 定义指定了 Alias 的 Field
      roles: roleList(limit: 10) {
        items { id, name }
      }
    }
  }
}
```

上例中，在 GraphQL Operation 上定义了一个类型为 `QueryBeanInput`
的变量 `$query`，该变量需由客户端随 GraphQL 端点调用一起传给服务端，
再由服务端将其转换（采用 JSON 反序列化等方式）为 `QueryBeanInput` 对象后，
传递到 GraphQL Field 的参数列表中。

在 GraphQL Operation 中定义的 `SelectionSet` 为嵌套的选择字段（`GraphQL Field Selection`），
最终执行 GraphQL Operation 的结果需按该嵌套结构逐级钻取后，再返回给客户端，比如：

```json
{
  "data": {
    "UserEntity__findPage": {
      "total": 10,
      "items": [{
        "id": 123456789,
        "name": "abc",
        "roles": {
          "items": [{
            "id": 35426178,
            "name": "guest"
          }, { ... }, ...]
        }
      }, { ... }, ...]
    }
  }
}
```

可以看到，GraphQL Field Selection 与返回数据的结构是按层级而相互对应的，
GraphQL Field 的名字（`Name`）或别名（`Alias`）将作为返回数据的属性名，
且别名优先于名字。

实际上，NopGraphQL 引擎在解析 GraphQL Document 的过程中会为每个 GraphQL Field
绑定一个 `IDataFetcher`，用于获取对应的 GraphQL Field 的值，并且，如果当前字段的值是一个对象，
则需要继续向下钻取，在其子层级的 `IDataFetcher` 中将会以该字段值作为源数据，
直接从该对象中取对应属性的值，或者，将其作为关联查询的主要条件，进行过滤查询。

向下钻取将会按照 GraphQL Document 的结构一直进行下去，
直到遇到字段值为**标量类型**（即，整型、字符、布尔等非结构化数据）时才终止。

因此，在前例中，可以这样理解 GraphQL Document 的数据钻取过程：

- 调用 `UserEntity__findPage` 字段绑定的 `IDataFetcher`，并传入参数
  `query`（其值来自于变量 `$query`），以获取分页结果 `PageBean`；
- 得到 `PageBean` 后，继续钻取其属性 `total` 和 `items`，由于 `total` 为标量类型，
  故而，对其的钻取结束，而 `items` 是一个列表，故而，需继续向下钻取；
- 遍历 `items` 列表（假设其元素类型为 `UserEntity`），依次钻取其各个元素的 `id`、`name`
  和 `roleList` 属性。这里只有 `roleList` 是一个列表，因此，继续向下钻取 `roleList`；
- `roleList` 对应的是一个关联查询，并且，在 GraphQL Document 中设置了参数 `limit` 为 `10`，
  表示仅取前 `10` 条数据，因此，该字段绑定的 `IDataFetcher` 将以上一级的 `UserEntity`
  对象作为过滤条件，以查询与上一级对象关联的 `role` 数据；
- 由于在字段 `roleList` 上设置了别名 `roles`，因此，`roleList` 的钻取结果将被赋值到返回结果的
  `roles` 属性上；
- 钻取结束，返回 GraphQL 查询结果；

注意，`IDataFetcher` 是一个通用的 GraphQL Field 钻取接口，其实现类除了可以做列表查询，
还可以调用上一级对象的 getter 方法获取 GraphQL Field 指定的属性的值，
比如，钻取 `PageBean` 的 `total` 和 `items` 属性时，便是直接调用的方法
`getTotal()` 和 `getItems()`。

但是，GraphQL Field 与 `IDataFetcher` 不是随意绑定的，而是由
[GraphQL Schema](https://graphql.org/learn/schema/)（即对 GraphQL Document 的类型定义）确定的，
而在 NopGraphQL 中，GraphQL Schema 则是根据 [XMeta](../../manual/xmeta)
和 [BizModel](../../manual/xbiz) 动态生成的。

得益于 GraphQL Field 相互间互不干扰的取值（`fetcher`）机制，
使得 GraphQL 能够自由地**选择**和**组合**输出字段，为定制输出数据提供了极大的灵活性和自由度，
客户端完全可以按照自身需求指定包括子查询在内的复杂的数据钻取，
甚至可以在一个 GraphQL Operation 中同时指定多个相关取值：

```graphql
query ($id: String, $id2: String, $query: String) {
  entity1: MyEntity__get(id: $id) {
    name
    children2: children {
      desc2: desc
      extField
    }
  }

  entity2: MyEntity__get(id: $id2) {
    id
    children {
      name
      myName
    }
  }

  MyEntity__findPage(query: $query) {
    items {
      id
      name
      children {
        name
        value
      }
    }
  }
}
```

> NopGraphQL 通过配置项 `nop.graphql.query.max-operation-count`
> 控制 GraphQL Operation 中允许的 GraphQL Selection 的最大数量，缺省为 `10`。

而这种字段选择和组合能力并不会造成开发的额外负担，大部分 GraphQL Field 都可以通过推理自动绑定上相应的
`IDataFetcher`。即使需要应对复杂的数据钻取需求，在 NopGraphQL 中也可以通过
[XMeta](../../manual/xmeta) 和 [BizModel](../../manual/xbiz) 动态实现，
并且，其原生支持差量机制，从而让 GraphQL 具备了无限可能。

最后，列举一些 `OperationType` 为 `mutation` 的 GraphQL Document 样例，
以便于更全面了解 GraphQL 的编写形式：

```graphql title="新增数据"
mutation {
  NopAuthUser__save(data: $data) {
    id
    name
    status
  }
}
```

```graphql title="更新数据"
mutation {
  NopAuthUser__update(data: $data) {
    id
    name
    status
  }
}
```

```graphql title="删除数据"
mutation {
  NopAuthUser__batchDelete(ids: $ids)
}
```

## 引擎实现分析 {#engine-impl}

> 在阅读本章节前，请先对 GraphQL 做一些[简单了解](#about-graphql)。

虽然 NopGraphQL 引擎是针对 GraphQL 的后端服务实现方案，
但其满足可逆计算理论所要求的[形式等价变换](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/theory/graphql-vs-rest.md)，
可以将 REST、gRPC 等协议等价变换为 GraphQL 协议，
所以，其同样支持以 REST、gRPC 等形式的 Web 接口调用。

```plantuml
actor "客户端" as client
control "解析 GraphQL" as parser
file "~*.xmeta" as xmeta
file "~*.xbiz" as xbiz
component "GraphQLDocument" as doc

component "GraphQLEngine" as engine {
  control "执行字段 DataFetcher" as exec
  control "聚合字段数据" as merge

  doc -down-> exec: 提供字段 DataFetcher
  exec -left-> merge: 提供执行 DataFetcher 得到的字段数据
  merge -up-> client: 返回处理结果
}

xmeta -down-> parser: IObjMeta
xbiz -down-> parser: IBizModel
client -right-> parser: GraphQL\nREST\ngRPC\n...
parser -right-> doc: 提供 GraphQLFieldDefinition\n和 GraphQLOperation
```

如上图所示，客户端可以 GraphQL、REST、gRPC 等形式发起接口调用，
在 NopGraphQL 中会将不同形式的调用所携带的数据统一转换为 `GraphQLDocument`
对象，在引擎核心 `GraphQLEngine` 中仅专注于对 `GraphQLDocument` 的处理即可。

在解析 GraphQL 的过程中，NopGraphQL 会根据业务对象的元数据模型
`IObjMeta`（其结构由 `*.xmeta` 定义）向 `GraphQLDocument` 补充字段的 Schema 信息，
并绑定业务处理模型 `IBizModel`（其结构由 `*.xbiz` 定义）中相应的处理接口，
从而得到 GraphQL 的执行入口 `GraphQLOperation`。

## 引擎架构 {#arch}

NopGraphQL 引擎内部的处理情况如下图所示：

<!-- https://plantuml.com/deployment-diagram -->

```plantuml
actor " " as client_1
actor " " as client_2
actor " " as client_3
actor " " as client_n

rectangle "NopGraphQL" as graphql {
  port "GraphQL" as api_p1
  port "REST" as api_p2
  port "gRPC" as api_p3
  port "..." as api_pn

  control "GraphQL\n适配器" as api_graphql_adaptor
  control "RPC 适配器" as api_rpc_adaptor

  component "GraphQLEngine" as engine {
    port "~#executeGraphQLAsync()" as api_call_graphql
    port "~#executeRpcAsync()" as api_call_rpc
    port " " as api_return_graphql
    port " " as api_return_rpc

    component biz_obj_man [
      <b>BizObjectManager
    ]
    component "GraphQLExecutor" as executor {
      port "~#executeOneAsync()" as action_rpc
      port "~#executeAsync()" as action_graphql

      control "遍历 List<GraphQLFieldSelection>" as graphql_traveller
      control "执行 DataFetcher 1" as fetcher_invoker_1
      control "执行 DataFetcher 2" as fetcher_invoker_2
      control "执行 DataFetcher ..." as fetcher_invoker_n
      file "{\n  Xxx__findPage: {\n    total: 10,\n    items: [ ... ]\n  }\n}" as graphql_result

      component env [
        <b>DataFetchingEnvironment
      ]
      component graphql_doc [
        <b>GraphQLDocument
      ]

      graphql_doc -up-> graphql_traveller: GraphQLSelectionSet
      graphql_traveller -up-> env: GraphQLFieldSelection
      env -down-> graphql_traveller: GraphQLSelectionSet

      env -up-> fetcher_invoker_n: IDataFetcher ...
      env -up-> fetcher_invoker_2: IDataFetcher 2
      env -up-> fetcher_invoker_1: IDataFetcher 1

      fetcher_invoker_1 -up-> graphql_result: Xxx__findPage
      fetcher_invoker_2 -up-> graphql_result: total, items
      fetcher_invoker_n -up-> graphql_result: Object in <b>items

      graphql_result -up-> action_graphql
      graphql_result -up-> action_rpc

      action_graphql .> api_return_graphql: GraphQLResponseBean
      action_rpc .> api_return_rpc: ApiResponse
    }

    file "query Xxx__findPage(\n  $query: QueryBeanInput\n) {\n  Xxx__findPage(\n    query: $query\n  ) {\n    total\n    items { ... }\n  }\n}" as query
    file "~*.xmeta" as xmeta
    file "~*.xbiz" as xbiz

    api_call_graphql -> query
    api_call_rpc -> query

    api_return_graphql .> api_graphql_adaptor: GraphQLResponseBean
    api_return_rpc .> api_rpc_adaptor: ApiResponse

    query -down-> biz_obj_man
    xmeta -up-> biz_obj_man: IObjMeta
    xbiz -up-> biz_obj_man: IBizModel

    biz_obj_man .|> graphql_doc
  }

  api_p1 <-down-> api_graphql_adaptor
  api_p2 <-down-> api_rpc_adaptor
  api_p3 <-down-> api_rpc_adaptor
  api_pn <-down-> api_rpc_adaptor

  api_graphql_adaptor -down-> api_call_graphql: GraphQLRequestBean
  api_rpc_adaptor -down-> api_call_rpc: ApiRequest\n+ operationName\n+ operationType
}

client_1 <-down-> api_p1: /graphql
client_2 <-down-> api_p2: /r/\n/p/\n/f/
client_3 <-down-> api_p3
client_n <-down-> api_pn: ...
```

> - GraphQL/RPC 适配器包括 `io.nop.graphql.core.web.GraphQLWebService`
>   的实现类、`io.nop.rpc.grpc.server.GraphQLServerCallHandler` 等

- **IObjMeta**: 业务对象的元数据，用于描述业务对象的结构，并约束业务对象的属性数据；
- **IBizModel**: 业务处理模型，用于定义业务处理函数，实现对业务对象的相关处理；
- **GraphQLEngine**: [GraphQL 协议](#proto-graphql)的解析和执行引擎；

客户端发起请求并在 Body 中携带 `GraphQLRequestBean` 结构的 JSON 对象，
在 NopGraphQL 中，**解析器**将根据该 JSON 对象构造 GraphQL 文档（`GraphQLDocument`），
并根据 GraphQL 文档中业务对象对应的元数据 `IObjMeta` 补充和校验 GraphQL 的字段信息，
以确保 GraphQL 文档的完整性。

**GraphQLEngine** 依次执行 GraphQL 文档中各个字段上由 `IBizModel`
指定的**业务处理函数**，然后将所有函数的执行结果合并，再构造为 `GraphQLResponseBean`，
并在 JSON 序列化后返回给客户端。

注意，GraphQL 的字段是嵌套的，每个字段都有相应的 `IDataFetcher`，NopGraphQL
引擎的执行过程就是按照 GraphQL 文档做广度和深度遍历，依次执行字段的 fetch 动作，
并将结果按相同的层级组装后返回。并且，上一层级的执行结果将作为下一层级的源数据，
以实现对数据的深度剪枝。

通过 `IObjMeta` 可以动态生成 GraphQL Schema，故而，无需提前定义 GraphQL Schema。

**业务对象**（`BizObject`）为 NopGraphQL 引擎所驱动的核心模型。

<!--
Nop 平台的后端服务使用 NopGraphQL 引擎实现。NopGraphQL 引擎没有使用 graphql-java 包，
是完全从零开始实现的一个新的 GraphQL 引擎。相比于 graphql-java，它充分利用了可逆计算原理，
极大减少了需要手工编写的代码量，提高了运行时性能。此外，NopGraphQL 支持模型动态加载，
支持 REST 调用接口与 GraphQL 调用接口。

Nop 平台是可逆计算理论的实现，因此，其业务组件必然是围绕组件的 DSL 进行设计和开发的，而
NopGraphQL 引擎实际上便是 XMeta 的执行引擎，负责客户端和服务端的业务数据交互和存储相关的工作。

XMeta 对应的业务对象并没有生成相应的 Java Class，因为，其核心作用是描述业务结构和数据约束，
在 NopGraphQL 只需要对客户端提交的数据以 Map 形式表达，再按 XMeta 结构进行字段校验和数据转换，
最终转换结果也仅需遍历 Map 并复制到 ORM Entity 的对象实例上即可，没有必要再通过中间的 Class
对象做转换数据的承载工作。

以 [XMeta](../../manual/xmeta) 为蓝本，构造**聚合根**，客户端的操作均以聚合根为中心展开？

> 注意，无论是浏览器、移动应用，还是普通的接口调用，其请求发送方，均统称为**客户端**，而
> NopGraphQL 所在的位置则为**服务端**。

XMeta 为 Nop 平台提供了标准化的**对象元数据**模型，所有需要定义对象结构的地方都统一使用 XMeta 模型来定义。

> XMeta 和 XDef 可以相互转换。XDef 对应于 XML 结构，而 XMeta 对应于对象属性结构。

NopGraphQL 会根据 XMeta 配置生成对外暴露的 GraphQL 类型。

XMeta 定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改、是否可以用于查询等信息。
NopGraphQL 引擎返回的对象信息也完全由 XMeta 来定义。

- 实体元数据
  > Nop 平台的代码生成器会自动根据 ORM 模型为每个实体生成一个对应的 XMeta 文件，
  > 每个实体属性都会对应生成一个对象 prop 配置，在此基础上还会根据一对多、多对多等关联配置生成生成一些辅助属性。
- 对象元数据
  > xmeta 文件定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改，是否可以查询等信息。
  > NopGraphQL 引擎返回的对象信息完全由 XMeta 来定义。如果一个属性在 XMeta 中没有定义，则即使实体上具有这个字段，
  > 前台 GraphQL 和 REST 请求也无法访问到该字段。

Nop 平台内置了一个自动化的后台管理软件生产线，它的输入是用户需求（以 Excel 文档的形式表达），
输出是可运行的应用系统，主要通过系统化的增量式代码生成方案来实现生产线的运转。这其中，GraphQL
Schema 是根据 Meta 元数据定义和 BizModel 业务模型定义自动生成的一种中间产物，
我们并不会手工编写 GraphQL 类型定义，在编写业务代码的过程中也不需要具有任何 GraphQL 相关的知识，
不需要实现 GraphQL 特有的 DataFetcher、DataLoader 等接口。
-->

XMeta 只是定义了聚合根的结构，并未创建相应的 Java Class 实体，而其关联的
`<entityName />` 只是其结构中一部分需持久化的映射，并且，其实际可由多个
ORM 实体映射而成，只是会以某个 ORM 实体作为主体。当然，XMeta 也可以不映射任何
ORM 实体，仅仅是一个过程处理对象。

## BizObject {#biz-object}

```plantuml
interface "IBizObject" as biz_obj {
  bizModel: IBizModel
  objMeta: IObjMeta
}

interface "IBizModel" as biz_model {
  actions: List<IBizActionModel>
}

interface "IBizActionModel" as biz_action {
}

interface "IObjMeta" as obj_meta {
  props: List<IObjPropMeta>
}

interface "IObjPropMeta" as obj_prop_meta {
}

interface "IOrmEntity" as orm_entity {
}

biz_obj "1" *-- "1" biz_model: 包含 >
biz_obj "1" *-- "1" obj_meta: 包含 >

biz_model "1" *-- "*" biz_action: 包含 >
obj_meta "1" *-- "*" obj_prop_meta: 包含 >

obj_meta -right- orm_entity: 映射
```

<!-- https://plantuml.com/sequence-diagram -->

```plantuml

autonumber "<b>[000]"

actor "User" as user
entity "GraphQLEngine" as graphql
entity "ObjMeta" as meta
entity "BizModel" as biz
entity "OrmEntity" as orm

```

## BizLoader {#biz-loader}

## 数据权限控制 {#data-auth}

<!--
## 聚合根

聚合不是为了实现事务

- 主分解维度，门面模式
  面向对象而不是面向 DTO，不是面向 ID
- 全局关系 + 内部的局部关系。不同比例尺的地图
- 信息尽在指尖
- 实体 + 延迟加载 + session 缓存：结构聚合
- BizObject: 行为聚合
- GraphQL: 结构的选择和组合

聚合根首先是逻辑的聚合，BizModel 的切片构造就是一种聚合方式，
这种做法不是传统的面向对象中的继承方式和组合方式。
另外聚合的对偶概念是动态切片，GraphQL 恰好提供了一种在获取信息时的一种动态切片能力，
使得我们可以在概念层面上维持一个庞大的聚合根概念，但是在实际层面每次都只加载少量数据。
没有对偶的切片概念，本身聚合根就会非常臃肿，成为性能的拖累。

## 利用 XMeta 元数据模型统一动态处理模式

一般的函数复用只是复用一模一样的处理逻辑，最多是通过几个回调函数来提供有限的扩展点，
但很多时候并不存在完全一样的处理逻辑，**我们能够抽象只是一种处理模式**。
例如，save 函数的基本处理逻辑如下：

1. 验证前台提交的字段信息
2. 对于支持逻辑删除的实体，需要检查是否存在标记为删除的实体
3. 检查数据库中不存在重复的记录，比如不允许多个用户具有同样的身份证等
4. 根据请求数据创建实体对象，对于复杂的主子表结构需要进行特殊处理

每种不同实体的 save 逻辑的整体结构是完全一致的，但具体的细节不同。
比如每个字段的类型和校验规则都不同，部分字段还需要执行转换逻辑，
将前台传入的值转换为后台要求的格式等。不同实体上用于区分唯一性的字段也不同。
在 Nop 平台中每个业务对象都可以关联一个 XMeta 文件，通过它可以定义业务对象的元数据。

> XMeta 元数据比 Java 的注解要更加灵活和强大，它支持元编程和自定义扩展，
> 通过 XDef 元模型自动进行结构校验。

使用 XMeta 还有一个好处是支持 Delta 定制。
我们在不同的应用中对于同一个业务对象可以使用不同的 XMeta 模型，
从而定制实际处理的内容。如果使用强类型的 DTO 对象就很难在不修改基础产品源码的情况下实现逻辑定制。

GraphQL 的对象组合能力与 XMeta 的对象结构抽象能力，
以及可逆计算的差量化能力结合在一起，可以将大部分 CRUD 相关的逻辑固化下来。
一般不需要编写 CRUD 相关的代码，也不需要针对不同的场景生成大量代码，
通过统一的实现即可完成主体需求，我们最多只需要向 CRUD 模型补充偏离标准 CRUD 处理过程的差量信息即可。

CrudBizModel 采用的是元数据驱动的实现方式，它会读取 xmeta 配置文件中的内容，
内置实现了数据验证、自动初始化、级联删除、逻辑删除、数据权限等多种常见需求，
所以一般情况下只需要调整 xmeta 和 xbiz 配置文件，并不需要编写定制逻辑。

1. 数据验证：类似于 GraphQL 的输出选择，NopGraphQL 可以对输入字段进行选择性验证和转换，这体现了**输入和输出的对偶性**。

   ```js
   validatedData = new ObjMetaBasedValidator(
     bizObjManager,
     bizObjName,
     objMeta,
     context,
     checkWriteAuth
   ).validateForSave(input, inputSelection);
   ```

2. 自动初始化：在 meta 中可以配置字段的 autoExpr 表达式，
   更新或者修改的时候可以根据该配置自动初始化字段值。autoExpr
   表达式可以根据数据模型中的 domain 配置自动生成。

3. 自动转换：根据 meta 中配置 transformIn 表达式，对输入的属性值进行适配转换。
   transformIn 表达式可以根据数据模型中的 domain 配置自动生成。

4. 级联删除：标记为 cascade-delete 的子表数据会随着主表数据的删除一并删除，
   而且会执行子表对应的 BizObject 业务对象上的定义的删除逻辑。

5. 逻辑删除：如果启用 delFlag 逻辑删除标记字段，则底层的 ORM
   引擎会自动将删除调用转换为修改 delFlag 的操作，并且对所有查询都自动应用
   delFlag=0 的过滤条件，除非明确在 SQL 对象上设置 disableLogicalDelete 属性。

6. 数据权限：所有读取到的实体记录都会自动验证是否满足数据权限要求。

## GraphQL 对象：BizModel {#biz-model}

NopGraphQL 引擎在初始化的时候会利用 IoC 容器的动态扫描能力发现所有标记了`@BizModel`注解的
bean，并把它们按照 BizObjName 配置进行归类合并。

NopAuthUserBizModel 和 NopAuthUserBizModelEx 的 BizObjectName 都是
NopAuthUser，它们的方法会叠加在一起共同生成 NopAuthUser 业务对象上的方法。当出现同名的函数时，会按照`@Priority`
优先级配置选择优先级更高的实现。如果优先级相同且函数名相同，则会抛出异常。

NopGraphQL 引擎在构造 BizObject 的时候还会检查 xbiz 扩展模型，我们可以通过在 NopAuthUser.xbiz
模型文件中增加方法来扩展 BizObject，这个模型文件可以在线更新，更新后会即时起效，无需重新初始化 GraphQL
类型定义。xbiz 文件中定义的方法优先级最高，它会自动覆盖 JavaBean 中定义的业务方法。

如果把对象名相同的 BizModel 看作是对象的一个切片，则 NopGraphQL
引擎相当于是在系统初始化的时候动态收集这些对象切片，然后像 docker
镜像一样把它们叠加在一起，构成完整的对象定义。在运行时，最上层的
xbiz 切片可以被动态修改，并覆盖下层切片的功能。

> BizModel 切片的概念有些类似于游戏开发领域中的 Entity Component System (ECS)模式，只是它累加的是动态行为而不是局部状态。

与 Gather 对偶的能力是 Scatter：我们经常需要做一些全局规则的抽象，
需要将某些公共知识自动推送到不同的业务对象中。NopGraphQL 主要通过
AOP 机制和元编程机制来实现信息的分发：

1. 公共的机制可以作为 AOP 拦截器作用于符合条件的业务方法上

2. xbiz 文件中可以通过 XLang 中通用的 x:gen-extends 元编程机制动态生成方法定义。
   也可以使用外部的 CodeGenerator 来生成代码。

在 xbiz 文件中可以直接编写 query,muation, loader 等函数定义，它们会覆盖 Java 的 BizModel 中的相应函数实现。
也就是说，对外暴露的 BizObject 是由所有的 BizModel 类以及 XBiz 模型文件中定义的所有函数所组成的，在 BizObjectManager 启动的时候会扫描
系统中所有的 BizModel 类，以及 XBiz 模型文件，生成对应的 BizObject 对象。

**XBiz 中定义的函数优先级最高，如果与已有的函数同名，则会自动覆盖**

- nop-graphql-core 提供了 GraphQL 的执行引擎，协调多个 DataFetcher 并行获取数据，并且提供了 RPC 调用接口封装

- nop-graphql-orm 提供了使用 NopORM 引擎实现的各种 DataFetcher

- nop-dao 提供了 JDBC 封装、事务封装以及数据库 Dialect 机制

- nop-orm-model 提供了实体模型定义，而 nop-orm-eql 提供了 EQL 语法的解析器。这两个模块可以独立于 nop-orm 引擎被使用

- nop-orm 实现了一个包含 Hibernate 和 MyBatis 所有核心功能的 ORM 引擎

- nop-biz 中的 BizObjectManager 提供了 IGraphQLSchemaLoader 接口的实现，将 GraphQL 调用映射到 BizModel 的方法上。
  这个过程类似于 REST 框架将 URL 链接映射到 Controler 类的方法上。nop-biz 模块内置了 CRUD 服务和字典表服务。

- nop-biz 通过 nop-fsm 内置了有限自动机机制，可以描述某些简单的业务流程

- nop-biz 并不强依赖于 NopIoC 容器，但是依赖 nop-ioc 模块可以利用模块内置的 beans.xml 配置。

**服务函数可以看作是某种执行 DSL 的虚拟机，传入的参数不同会指导虚拟机执行不同的处理逻辑**。
举个具体的例子，CrudBizModel 中提供的 findPage/findList 等通用查询函数，
它们所接收的查询条件对象 QueryBean 就可以看作是一种 DSL，它描述了针对一个复杂对象结构的组合查询条件。

### 通过元编程增强 XBiz 模型

一旦引入 XBiz 这样的 DSL 模型文件，就可以立刻施展标准化的元编程套路，
为 DSL 模型引入更多的自定义扩展。例如，在 XBiz 文件中，我们可以通过如下方式引入逻辑编排支持。

```xml
<biz>
  <x:post-extends>
    <biz-gen:TaskFlowSupport xpl:lib="/nop/core/xlib/biz-gen.xlib"/>
  </x:post-extends>

  <actions>
    <mutation name="callTask" task:name="test/DemoTask"/>
  </actions>
</biz>
```

- `x:post-extends`在模型解析的编译期自动执行，通过`<biz-gen:TaskFlowSupport>`
  标签会自动对具有`task:name`的函数节点进行变换，自动生成调用 TaskFlowManager 的代码。

- 我们可以使用可视化的逻辑编排设计器来设计`Task`，然后在 XBiz 模型中只要为服务函数指定它所关联的`task:name`即可。

### BizLoader {#biz-model-biz-loader}

1. `@BizQuery`表示本方法将被映射为 GraphQL 中的 query 调用，`@BizMutation`
   将被映射为 GraphQL 中的 mutation 调用。

2. `@BizLoader`为 GraphQL 类型的属性提供 fetcher 和 loader 定义。
   注意，为了保证概念的简单性，NopGraphQL 要求所有属性都必须在 xmeta 文件中声明，
   BizModel 中仅是为已定义的属性提供定制的加载器。

3. 如果返回值类型为 CompletionStage，则表示该方法异步执行

4. 如果标注了`@BizLoader`注解的方法的 ContextSource 参数为 List
   类型，则表示它对应 GraphQL 的 DataLoader 实现，支持批量加载。

### 没有实体定义的情况下也可以写 BizModel 吗？

可以，Nop 平台的整体设计是分层的，后一层不依赖于前一层。
自己写一个 BizModel 类即可，参见 LoginApiBizModel。

通过 Nop 平台的代码生成器，我们可以根据 Excel 中的数据模型定义一路推导得到前端页面，
但是每个推导步骤都是可选步骤，并不一定需要前一个步骤的存在。

参考 LoginApiBizModel 的实现，我们可以在 Java 中直接编写一个 BizModel 类，
然后在某个 beans.xml 中注册，即可通过 NopGraphQL 引擎来调用。

> LoginApiBizModel 实现 ILoginSpi 接口仅仅是为了提高代码可读性和可维护性，
> 并不是必须的。一个 BizModel 类可以不继承任何基类，也不需要实现任何接口，
> 本质上 BizModel 与 Spring 框架中的 Controller 类似，只是它不依赖于任何 Web 运行时环境，
> 返回结果也不要求是 POJO 等可以直接进行 JSON 序列化的对象。
> （BizModel 中函数的返回值会经过 NopGraphQL 引擎处理后得到返回值）

使用 NopGraphQL，一般没有必要再区分 Controller 和 Service，
直接在 Service 上增加@BizModel 注解（并注册在 beans.xml）中即可直接将服务发布为 Web 服务。
通过 meta 层可以进行返回结果增强和后处理等，即 NopGraphQL 本身提供了一个弹性适配层，
很多情况下都没有必要再增加一个对象来实现适配。

## 数据权限控制 {#data-auth}

## 在 Biz 模型中调用 validator 模型 {#biz-validator}

Nop 平台中的后台服务函数不一定在 Java 类中实现。在进行无代码开发的时候，
后台服务函数可以写在 xbiz 模型文件中，biz 模型支持在线编辑、动态加载，
在不停机的情况下可以增加后台 GraphQL 服务函数，并立刻起效。

testValidator3 函数通过`biz:RunValidator`标签函数来装载外部的 validator 模型文件，
并执行验证逻辑。这样做的好处是未来可以通过 Delta 定制机制来修改验证逻辑，而不用修改 Demo.xbiz 文件。

```xml
<biz:RunValidator xpl:lib="/nop/core/xlib/biz.xlib"
                  validatorPath="/nop/demo/validator/process-card.validator.xml"
                  obj="${{entity,firstProductionOrder:entity.productionOrder,firstMaterial}}"/>

```

> Biz 模型是 XML 格式，因此可以通过一个可视化设计器来在线设计 Biz 模型。
> 对于具体的 Action，也可以通过可视化拖拽的方式来实现。
> 例如，将`<biz:RunValidator>`标签看作是一个组件，validatorPath 等是组件的属性，
> 可以从面板中拖拽对应的组件到 Action 容器中，从而实现可视化的逻辑编排

### 通过元编程将 Validator DSL 嵌入到 Biz 模型中

Demo.xbiz 文件中的 testValidator2 函数演示了另外一种执行 Validator 验证逻辑的方式。
它通过宏标签将 Validator 模型嵌入到 Biz 模型中，
在编译宏标签的时候将会把对应节点的内容传入 ValidatorParser 中进行解析得到 ValidatorModel，
在运行期直接使用作为全局变量存在的 ValidatorModel 即可。

```xml
<biz:Validator xpl:lib="/nop/core/xlib/biz.xlib" fatalSeverity="100"
               obj="${{entity,firstProductionOrder:entity.productionOrder,firstMaterial}}">

    <check id="checkTransferCode" errorCode="test.not-transfer-code"
           errorDescription="扫入的码不是流转码">
        <eq name="entity.flowMode" value="1"/>
    </check>
</biz:Validator>
```
-->

## 时序图

以 Quarkus 集成并发送如下请求为例：

```json title="/graphql"
{
  "query": "query PageProvider__getPage($path:String){\nPageProvider__getPage(path:$path)\n}",
  "variables": {
    "path": "/xxx/pages/Xxx/main.page.yaml"
  }
}
```

请响应逻辑如下：

<!-- https://plantuml.com/sequence-diagram -->

```plantuml
autonumber "<b>[000]"

entity "浏览器" as browser
entity "QuarkusGraphQLWebService" as service
entity "GraphQLEngine" as engine
entity "GraphQLExecutor" as executor

browser -> service: /graphql:\n在请求 body 中携带\nJSON 格式的 GraphQL 数据
activate service
  service -> service: ~#about-graphql(body)
  activate service
    service -> service: ~#runGraphQL(body)
    activate service
      service -> service: BeanContainer#getBeanByType(\n  IGraphQLEngine.class\n):\n -> GraphQLEngine
      service -> service: 将 body 反序列化为\nGraphQLRequestBean: request

      service -> engine: ~#newGraphQLContext(request)
      activate engine
        engine -> engine: ~#parseOperation(\n  request.getQuery(): query\n)
        activate engine
          engine -> engine: ~#parseOperationFromText(query):\n-> GraphQLDocument

          engine -> engine: 返回 GraphQLDocument
        deactivate engine

        engine -> service: 返回携带 GraphQLDocument 的\nGraphQLExecutionContext: context
      deactivate engine

      service -> engine: ~#executeGraphQLAsync(context)
      activate engine
        engine -> executor: ~#executeAsync(context)
        activate executor
          executor -> executor: ~#invokeOperations
          activate executor
            executor -> executor: ~#_invokeOperations
            activate executor
              executor -> executor: ~#invokeOperationOrTry
              activate executor
                executor -> executor: GraphQLFieldDefinition\n~#getFetcher():\n-> ServiceActionFetcher

                executor -> executor: 返回异步 OperationResult:\n其由异步调用\nServiceActionFetcher#get\n得到
              deactivate executor

              executor -> executor: 返回异步 OperationResult
            deactivate executor

            executor -> executor: 返回异步 OperationResult
          deactivate executor

          executor -> executor: 异步转换 OperationResult\n为 GraphQLResponseBean
          executor -> engine: 返回异步\nGraphQLResponseBean
        deactivate executor

        engine -> service: 返回异步 GraphQLResponseBean
      deactivate engine

      service -> service: 异步转换 GraphQLResponseBean\n为 Response
      service -> service: 返回异步 Response
    deactivate service

    service -> service: 返回异步 Response
  deactivate service

  service -> browser: 返回 JSON 数据
deactivate service
```

`ServiceActionFetcher` 与对应的 `@BizModel` 进行绑定（在调用
`GraphQLEngine#parseOperationFromText` 时做的绑定），
在调用其 `#get` 函数时，将实际调用绑定的 `@BizModel`
对应的 `@BizQuery` 函数。

`GraphQLEngine#parseOperationFromText` 的执行逻辑如下：

```plantuml
autonumber "<b>[000]"

entity "GraphQLEngine" as engine
entity "GraphQLSelectionResolver" as resolver
entity "BizObjectManager" as biz_man
entity "BizObjectBuilder" as biz_builder

engine -> engine: ~#parseOperationFromText(query)
activate engine
  engine -> engine: GraphQLDocumentParser\n~#parseFromText(query):\n-> GraphQLDocument: doc

  engine -> engine: ~#initDocument(doc)
  activate engine
    engine -> engine: ~#resolveSelections(doc)

    engine -> resolver: ~#resolveSelection(doc)
    activate resolver
      resolver -> resolver: ~#resolveOperation(\n  doc, GraphQLOperation: op\n)

      resolver -> engine: ~#getOperationDefinition:\n获取 GraphQLFieldSelection\n的 GraphQLFieldDefinition
      activate engine
        engine -> biz_man: ~#getOperationDefinition
        activate biz_man
          biz_man -> biz_man: ~#getBizObject(bizObjName)
          activate biz_man
            biz_man -> biz_man: ~#buildBizObject(bizObjName)

            biz_man -> biz_builder: ~#buildBizObject(bizObjName)
            activate biz_builder
              biz_builder -> biz_builder: ~#loadBizObjFromModel(bizObjName):\n-> BizObjectImpl: bizObj

              biz_builder -> biz_builder: ~#buildOperations(bizObj)
              activate biz_builder
                biz_builder -> biz_builder: ~#buildActionOperation(bizObj)
                activate biz_builder
                  biz_builder -> biz_builder: BizModelToGraphQLDefinition\n~#toOperationDefinition:\n构造 GraphQLFieldDefinition，\n并与 ServiceActionFetcher 绑定

                  biz_builder -> biz_builder: 返回 GraphQLFieldDefinition
                deactivate biz_builder

                biz_builder -> biz_builder: BizObjectImpl 与\nGraphQLFieldDefinition 绑定
                biz_builder -> biz_builder:
              deactivate biz_builder

              biz_builder -> biz_man: 返回 BizObjectImpl
            deactivate biz_builder

            biz_man -> biz_man: 返回 BizObjectImpl
          deactivate biz_man

          biz_man -> biz_man: BizObjectImpl\n~#getOperationDefinition
          biz_man -> engine:
        deactivate biz_man

        engine -> resolver:
      deactivate engine

      resolver -> resolver: ~#resolveFieldSelection:\n绑定 GraphQLFieldSelection\n与 GraphQLFieldDefinition
      resolver -> engine:
    deactivate resolver

    engine -> engine:
  deactivate engine

  engine -> engine: 返回 GraphQLDocument
deactivate engine
```

在 `BizObjectBuilder#buildBizObject` 中会构造 `@BizModel`
的 GraphQL 对象结构，并与其 xmeta 定义进行合并。

## 注意事项

## 参考资料

- [面向对象的 GraphQL](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/graphql-java.md)
- [低代码平台中的分布式 RPC 框架](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/microservice/rpc-design.md)
- [Nop 入门：极简服务层开发](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/simple/1-simple-service.md)
- [从可逆计算看后端服务函数的可扩展设计](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/biz-customization.md)
- [Biz 模型](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/xbiz.md)
- [GraphQL 为什么流行不起来？是设计不足还是设计过度？](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/qa-about-graphql.md)
- [验证模型](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/validator.md)
- [CrudBizModel 中的自动验证](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/validate.md)
