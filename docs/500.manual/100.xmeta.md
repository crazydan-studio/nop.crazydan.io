---
title: XMeta 模型
description: 关于 XMeta 模型的配置说明
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import Header from '@site/docs/\_header.md';
import {NopDocLink, NopVfsLink} from '@site/docs/NopLink';

<Header />

XMeta 为 Nop 平台内置的一种领域模型，主要用于描述业务对象的结构。其为
NopGraphQL 引擎的[核心模型](../implement/component/graphql#engine-core-models)
`IBizObject` 的重要组成部分。

> XMeta 解析后的模型类型即为 [`IObjMeta`](../implement/component/graphql#obj-meta)。

XMeta 模型的结构定义在 <NopVfsLink module="nop-xdefs" path="/nop/schema/xmeta.xdef" />
中，通过分析该 xdef 文件，便可以了解和掌握 XMeta 完整的配置和结构信息。

<!-- https://plantuml.com/object-diagram -->

```plantuml
object "/nop/schema/xmeta.xdef" as xmeta {
}
object "/nop/schema/schema/obj-schema.xdef" as obj_schema {
  schema=schema.xdef
}
object "[[./dsl/schema /nop/schema/schema/schema.xdef]]" as schema {
}
object "/nop/schema/schema/schema-node.xdef" as schema_node {
}

xmeta -down-> obj_schema: xdef:ref 引用

obj_schema -down-> schema_node: xdef:ref 引用
obj_schema::schema --> schema: <schema xdef:ref="schema.xdef"/>

schema -down-> schema_node: xdef:ref 引用
```

> - `xdef:name` 用于命名 XDef 节点，在 xdef 文件内的其他节点可以通过
>   `xdef:ref` 引用该命名节点的定义。其名字也对应于为该节点所生成的 Java 类名；
> - `xdef:ref` 用于引用内部或外部 xdef 定义，前者引用的是 `xdef:name` 所指定的名字，
>   后者引用的则是 xdef 文件的虚拟文件系统（VFS）路径；
> - `xdef:ref` 引用相当于继承，并且也可以在当前节点上添加其他属性或子节点；
> - XDef 之间通过 `xdef:ref` 实现扩展，而 XDSL 之间则通过 `x:extends` 实现扩展；

以下定义的是一个简单的 xmeta 文件，用于描述业务对象
`io.nop.demo.entity.AccountEntity` 的结构：

```xml title="_vfs/nop/demo/model/AccountEntity/AccountEntity.xmeta"
<meta xmlns:x="/nop/schema/xdsl.xdef"
     x:schema="/nop/schema/xmeta.xdef"
     displayName="帐号"
>
  <x:gen-extends>
    <meta-gen:DefaultMetaGenExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:gen-extends>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:post-extends>

  <displayProp>name</displayProp>

  <entityName>io.nop.demo.entity.AccountEntity</entityName>
  <primaryKey>oid</primaryKey>
  <keys>
    <key name="UK_name" props="name"/>
  </keys>
  <orderBy>
    <field name="updatedTime" desc="true"/>
  </orderBy>

  <props>
    <prop name="oid" propId="1" mandatory="true"
          queryable="true" sortable="true"
          insertable="true" updatable="false"
    >
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="name" propId="2" mandatory="true"
          queryable="true" sortable="true"
          insertable="true" updatable="false"
    >
      <schema type="java.lang.String" precision="50"/>
    </prop>

    <prop name="updatedTime" propId="3" mandatory="true"
          queryable="true" sortable="true"
          insertable="false" updatable="false">
        <schema type="java.sql.Timestamp"/>
    </prop>
  </props>
</meta>
```

## XMeta 结构 {#attrs}

<Table head={['属性', '值类型', '属性名称']}>

<!-- -->

<TRow><TCol id="attr_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 业务对象的名称 </TCol>
<TDesc>

用于设置业务对象的显示名称，比如，为业务对象 `UserGroupEntity`
设置显示名称为**`用户分组`**，即 `displayName="用户分组"`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_displayProp"> &lt;displayProp /> </TCol>
<TCol> string </TCol><TCol> 显示数据名称的属性 </TCol>
<TDesc>

用于显示业务对象数据名称的[属性名](#attr_props_prop_name)，比如，在业务对象
`RoleEntity` 中的 `name` 属性的值便为角色数据的显示名称，则设置
`<displayProp>name</displayProp>`。
在下拉列表、树形控件等需要显示数据名称的组件中需要引用 `<displayProp />` 的设定值

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 描述说明 </TCol>
<TDesc>

用于阐述业务对象的作用、使用注意事项等

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_entityName"> &lt;entityName /> </TCol><TCol>

[class-name](./dict/std-domain#opt_class_name)

</TCol><TCol> ORM 实体的名字 </TCol>
<TDesc>

用于设置与业务对象映射的 ORM 实体的[名字](./xorm#attr_entities_entity_name)（一般与实体的类名相同），
比如 `<entityName>io.nop.demo.entity.RoleEntity</entityName>`。
只有在创建了对应的 ORM [实体](./xorm#def_attr_entities_entity)时才需要设置该值。

在集成了 [NopORM](../implement/component/orm) 后，[NopGraphQL](../implement/component/graphql)
将为业务对象构造相应的 [GraphQL 字段取值](../implement/component/graphql#engine-select-graphql-field)函数
`OrmEntityColumnFetcher`、`OrmEntityPropertyFetcher` 等，用于从数据库中获取该
ORM 实体的指定列（**Column**）的值。详细逻辑见 `io.nop.graphql.orm.OrmBizInitializer#initialize`。

**注意**：`OrmEntityColumnFetcher` 等字段取值函数也将采用
[GraphQL DataLoader 机制](../implement/component/graphql#biz-loader)做
ORM 列的批量加载，因此，不会存在性能问题。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_primaryKey"> &lt;primaryKey /> </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> ORM 实体的主键列表 </TCol>
<TDesc>

用于设置与 ORM
实体的[主键](./xorm#attr_entities_entity_columns_column_primary)相映射的[属性名](#attr_props_prop_name)，
对于复合主键，则需要以逗号分隔多个属性名，例如：

```xml
  <!-- 唯一主键 -->
  <primaryKey>oid</primaryKey>

  <!-- 复合主键 -->
  <primaryKey>userId,groupId</primaryKey>
```

**注意**：`id` 为 NopORM 的保留名字，一般要求不使用 `id` 作为主键属性的名字。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key"> &lt;keys>&lt;key />&lt;/keys> </TCol>
<TCol> ObjKeyModel </TCol><TCol> ORM 实体的唯一键 </TCol>
<TDesc>

用于设置具有**唯一性约束**并与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的[属性名](#attr_props_prop_name)。

在新增或修改 ORM 实体对象时，在 `CrudBizModel`
中将自动检查受唯一性约束的属性在数据库中是否存在重复值。其检查逻辑见
`CrudBizModel#checkUniqueForSave`、`CrudBizModel#checkUniqueForUpdate`。

对 `<keys />` 列表的详细说明见[《ORM 实体唯一键》](#def_attr_keys_key)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_filter"> &lt;filter /> </TCol><TCol>

[filter-bean](./dict/std-domain#opt_filter_bean)

</TCol><TCol> ORM 实体的默认过滤条件 </TCol>
<TDesc>

用于设置在查询该 ORM 实体时需始终附加的过滤条件。其追加逻辑见
`CrudBizModel#prepareFindPageQuery`。

此外，在获取、删除、更新、复制某个确定的 ORM 实体对象时，在 `CrudBizModel`
中也会检查该实体对象是否满足该过滤条件。其检查逻辑见 `CrudBizModel#checkMetaFilter`。

因此，其可用于限定用户只能查看和操作特定范围内的数据，例如：

```xml
  <filter>
    <eq name="status" value="1" />
  </filter>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field"> &lt;orderBy>&lt;field />&lt;/orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> ORM 实体的默认排序条件 </TCol>
<TDesc>

用于设置在查询该 ORM 实体时需始终附加的排序条件。其追加逻辑见 `CrudBizModel#prepareFindPageQuery`。

对 `<orderBy />` 列表的详细说明见[《ORM 实体排序条件》](#def_attr_orderBy_field)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree"> &lt;tree /> </TCol>
<TCol> ObjTreeModel </TCol><TCol> ORM 实体的树形结构配置 </TCol>
<TDesc>

用于配置 ORM 实体的树形结构信息。在 `CrudBizModel` 中将根据此结构查询和维护树形结构的
ORM 实体数据，及其父子关联关系（[参考用例](/practice/demo/v2#create-tree)）。

对 `<tree />` 的详细说明见[《ORM 实体树形结构配置》](#def_attr_tree)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection"> &lt;selections>&lt;selection />&lt;/selections> </TCol>
<TCol> ObjSelectionMeta </TCol><TCol> GraphQL 选择字段集 </TCol>
<TDesc>

对 GraphQL 的选择字段集命名，用于指定对业务对象的哪些属性做[字段取值](../implement/component/graphql#about-graphql)。

通过选择字段集的名字，可以以简单的方式引用常用的选择字段列表，不需要反复编写该列表。

对 `<selections />` 的详细说明见[《GraphQL 选择字段集》](#def_attr_selections_selection)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop"> &lt;props>&lt;prop />&lt;/props> </TCol>
<TCol> ObjPropMetaImpl </TCol><TCol> 业务对象的属性定义 </TCol>
<TDesc>

详细说明见[《属性列表》](#def_attr_props_prop)

</TDesc></TRow>

</Table>

### ORM 实体唯一键 {#def_attr_keys_key}

在新增或修改 ORM 实体对象时，`CrudBizModel`
将自动检查 XMeta 中受唯一性约束的属性（组合属性一起检查）在数据库中是否存在重复值。
若存在重复，则直接抛出异常，从而避免向数据库写入不唯一的数据，保证其唯一性。

> 其检查逻辑详见 `CrudBizModel#checkUniqueForSave`、`CrudBizModel#checkUniqueForUpdate`。

例如，配置 `name` 值唯一，`code1` 与 `code2` 的组合结果唯一：

```xml {5-6}
<meta>
  <!-- ... -->

  <keys>
    <key name="UK_name" props="name"/>
    <key name="UK_code" props="code1,code2"/>
  </keys>

  <!-- ... -->
</meta>
```

注意，`<keys />` 本身没有配置属性，以下仅对其子节点 `<key />` 的结构进行说明：

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_keys_key_name"> name </TCol>
<TCol> string </TCol><TCol> 唯一键名 </TCol>
<TCol> 是 </TCol><TDesc>

用于配置唯一键的名字，其对应数据库层面 `UNIQUE KEY` 的名字，仅包含字母、数字和下划线。

在不同的 `<key />` 标签之间的 `name` 需互不相同。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_props"> props </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> 唯一键属性名列表 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置具有**唯一性约束**并与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的[属性名](#attr_props_prop_name)。
多个属性之间采用逗号分隔

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 唯一键的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置唯一键的显示名称。一般显示 `name` 会更容易区分

</TDesc></TRow>

</Table>

### ORM 实体排序条件 {#def_attr_orderBy_field}

在查询 ORM 实体时，`CrudBizModel` 将会始终向查询语句中附加在
XMeta 中配置的排序条件，从而保证查询结果始终是有序的。

> 其追加逻辑详见 `CrudBizModel#prepareFindPageQuery`。

例如，配置按 `status` 降序排序，并按 `name` 升序排序：

```xml {5-6}
<meta>
  <!-- ... -->

  <orderBy>
    <field name="status" desc="true"/>
    <field name="name" desc="false"/>
  </orderBy>

  <!-- ... -->
</meta>
```

注意，`<orderBy />` 本身没有配置属性，以下仅对其子节点 `<field />` 的结构进行说明：

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_orderBy_field_name"> name </TCol>
<TCol> string </TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的、
参与排序的[属性名](#attr_props_prop_name)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_desc"> desc </TCol>
<TCol> boolean </TCol><TCol> 是否降序排序 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置排序属性值的排序方向。为 `true` 时，表示采用降序排序。
缺省为 `false`，即采用升序排序

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_nullsFirst"> nullsFirst </TCol>
<TCol> boolean </TCol><TCol> NULL 值优先？ </TCol>
<TCol> 否 </TCol><TDesc>

用于设置如何比较排序属性的 `NULL` 值：

- 为 `true` 时，表示 `NULL` 值小于所有非 `NULL` 值；
- 为 `false` 时，表示 `NULL` 值大于所有非 `NULL` 值；

</TDesc></TRow>

</Table>

### ORM 实体树形结构配置 {#def_attr_tree}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_tree_parentProp"> parentProp </TCol>
<TCol> string </TCol><TCol> 指向父实体的属性名 </TCol>
<TCol> 是 </TCol><TDesc>

这里填写的不是与父实体同类型的属性名（如 `parent`），
而是与 ORM 表字段直接映射的属性名（如 `parentId`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_childrenProp"> childrenProp </TCol>
<TCol> string </TCol><TCol> 指向子实体的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

在父实体中对应的子实体的集合类型的属性名，如 `children`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_levelProp"> levelProp </TCol>
<TCol> string </TCol><TCol> 表示节点级别的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

其值对应的属性须为整数类型。若其值为 `level`，
则 `level = 1` 表示一级节点，`level = 2` 表示二级节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootLevelValue"> rootLevelValue </TCol>
<TCol> string </TCol><TCol> 根节点所对应的节点级别属性的值 </TCol>
<TCol> 否 </TCol><TDesc>

若 `levelProp` 所对应的属性的值为该属性的值时，表示得到的实体数据为根节点。
例如，其值为 `0` 则表示 `level = 0` 的结果为根节点，
若未指定该值，则以 `rootParentValue` 对应的结果为根节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootParentValue"> rootParentValue </TCol>
<TCol> string </TCol><TCol> 根节点的初始值 </TCol>
<TCol> 否 </TCol><TDesc>

若 `parentProp` 所对应的属性的值为该初始值时，表示得到的实体数据为根节点。
例如，其值为 `0` 则表示 `parentId = 0` 的结果为根节点，
若未指定该值，则表示 `parentId is null` 的结果为根节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_sortProp"> sortProp </TCol>
<TCol> string </TCol><TCol> 排序属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于对树形数据排序的[对象属性](#def_attr_props_prop)，默认为
`XMeta#primaryKey` 指定的单一[对象属性](#def_attr_props_prop)（复合主键将抛异常）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_isLeafProp"> isLeafProp </TCol>
<TCol> string </TCol><TCol> 表示叶子节点的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于指示实体数据是否为叶子节点的[对象属性](#def_attr_props_prop)，
该属性须为 `Boolean` 类型。**暂时不确定其用途！**

</TDesc></TRow>

</Table>

根据 `<tree />` 的配置拼接 SQL 的逻辑见 `io.nop.biz.crud.TreeEntityHelper#buildTreeEntityBaseSql`，
也可以参考文档<NopDocLink title="《树形结构相关》" path="/dev-guide/orm/tree-structure.md" />。

根节点默认以条件 `o.{parentProp} is null` 来过滤。如果指定了 `rootParentValue`
或 `rootLevelValue`，则以条件 `o.{parentProp} = ${rootParentValue}`
或 `o.{levelProp} = ${rootLevelValue}`，且以 `rootLevelValue` 来过滤根节点的优先级高于
`rootParentValue`。

### GraphQL 选择字段集 {#def_attr_selections_selection}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_selections_selection_id"> id </TCol>
<TCol> string </TCol><TCol> 选择集合唯一标识 </TCol>
<TCol> 是 </TCol><TDesc>

用于区分其他字段选择集合

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 显示名 </TCol>
<TCol> 否 </TCol><TDesc>

方便人阅读

</TDesc></TRow>

</Table>

`<selection />` 标签的 body 为
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
语法，用于指定可返回的字段：

```xml
<meta>
  <selections>
    <selection id="F_defaults">
      userId, userName, status
    </selection>

    <selection id="F_moreFields">
      userId, userName, status, relatedRoleList{ roleId, roleName, permissionList{ id, name } }
    </selection>

    <selection id="copyForNew">
      status, description
    </selection>
  </selections>
</meta>
```

关于 `<selection />` 有如下内置约定：

- `id` 为 `copyForNew`：特定用于接口 `@mutation:{BizObjName}__copyForNew/id`
  做 ORM 实体的复制新增，指定默认的可被复制的属性。其实现逻辑见
  `io.nop.biz.crud.CrudBizModel#copyForNew`
  - 为了安全性，可复制内容不允许前端指定
- `id` 以 `F_` 为前缀：表示查询接口可以使用的 GraphQL Fragment 定义。其中，`F_defaults`
  表示默认可返回的字段集合，若未配置该 selection，则返回所有的缺省字段（非 lazy 加载的字段）
- `id` 为其余名称：其用途可根据业务需求自行决定。比如，通过
  `getObjMeta().getFieldSelection("my_selection")` 获得配置的字段，再调用
  `io.nop.biz.crud.CrudBizModel#doSave` 保存指定字段的数据

关于 `<selection />` 的使用：

- 指定返回默认字段：

```graphql
// 等价于 REST 调用: /r/Book__get?id=123
query {
  Book__get(id:123) {
    ...F_defaults
  }
}

// 等价于 REST 调用: /r/Book__get?id=123&@selection=...F_defaults,author
query {
  Book__get(id:123) {
    ...F_defaults,
    author {
      ...F_defaults
    }
  }
}

// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_defaults,groupMappings
query {
  NopAuthUser__findList {
    ...F_defaults, groupMappings{ ...F_defaults }
  }
}
```

- 指定返回其他字段：

```graphql
// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_moreFields
query {
  NopAuthUser__findList {
    ...F_moreFields
  }
}
```

### 属性列表 {#def_attr_props_prop}

:::tip

目前仅关注与后端处理相关的属性，对于仅在 XView 层面使用的属性（如
`ui:maxUploadSize` 等）暂时未做整理。

:::

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_name"> name </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_schema"> &lt;schema /> </TCol>
<TCol> ISchema </TCol><TCol> 属性 Schema </TCol>
<TCol> 否 </TCol><TDesc>

对<b>当前属性</b>值类型、值精度等的约束定义。
详细说明见 [基础 DSL - Schema](./dsl/schema#attrs)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 属性显示名称 </TCol>
<TCol> 否 </TCol><TDesc>

方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 属性描述 </TCol>
<TCol> 否 </TCol><TDesc>

描述属性

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_defaultValue"> defaultValue </TCol><TCol>

[any](./dict/std-domain#opt_any)

</TCol><TCol> 属性缺省值 </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_propId"> propId </TCol>
<TCol> int </TCol><TCol> 属性的顺序标识 </TCol>
<TCol> 否 </TCol><TDesc>

可以对应于 protobuf 标准中的 `propId` 属性，同时也与 ORM 实体上的 `propId` 对应

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mapToProp"> mapToProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 映射到 ORM 实体的指定属性 </TCol>
<TCol> 否 </TCol><TDesc>

为 ORM 实体的属性（注意，**不是业务对象的属性**）映射一个别名，
如，将 ORM 实体的属性 `a.b` 映射到别名 `b` 上，在 GraphQL 返回结果时，
会通过 `OrmDependsPropFetcher` 从 ORM 实体上获取 `a.b` 的值后赋值给对象的属性 `b`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_depends"> depends </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> <b>当前属性</b>所依赖的属性列表 </TCol>
<TCol> 否 </TCol><TDesc>

逗号分隔的属性列表（需在 ORM 实体上有映射）。在获取<b>当前属性</b>的值时，需要依赖其他字段。
例如，在批量加载<b>当前属性</b>时，需要把依赖的属性也进行批量加载

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mandatory"> mandatory </TCol>
<TCol> boolean </TCol><TCol> 属性值必填？ </TCol>
<TCol> 是 </TCol><TDesc>

指示<b>当前属性</b>是否为必填项。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_internal"> internal </TCol>
<TCol> boolean </TCol><TCol> 是否内部属性？ </TCol>
<TCol> 是 </TCol><TDesc>

自动推导生成的业务对象属性，将被设置为内部属性，即，`internal="true"`。
在 XView 中默认不显示内部属性。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_deprecated"> deprecated </TCol>
<TCol> boolean </TCol><TCol> 是否已废弃？ </TCol>
<TCol> 是 </TCol><TDesc>

已废弃的属性将不再被使用。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_insertable"> insertable </TCol>
<TCol> boolean </TCol><TCol> 是否可新增？ </TCol>
<TCol> 是 </TCol><TDesc>

若为 `false`，则新增的 ORM 实体将不会插入该属性数据。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_updatable"> updatable </TCol>
<TCol> boolean </TCol><TCol> 是否可更新？ </TCol>
<TCol> 是 </TCol><TDesc>

若为 `false`，则更新的 ORM 实体将不会更新该属性数据。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_virtual"> virtual </TCol>
<TCol> boolean </TCol><TCol> 是否虚拟字段？ </TCol>
<TCol> 是 </TCol><TDesc>

虚拟字段不会被复制到 ORM 实体上。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_published"> published </TCol>
<TCol> boolean </TCol><TCol> 是否对外开放？ </TCol>
<TCol> 是 </TCol><TDesc>

为 `false` 时，则在 GraphQL 返回的对象中将不包含该属性，对外不可见，
比如，密码等敏感属性。缺省为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_exportable"> exportable </TCol>
<TCol> boolean </TCol><TCol> 是否可导出？ </TCol>
<TCol> 是 </TCol><TDesc>

仅当该值为 `true` 且
[published](#attr_props_prop_published) 也为 `true`
时，该属性才能够被导出。缺省为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_sortable"> sortable </TCol>
<TCol> boolean </TCol><TCol> 是否可排序？ </TCol>
<TCol> 是 </TCol><TDesc>

是否可以被作为排序字段出现在 SQL 的 `order by` 语句中。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_queryable"> queryable </TCol>
<TCol> boolean </TCol><TCol> 是否可查询？ </TCol>
<TCol> 是 </TCol><TDesc>

该属性对应的 ORM 表字段是否可以被作为查询字段出现在 SQL 的 `where` 语句中，
与 `allowFilterOp` 配合，可限制在该属性对应的 ORM 表字段上能够应用的过滤运算。缺省为 `false`。
注：作为[过滤器转换](#def_attr_props_prop_graphql_transFilter)的对象属性需要设置该属性值为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_allowFilterOp"> allowFilterOp </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> 允许的过滤运算 </TCol>
<TCol> 否 </TCol><TDesc>

可以在该属性对应的 ORM 表字段上执行哪些查询运算，如
`gt`、`ge`、`contains`、`like`等，默认只允许 `in`、`eq`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_lazy"> lazy </TCol>
<TCol> boolean </TCol><TCol> 是否懒加载？ </TCol>
<TCol> 是 </TCol><TDesc>

缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_kind"> ext:kind </TCol>
<TCol> string </TCol><TCol> 类别 </TCol>
<TCol> 否 </TCol><TDesc>

可选值：

- `to-one`：业务对象与属性对应的对象为一对一关联；
- `to-many`：业务对象与属性对应的对象为一对多关联；
- `alias`：表示其为在 ORM 实体上定义的别名，通过该属性名，可以找到别名映射的源属性；
- `component`：表示其为 ORM 实体中的组件字段，比如，JSON 字段。
  注意，对于文件字段，会通过 `mapToProp` 映射到 ORM 实体对应组件字段的
  `fileStatus`/`fileStatusList` 属性上，不再设置 `ext:kind="component"`；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_tagSet"> tagSet </TCol><TCol>

[tag-set](./dict/std-domain#opt_tag_set)

</TCol><TCol> 附加标识列表 </TCol>
<TCol> 否 </TCol><TDesc>

**[XOrm Only]**
逗号分隔的自定义标识列表。用于 CodeGen 在通过 `app.orm.xml`
生成 xmeta 时，会根据这些标识来设置其他属性的值。其实际来自于设置在
ORM 实体属性上的 `tagSet`。注意，**若是以 XMeta 为中心设计模型，是不需要该属性的**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_type"> graphql:type </TCol>
<TCol> string </TCol><TCol> <b>当前属性</b>值的返回类型 </TCol>
<TCol> 否 </TCol><TDesc>

将<b>当前属性</b>的值按该设定的类型转换后返回。该属性的可选值为枚举类
`io.nop.graphql.core.schema.GraphQLScalarType`
中的各个枚举量的名称（大小写敏感），如 `String`、`Map`。
如果返回的是集合类型，则需要将可选值包裹在 `[]` 内，如
`[String]`（字符串集合）、`[Map]`（键值对集合）。
注意：

- 作为主键的 `Long` 型数据，一般要求将其转换为 `String`
  后返回，因为，JS 对于超过一定大小的 `Long` 型数据会无法正常处理；
- 对于内容为 JSON 格式的字符串，可以设定返回类型为 `[Map]`，以便于前后端以
  JSON 对象交换数据；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_mapper"> graphql:mapper </TCol>
<TCol> string </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_labelProp"> graphql:labelProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 作为<b>当前属性</b>显示文本的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>指向的是对象（含对象集合）或数据字典时，
一般需要声明使用业务对象中的哪个[属性](#def_attr_props_prop)的值作为其显示文本。
其优先级高于 [ext:joinRightDisplayProp](#attr_props_prop_ext_joinRightDisplayProp)。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictName"> graphql:dictName </TCol>
<TCol> string </TCol><TCol> 数据字典名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于 [graphql:labelProp](#attr_props_prop_graphql_labelProp)
所指向的业务对象属性，其值为所关联的数据字典。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictValueProp"> graphql:dictValueProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 与数据字典关联的业务对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于 [graphql:labelProp](#attr_props_prop_graphql_labelProp)
所指向的业务对象属性，其值为对应的 `graphql:labelProp`
所在的业务对象属性，从而使 `graphql:dictValueProp`
与 `graphql:labelProp` 构成双向关联。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinLeftProps"> graphql:joinLeftProps </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinRightProps"> graphql:joinRightProps </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_datePattern"> graphql:datePattern </TCol>
<TCol> string </TCol><TCol> 日期转换格式 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>的数据类型为 `Timestamp`，且系统配置
`nop.graphql.ignore-millis-in-timestamp`（`Timestamp` 类型是否不以毫秒形式返回）为 `true`
时，NopGraphQL 引擎会自动将<b>当前属性</b>的值按该设定的形式格式化为字符串后返回。
注意，若设定的转换格式为 `ms`，则返回日期的毫秒值字符串，其余的转换格式按
`SimpleDateFormat` 支持的形式进行设定即可，如 `yyyy-MM-dd HH:mm:ss`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_transFilter"> &lt;graphql:transFilter /> </TCol><TCol>

[xpl-fn](./dict/std-domain#opt_xpl_fn): `(filter, query, forEntity) => any`

</TCol><TCol> 过滤器转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>上做过滤运算的过滤器均会被替换为该转换函数所构造的过滤器，从而简化复杂过滤条件的使用。
详细说明见 [XMeta 过滤器转换](#def_attr_props_prop_graphql_transFilter)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ui_maskPattern"> ui:maskPattern </TCol>
<TCol> string </TCol><TCol> 掩码模式 </TCol>
<TCol> 否 </TCol><TDesc>

GraphQL 返回的数据会自动按照其指定的模式调用 `StringHelper#maskPattern`
函数对<b>当前属性</b>的值做掩码处理，如，`ui:maskPattern="3*4"` 表示保留前 3 位以及后 4 位字符，
中间部分用 `*` 来代替。可应用于安全性要求较高的属性上。其将在 `x:post-extends`
阶段为<b>当前属性</b>自动生成
[&lt;transformOut />](#attr_props_prop_transformOut)（详见 Xpl 函数 `meta-gen:GenMaskingExpr`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_moduleId"> biz:moduleId </TCol>
<TCol> string </TCol><TCol> 关联对象所属的模块 </TCol>
<TCol> 否 </TCol><TDesc>

Nop 模块标识（如，`nop/auth`）。在<b>当前属性</b>关联的是其他模块的对象时，需要通过该属性指示该关联对象所属的模块

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_codeRule"> biz:codeRule </TCol>
<TCol> string </TCol><TCol> 编码规则 </TCol>
<TCol> 否 </TCol><TDesc>

用于自动生成订单号、卡号等，该值不为空时，将在 `x:post-extends` 阶段为<b>当前属性</b>自动生成
[&lt;autoExpr />](#attr_props_prop_autoExpr)（详见 Xpl 函数 `meta-gen:GenCodeRuleAutoExpr`）。
详细说明见文档<NopDocLink title="《编码规则》" path="/dev-guide/biz/coderule.md" />

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_relation"> ext:relation </TCol>
<TCol> string </TCol><TCol> 关联映射到的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinLeftProp"> ext:joinLeftProp </TCol>
<TCol> string </TCol><TCol> 关联的源端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightProp"> ext:joinRightProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightDisplayProp"> ext:joinRightDisplayProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的显示属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_orm_manyToManyRefProp"> orm:manyToManyRefProp </TCol>
<TCol> string </TCol><TCol> 多对多关联的中间模型中另一方的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于多对多关联，其指向在中间模型中用于映射对端模型的属性。
详细说明见 [XMeta 对象关联配置 - 多对多](#relations-many-to-many)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_queryMethod"> graphql:queryMethod </TCol>
<TCol> GraphQLQueryMethod </TCol><TCol> 关联过滤查询的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于指定关联过滤查询的返回结果类型。
详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_connectionProp"> graphql:connectionProp </TCol><TCol>

[prop-name](./dict/std-domain#opt_prop_name)

</TCol><TCol> 关联过滤查询所指向的业务对象的属性 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_authObjName"> graphql:authObjName </TCol>
<TCol> string </TCol><TCol> 关联过滤查询的数据权限模型名称 </TCol>
<TCol> 否 </TCol><TDesc>

指定在[关联过滤查询](#relations-connection)时所应用的数据权限模型。
默认为被过滤对象的 [BizModel](./xbiz) 名称。`IDataAuthChecker#getFilter`
将根据该数据权限模型生成额外的过滤条件，从而实现按行对数据进行访问控制

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_inputType"> &lt;graphql:inputType /> </TCol><TCol>

[class-name](./dict/std-domain#opt_class_name)

</TCol><TCol> GraphQL 输入参数类型的类全名 </TCol>
<TCol> 否 </TCol><TDesc>

以强类型方式定义
[GraphQL 输入参数](https://graphql.org/learn/queries/#arguments)，
以对输入参数自动进行数据校验和类型转换。

例如，`GraphQLConnectionInput` 就被定义为[关联过滤查询](#relations-connection)的默认输入参数类型。

该类型的定义需满足以下条件：

- 在类上标注 `@GraphQLInput`；
- 各参数均需提供 getter 方法，并在方法上标注 `@PropMeta`；
- 在注解 `@PropMeta` 上按顺序递增设置 `propId` 的值；

**注**：该设置还未真正被使用，当前在 BizModel 中使用的是 `Map` 弱类型形式

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg"> &lt;arg /> </TCol>
<TCol> ObjPropArgModel </TCol><TCol> GraphQL 输入参数定义列表 </TCol>
<TCol> 否 </TCol><TDesc>

与 [&lt;graphql:inputType />](#attr_props_prop_graphql_inputType)
的作用相同，只不过后者是以 Java Class 方式定义输入参数，并且，在配置了
`<graphql:inputType />` 的情况下，`<arg />` 将被忽略。
详细说明见 [XMeta GraphQL 输入参数列表](#def_attr_props_prop_arg)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_maxFetchSize"> graphql:maxFetchSize </TCol>
<TCol> int </TCol><TCol> 当前<b>关联查询属性</b>一次查询所能取的最大数据量 </TCol>
<TCol> 否 </TCol><TDesc>

缺省值为 `-1`。仅对**关联查询属性**有效，用于控制每次查询所能取得的最多数据，
前端指定的分页大小将被限制在该值及其以下。在其值小于或等于 `0` 时，则分页大小不能超过系统配置
`nop.graphql.max-page-size` 的设定值（缺省为 `1000`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_filter"> &lt;graphql:filter /> </TCol><TCol>

[filter-bean](./dict/std-domain#opt_filter_bean)

</TCol><TCol> 当前<b>关联查询属性</b>的默认过滤条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的过滤条件。其将与前端设置的过滤条件以 `and` 方式组合

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_orderBy"> &lt;graphql:orderBy>&lt;field />&lt;/graphql:orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> 当前<b>关联查询属性</b>的默认排序条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的排序条件。其将与前端设置的排序条件组合在一起。
详细说明见 [ORM 实体排序条件](#def_attr_orderBy_field)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformIn"> &lt;transformIn /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 输入数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

将接口调用回传的<b>业务对象属性</b>的值按该转换函数处理后，再赋值给业务对象。
比如，将提交的数据从逗号分隔的字符串转换为 `List<String>` 类型。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformOut"> &lt;transformOut /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 输出数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

NopGraphQL 将<b>业务对象属性</b>的值按该转换函数处理后，再返回给接口调用方。
比如，将 `List<String>` 类型数据转换为逗号分隔的字符串，或者将密码等敏感数据脱敏后再返回。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_getter"> &lt;getter /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> <b>业务对象属性</b>的 Getter 函数 </TCol>
<TCol> 否 </TCol><TDesc>

为<b>业务对象属性</b>定义 Getter 函数，其将覆盖对象实体上的 Getter 方法，
以便于添加动态处理逻辑。

其用于 NopGraphQL 向客户端返回数据之前的准备阶段。

其可以与 [&lt;transformOut />](#attr_props_prop_transformOut)
同时设定，且该 Getter 函数先执行，而其执行结果将作为参数 `value`
传给 `<transformOut />` 函数。该 Getter 函数的可用参数如下（详细执行逻辑见
`PropGetterFetcher`）：

- `entity`: 其为业务对象自身；
- 其他：在 [GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
  上的输入参数；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_setter"> &lt;setter /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> <b>业务对象属性</b>的 Setter 函数 </TCol>
<TCol> 否 </TCol><TDesc>

为<b>业务对象属性</b>定义 Setter 函数，其将覆盖对象实体上的 Setter 方法，
以便于添加动态处理逻辑。

其用于 NopGraphQL 根据客户端提交数据构造业务对象的过程中。

其可以与 [&lt;transformIn />](#attr_props_prop_transformIn)
同时设定，`<transformIn />` 函数的执行结果将作为参数 `value`
传给该 Setter 函数。该 Setter 函数的可用参数如下（详细执行逻辑见
`OrmEntityCopier#copyField`）：

- `entity`: 其为业务对象自身；
- `value`: 其为<b>业务对象属性</b>的值。可能为 `null`；
- `propMeta`: `IObjPropMeta` 类型，其为<b>业务对象属性</b>的[结构](#def_attr_props_prop)；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr"> &lt;autoExpr /> </TCol>
<TCol> ObjConditionExpr </TCol><TCol> 自动计算属性缺省值 </TCol>
<TCol> 否 </TCol><TDesc>

用于新增或者修改的时候自动计算<b>业务对象属性</b>的缺省值，
比如，根据子表中的商品价格自动计算汇总价格等。
详细说明见 [XMeta 属性自动计算](#def_attr_props_prop_autoExpr)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth"> &lt;auth /> </TCol>
<TCol> ObjPropAuthModel </TCol><TCol> 字段级别的访问控制 </TCol>
<TCol> 否 </TCol><TDesc>

用于配置对<b>业务对象属性</b>的读写权限，从而实现对业务对象属性的访问权限控制。
详细说明见 [XMeta 属性访问控制](#def_attr_props_prop_auth)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_selection"> &lt;graphql:selection /> </TCol><TCol>

[field-selection](./dict/std-domain#opt_field_selection)

</TCol><TCol> 默认的 GraphQL 选择字段集 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
若<b>当前属性</b>映射的是一个对象，则可以配置该属性，用于指定默认的
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addDispSelection`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_jsonComponentProp"> graphql:jsonComponentProp </TCol>
<TCol> string </TCol><TCol> <b>当前属性</b>对应的 JSON 组件属性名 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
在<b>当前属性</b>为 JSON 文本时会自动构造一个 [&lt;schema />](#attr_props_prop_schema) 为
`JsonOrmComponent` 的对象属性，并赋值 `graphql:jsonComponentProp` 以指向该属性，从而建立起二者的关联。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addJsonComponent`

</TDesc></TRow>

</Table>

## XMeta 属性显示文本 {#def_attr_props_prop_graphql_labelProp}

在业务对象的属性对应的是数据字典，或者为[关联对象](#relations)的 ID 列表时，
可以在业务对象中定义一个作为其**显示文本**的属性，以便于在前端显示，再通过
`graphql:labelProp` 指向该显示文本属性，以建立二者之间的引用关系，比如：

```xml {4,10,11} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="status"
          graphql:labelProp="status_label"
    >
      <schema type="Integer" dict="auth/user-status"/>
    </prop>

    <prop name="status_label"
          graphql:dictValueProp="status"
          graphql:dictName="auth/user-status"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

在本例中，`status` 赋值的是数据字典 `auth/user-status` 的 `value`
值，其类型是 `Integer`，若在前端直接显示该属性值，则不方便用户进行识别，
因此，可以为 `status` 构建一个相应的<u>用于显示其对应数据字典的 `label`
文本</u>的属性 `status_label`。

NopGraphQL 引擎将会根据 `graphql:dictValueProp`
所指定的业务对象属性（即本例中的 `status`）的实际值，从 `graphql:dictName`
对应的数据字典（`auth/user-status`）中获取到字典枚举值的显示文本，
并将该文本内容作为 `status_label` 的值返回给前端。

前端仅需要在 GraphQL Field Selection 中包含 `status_label`
即可得到 `status` 对应的显示文本内容，从而避免前端单独处理对数据字典的文本回显：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    status
    status_label
  }
}
```

而对于[一对多/多对多](#relations-many-to-many)的对象关联场景中：

```xml {14} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="relatedRoleList"
          ext:kind="to-many"
          lazy="true"
    >
      <schema>
        <item bizObjName="NopAuthRole"/>
      </schema>
    </prop>

    <prop name="relatedRoleIdList"
          ext:relation="relatedRoleList"
          graphql:labelProp="relatedRoleList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.String&gt;"/>
    </prop>

    <prop name="relatedRoleList_label"
          lazy="true"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

可为关联目标端的主键（`id`）列表 `relatedRoleIdList` 构造一个对应的显示文本列表
`relatedRoleList_label`，而在 [Nop Orm](./xorm) 层中将会在实体对象的
Java 代码中为属性 `relatedRoleList_label` 自动生成如下 getter 代码：

```java
  public String getRelatedRoleList_label() {
    return io.nop.core.lang.utils.Underscore.pluckThenJoin(
      getRelatedRoleList(),
      io.nop.auth.dao.entity.NopAuthRole.PROP_NAME_roleName
    );
  }
```

也就是，从关联目标端列表 `relatedRoleList` 中依次取其[显示属性](#attr_displayProp)（本例中为
`roleName`）的值，再以逗号 `,` 分隔组成字符串（`Underscore#pluckThenJoin`）后返回。

如此，前端便可以在获取关联目标端 id 列表的同时获取对应的显示文本列表：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleIdList
    relatedRoleIdList_label
  }
}
```

当然，在实际使用时也没有必要分别获取 id 及其显示文本列表，
直接返回关联对象列表及其必要属性，应该作为优先选择方案：

```graphql {5-8}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleList {
      id
      roleName
    }
  }
}
```

## XMeta 过滤器转换 {#def_attr_props_prop_graphql_transFilter}

对业务对象的过滤可能会涉及较为复杂的组合条件（如，子查询等），或者是组合条件会出现多次，
亦或是直接拼接 SQL 片段，在这些情况下，便需要通过过滤器转换机制来实现。

过滤器转换机制就是通过一个转换函数，对过滤器（其为 `TreeBean`
类型）的树形结构上的节点（子过滤器）进行替换。

> 具体的转换逻辑见 `io.nop.api.core.beans.query.QueryBean#transformFilter`。

在 XMeta 中仅需要定义一个配置了过滤器转换函数 `graphql:transFilter`
的[对象属性](#def_attr_props_prop)即可，例如：

```xml {3,9,16} title="NopAuthSite.xmeta"
<meta>
  <x:gen-extends>
    <meta-gen:DefaultMetaGenExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:gen-extends>

  <props>
    <!-- Note：只有可查询（queryable = true）的属性才能参与过滤运算 -->
    <prop name="hasResourceStatus" queryable="true">
      <graphql:transFilter>
        <filter:sql>
          exists (
            select o2
            from NopAuthResource o2
            where
              o2.siteId = o.id
              and o2.status >= ${ filter.getAttr('value') }
          )
        </filter:sql>
      </graphql:transFilter>
    </prop>
  </props>
</meta>
```

在该例中，为对象属性 `hasResourceStatus` 配置了过滤器转换函数，其通过 Xpl 函数
`filter:sql` 构造了一个包含 SQL 片段的子过滤器，用于替换以 `hasResourceStatus`
作为运算条件的过滤器，并且，在该 SQL 片段中还以 `${ filter.getAttr('value') }`
形式引用了被替换过滤器的属性 `value` 的值。

> 注意，Xpl 函数 `meta-gen:DefaultMetaGenExtends` 会在
> XMeta 解析前全局引入 `filter:sql` 所在的函数库
> `/nop/core/xlib/filter.xlib`（即 `<c:import from="/nop/core/xlib/filter.xlib"/>`），
> 因此，不需要再在 `<filter:sql/>` 节点上配置
> `xpl:lib` 属性（即 `<filter:sql xpl:lib="/nop/core/xlib/filter.xlib"/>`）。

在调用对应的 GraphQL 接口时，可以构造如下形式的根过滤器 `filter`：

<!-- prettier-ignore -->
```json {10} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "and",
      "$body": [
        {
          "$type": "gt", "name": "orderNo", "value": 100
        },
        {
          "$type": "eq", "name": "hasResourceStatus", "value": 1
        }
      ]
    }
  }
}
```

以上调用最终生成的 SQL 如下：

```sql {5-10}
select o
from NopAuthSite o
where
  o.orderNo > 100 and
  exists (
    select o2
    from NopAuthResource o2
    where o2.siteId = o.id
    and o2.status >= 1
  )
```

也就是，以 `hasResourceStatus` 作为运算条件的过滤器均会被替换为
`graphql:transFilter` 所构造出的过滤器。

`graphql:transFilter` 的类型是 `xpl-fn`，即，一个 Xpl 函数，其函数签名为
`(filter, query, forEntity) => any`，函数参数分别为：

- `filter`：类型为 `TreeBean`，表示将要被替换的过滤器，即上例中的
  `{"$type": "eq", "name": "hasResourceStatus", "value": 1}`；
- `query`：类型为 `QueryBean`，对应于 GraphQL 接口中的 `query` 参数；
- `forEntity`：类型为 `Boolean`，始终为 `false`；

> `graphql:transFilter` 的执行逻辑见 `io.nop.biz.crud.BizQueryHelper#transformFilter`。

根据 `TreeBean#transformChild` 的处理逻辑可以发现 `graphql:transFilter`
函数的返回值可以是 `Boolean`、`XNode`、`null` 或者 `Collection<XNode>`，
因此，该函数的签名中指定的返回值类型为 `any`，并未直接限定返回 `XNode`。

但实际开发中，该函数一般只会返回 `XNode` 节点，以构造过滤条件，
而在构造过程中可以通过 `${...}` 引用该函数的参数，比如，前例中的
`${ filter.getAttr('value') }` 表示从参数 `filter` 中取其属性名为
`value` 的值（即，`1`）。

> 在 `TreeBean` 中除了属性 `$type` 是通过 `TreeBean#getTagName`
> 获取值以外，其余的属性均通过 `TreeBean#getAttr` 获取属性值。

由于 `graphql:transFilter` 函数的返回值是 `XNode` 节点，因此，除了通过
`filter:sql` 构造 SQL 过滤节点以外，还可以直接构造 EQL 过滤节点，甚至是二者共用：

```xml {3,4,12}
    <prop name="withOrderNoAndResourceStatus" queryable="true">
      <graphql:transFilter>
        <and xpl:outputMode="node">
          <gt name="orderNo" value="${ filter.getAttr('orderNo') }"/>

          <filter:sql>
            exists (
              select o2
              from NopAuthResource o2
              where
                o2.siteId = o.id
                and o2.status >= ${ filter.getAttr('resourceStatus') }
            )
          </filter:sql>
        </and>
      </graphql:transFilter>
    </prop>
```

> - `graphql:transFilter` 本身不支持输出，所以，需要在其标签内通过输出模式
>   `xpl:outputMode` 为 `node` 的 Xpl 脚本输出一个 `XNode` 节点；

在前端仅需要构造一个如下的过滤器即可得到与前面例子相同的过滤条件：

<!-- prettier-ignore -->
```json title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

注意，在该过滤器中不再设置 `value` 属性，而是分别指定了两个混合过滤器所需的参数
`orderNo` 和 `resourceStatus`，并调用 `TreeBean#getAttr` 获得了过滤器的传入值。

可以发现，虽然上面的过滤器传入了两个附加参数，但依然采用的是 `eq` 运算符。
这是因为，在属性定义上，默认的 `allowFilterOp`（允许的过滤运算）仅有 `eq` 和 `in`。
若是需要采用其他运算符，则需要显式设置 `allowFilterOp`，比如：

```xml {3}
    <prop name="withOrderNoAndResourceStatus"
          queryable="true"
          allowFilterOp="with"
    >
      <graphql:transFilter>
        <!-- ... -->
      </graphql:transFilter>
    </prop>
```

然后，构造过滤器为：

<!-- prettier-ignore -->
```json {4} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "with",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

此外，`filter` 实际所使用的运算符可以通过 `filter.getTagName()` 得到，
所以，在某些动态场景下，还可以根据实际使用的运算符来构造不同的过滤器：

```xml {7,18}
    <prop name="resourceStatus"
          queryable="true"
          allowFilterOp="eq,in"
    >
      <graphql:transFilter>
        <c:choose xpl:outputMode="node">
          <when test="${ filter.getTagName() == 'eq' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status = ${ filter.getAttr('value') }
              )
            </filter:sql>
          </when>
          <when test="${ filter.getTagName() == 'in' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status in (${ filter.getAttr('value') })
              )
            </filter:sql>
          </when>
          <otherwise>
            <!-- Note：若不做任何处理，则会删除待替换的过滤器 filter -->
            <c:throw
                errorCode="nop.err.xmeta.trans-filter.not-supported-op"
                params="${ {name: filter.getAttr('name'), op: filter.getTagName()} }"
            />
            <!-- 直接返回待替换的过滤器 filter，不做替换或删除 -->
            <!--<c:script>filter</c:script>-->
          </otherwise>
        </c:choose>
      </graphql:transFilter>
    </prop>
```

> 在涉及多分支判断时，不能采用 `c:if` 或 `xpl:if` 做分支处理，否则
> `graphql:transFilter` 将返回最后一个 if 分支的结果，若该分支不满足判断条件，则实际将返回
> `null`，而不是满足判断条件的分支结果。

如此，便可以按需使用 `eq` 或 `in` 过滤器来进行过滤查询：

<!-- prettier-ignore -->
```json {4,12} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq", "name": "resourceStatus", "value": 1
    }
  }
}
// 或者
{
  "query": {
    "filter": {
      "$type": "in", "name": "resourceStatus", "value": [1, 2, 3]
    }
  }
}
```

## XMeta 对象关联配置 {#relations}

### 一对一 {#relations-one-to-one}

```plantuml
class Left {
  + id: int
  + rightId: int
  + right: Right
}

class Right {
  + id: int
  + displayName: string
}

Left "1" -right-> "1" Right
```

根据以上图例所生成的 XMeta 为：

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

- `ext:relation` 用在 `Left`（关联的源端）直接与关联目标端（`Right`）建立关联的属性上，
  其指向在 `Left` 中与映射到关联目标端对象的属性上，如，`rightId -> right`；
- 在与关联目标端对象映射的属性上声明关联关系，包括：`ext:kind`、`ext:joinLeftProp`、`ext:joinRightProp` 等；
- `ext:kind` 设置为 `to-one`（一对一）模式关联 `Right`；
- `ext:joinLeftProp` 表示在 `Left`（关联的源端）中用于与 `Right`（关联的目标端）建立关联的属性；
- `ext:joinRightProp` 表示在 `Left`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
  `Right`（关联的目标端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Right`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 一对多 {#relations-one-to-many}

> 注意，一对多和一对一是互为反方向的关联配置，因此，二者是分别配置在关联的源端和目标端中的。

```plantuml
class Left {
  + id: int
  + rightId: int
  + displayName: string
}

class Right {
  + id: int
  + leftList: List<Left>
}

Right "1" -left-> "0..*" Left
```

根据以上图例所生成的 XMeta 为：

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftList"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
  </props>
</meta>
```

- `ext:kind` 设置为 `to-many`（一对多）模式关联 `Left`；
- `ext:joinRightProp` 表示在 `Left`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
- `ext:joinLeftProp` 表示在 `Left`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
  `Right`（关联的源端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Left`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 多对多 {#relations-many-to-many}

在 Nop 中是通过中间模型来建立多对多的关联，并通过中间模型将多对多分解为中间模型与关联双方的一对多关联：

> 详细的说明文件见文档<NopDocLink title="《多对多关联》" path="/dev-guide/orm/many-to-many.md" />。

```plantuml
class Left {
  + id: int
  + rightMappings: List<Ref>
}

map Ref {
  leftId => rightId
}

class Right {
  + id: int
  + leftMappings: List<Ref>
}

Ref "1" -left-> "1" Left::id
Ref "1" -right-> "1" Right::id
```

根据以上图例所生成的 XMeta 分别为：

- 配置 `Left` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Right`

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="leftId"
          orm:manyToManyRefProp="rightId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedRightIdList"
          ext:relation="relatedRightList"
          graphql:labelProp="relatedRightList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedRightList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Right"/>
      </schema>
    </prop>
    <prop name="relatedRightList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Left`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Left`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Right`（即，多对多的目标端模型）建立关联的属性；
> - `relatedRightList` 和 `relatedRightIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Left` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Right` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Left`

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          orm:manyToManyRefProp="leftId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedLeftIdList"
          ext:relation="relatedLeftList"
          graphql:labelProp="relatedLeftList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedLeftList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
    <prop name="relatedLeftList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Right`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Left`（即，多对多的目标端模型）建立关联的属性；
> - `relatedLeftList` 和 `relatedLeftIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Right` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Ref` 与 `Left` 和 `Right` 的一对一关联

```xml title="Ref.xmeta"
<meta>
  <props>
    <prop name="leftId" ext:relation="left">
      <schema type="java.lang.Integer"/>
    </prop>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="left"
          ext:kind="to-one"
          ext:joinLeftProp="leftId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Left"/>
    </prop>
    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-one`（一对一）模式关联 `Left` 或 `Right`；
> - `ext:joinLeftProp` 表示在 `Ref`（关联的源端）中用于与关联目标端（`Left` 或 `Right`）建立关联的属性；
> - `ext:joinRightProp` 表示在 `Ref`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
>   关联目标端（`Left` 或 `Right`）的属性；
> - `ext:relation` 用在 `Ref`（关联的源端）直接与关联目标端（`Left` 或 `Right`）建立关联的属性上，
>   其指向在 `Ref` 中与映射到关联目标端对象的属性上，如，`leftId -> left`、`rightId -> right`；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 关联过滤查询 {#relations-connection}

> 详细的说明请参考：
>
> - <NopDocLink title="Connection 配置" path="/dev-guide/graphql/connection.md" />
> - <NopDocLink title="Nop 入门：如何实现复杂查询" path="/tutorial/simple/4-complex-query.md" />
> - <NopDocLink title="如何实现对列表列表数据的过滤" path="/dev-guide/recipe/filter-list.md" />

:::tip

NopGraphQL 的 `DataFetcher` 机制会在获得主查询的结果后，
再逐条进行子查询，因此可能会出现明显的性能问题，在性能问题较明显时，需考虑在
<NopDocLink title="@SqlLibMapper" path="/dev-guide/orm/sql-lib.md" />
中做自定义查询或者采用按需加载机制。

:::

NopGraphQL 引擎提供 `DataFetcher` 机制，可以通过 `OrmEntityPropConnectionFetcher`
实现按需对关联对象进行过滤和排序，比如，按指定条件 `filter` 过滤出 `NopAuthSite`
的资源列表 `resourcesList`：

```graphql {6}
query($filter: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    resourcesList(filter: $filter, limit: 10, offset: 0) {
      total
      items {
        id
        displayName
      }
    }
  }
}

variables:
  filter: {
    "$type": "or",
    "$body": [
      { "$type": "eq", "status", 1},
      { "$type": "eq", "status", 2}
    ]
  }
```

则只需要在 `NopAuthSite.xmeta` 中为其对象属性 `resourcesList` 设置
`graphql:queryMethod`，将其定义为**关联查询属性**：

```xml {3,6,12} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="id"/>

    <prop name="resourcesList"
          graphql:queryMethod="findPage"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:filter>
        <eq name="siteId" value="@prop-ref:id"/>
      </graphql:filter>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

> - `<schema bizObjName="NopAuthResource"/>` 指示了关联对象（即，资源列表）的类型为 `NopAuthResource`；
> - `graphql:filter` 则用于指定关联查询的过滤条件，`@prop-ref:` 前缀表示从业务对象上获取属性值，
>   本例表示，过滤出 `NopAuthResource#siteId` 与业务对象上的属性 `id` 的值相等的数据；
> - `graphql:orderBy` 则指定了查询结果的排序条件，本例表示，按属性 `NopAuthResource#orderNo` 升序排序；
> - 前端传入的 `filter` 和 `orderBy` 参数不会覆盖对 `graphql:filter` 与 `graphql:orderBy`
>   的默认配置，而是会被组合在一起后，再进行过滤和排序；

属性 `graphql:queryMethod` 的可选值如下（具体实现参考 `io.nop.graphql.orm.fetcher.OrmEntityPropConnectionFetcher#get`）：

- `findCount`：返回 `long` 类型数据，表示符合过滤条件的数据总量；
- `findFirst`：返回关联对象类型数据，表示查询结果中的第一条对象数据；
- `findList`：返回 `List` 类型数据，表示查询结果中的全部对象数据；
- `findPage`：返回 `PageBean` 类型数据，表示指定分页的对象数据；
- `findConnection`：返回 `GraphQLConnection` 类型数据，表示指定分页的对象数据；

虽然关联查询的返回结果类型与指定的 `graphql:queryMethod` 相关，但其输入参数类型都是
`GraphQLConnectionInput`，如，`resourcesList(filter: $filter, limit: 10, offset: 0)`
中的括号内的部分既是 `GraphQLConnectionInput` 的各项属性配置。

关联过滤查询并不需要业务对象和关联对象在 ORM 层面存在确切的关联关系，
即使二者没有直接关联关系，甚至可以不在同一数据库中，也能够进行关联过滤查询，只需要通过
`graphql:filter` 指定相应的关联过滤条件即可。

而若是二者在 ORM 层面定义了一对一（`ext:kind="to-one"`）或一对多（`ext:kind="to-many"`）的关联关系，
则可以设置属性 `graphql:connectionProp` 指向对应的关联属性，从而按二者的关联关系自动推导
`graphql:filter` 的配置，如：

```xml {3,14} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="resources"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="siteId"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>
    </prop>

    <prop name="resourcesConnection"
          graphql:queryMethod="findPage"
          graphql:connectionProp="resources"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

也就是，`resourcesConnection` 在查询时会根据 `graphql:connectionProp`
指向的 `resources` 属性的一对多关联自动推导得到过滤条件 `NopAuthResource#siteId = ${id}`。
而若是在 `resourcesConnection` 中再配置 `graphql:filter`，
则表示在已推导得到的过滤条件的基础上再补充额外的过滤条件。

此外，定义的**关联查询属性**（前例中的 `resourcesList` 或 `resourcesConnection`）是可以复用的，利用
GraphQL 的[别名](https://graphql.org/learn/queries/#aliases)机制，
可以实现用同一个关联查询属性返回不同的查询结果：

```graphql {6,13}
query ($filter1: Map, $filter2: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    activeResources: resourcesList(filter: $filter1, limit: 10, offset: 0) {
      items {
        id
        displayName
      }
    }

    inactiveResources: resourcesList(filter: $filter2, limit: 10, offset: 20) {
      items {
        id
        displayName
      }
    }
  }
}
```

## XMeta 输入/输出转换 {#data_transform_in_and_out}

### 输入转换 {#data_transform_in}

为了适配组件规范或者方便用户输入等原因，客户端可能会将本身为列表类型的数据，
采用分隔符拼接为字符串后再提交给服务端，在这种情况下，
屏蔽客户端与服务端之间数据结构差异的最好方式就是对提交数据做**输入转换**，
从而确保在处理业务逻辑时无需关注客户端的变化。

在 XMeta 中可以通过 `<transformIn />` 配置相应的**输入转换函数**，
从而将客户端的输入数据转换为服务端需要的结构，例如，将以 `,` 分隔的
`types` 字符串转换为字符串数组：

```xml {5-7}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>
    </prop>
  </props>
</meta>
```

该输入转换函数的可用参数如下（该函数的调用逻辑见 `ObjMetaBasedValidator#transformIn`）：

- `data`: `Map` 类型，其为客户端提交的全部输入数据；
- `value`: 其为<b>业务对象属性</b>对应的待转换输入数据。可能为 `null`；
- `transData`: `Map` 类型，其包含当前已处理的输入数据，其将被用于构造出业务对象；
- `propMeta`: `IObjPropMeta` 类型，其为<b>业务对象属性</b>的[结构](#def_attr_props_prop)；

在 `<transformIn />` 标签内可以编写任意 <NopDocLink title="Xpl" path="/dev-guide/xlang/xpl.md" />
标签，或者直接编写 <NopDocLink title="XScript" path="/dev-guide/xlang/xscript.md" />
脚本，仅需要确保最后一段的执行逻辑会返回转换后的值即可：

```xml {5}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        return value?.split(',');
      </transformIn>
    </prop>
  </props>
</meta>
```

### 输出转换 {#data_transform_out}

输出转换可以视为[输入转换](#data_transform_in)的逆过程，
也就是，将服务端输出的数据转换为客户端所接受的数据格式：

```xml {5-9}
<meta>
  <props>
    <prop name="types">
      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

不过，与 `<transformIn />` 不同的是，`<transformOut />` 采用的是
NopGraphQL 的 `DataFetcher` 机制进行调用的，其转换逻辑由
`EvalActionTransformFetcher` 执行。

输出转换函数可访问的参数如下：

- `entity`: 其为业务对象自身；
- `value`: 其为<b>业务对象属性</b>的值，也就是待转换的输出数据。可能为 `null`；

### 自动转换 {#data_transform_auto}

得益于 Nop 内置的 `x:post-extends` 元编程机制，在 XMeta 中可以引入 Xpl 函数
`meta-gen:DefaultMetaPostExtends`：

```xml {9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>
</meta>
```

该函数将会根据 [&lt;schema />](#attr_props_prop_schema)
上设置的 [domain](./dsl/schema#attr_domain)
或 [stdDomain](./dsl/schema#attr_stdDomain)，从
`/nop/core/xlib/meta-prop.xlib` 中查找名称为 `domain-{domain}`
或 `domain-{stdDomain}` 的 Xpl 函数，并自动将该函数生成的 `XNode`
合并到<b>当前属性</b>节点上（处理逻辑见 Xpl 函数 `meta-gen:GenPropForDomain`）。

假设，将前面的例子中的属性 `types` 的 Schema Domain 设置为 `comma-list`：

```xml {3,9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>

  <props>
    <prop name="types">
      <schema domain="comma-list" />
    </prop>
  </props>
</meta>
```

然后，通过 Nop delta 机制，在 `/nop/core/xlib/meta-prop.xlib`
中添加函数 `domain-comma-list`（即命名为 `domain-{domain}` 形式）：

```xml {12} title="/_vfs/_delta/default/nop/core/xlib/meta-prop.xlib"
<lib xmlns:x="/nop/schema/xdsl.xdef"
      x:schema="/nop/schema/xlib.xdef"
      x:extends="super"
>
  <tags>
    <domain-comma-list outputMode="node">
      <attr name="propNode"/>

      <source>
        <prop name="${propNode.getAttr('name')}">
          <!-- type 为客户端所接受的类型 -->
          <schema type="String"/>

          <transformIn>
            <c:script><![CDATA[
              return value?.split(',');
            ]]]></c:script>
          </transformIn>

          <transformOut>
            <c:script><![CDATA[s
              import java.lang.String;

              return value ? String.join(',', value) : null;
            ]]]></c:script>
          </transformOut>
        </prop>
      </source>
    </domain-comma-list>
  </tags>
</lib>
```

最终，生成的 `types` 属性的结构如下：

```xml
<meta>
  <props>
    <prop name="types">
      <schema type="String"/>

      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>

      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

此外，对于配置了掩码模式 [ui:maskPattern](#attr_props_prop_ui_maskPattern)
的属性，也会由 Xpl 函数 `meta-gen:GenMaskingExpr` 自动构造并生成如下输出转换函数：

```xml {3,5}
<meta>
  <props>
    <prop name="mobile" ui:maskPattern="3*4">
      <transformOut>
        return value?.toString()?.$maskPattern("3*4");
      </transformOut>
    </prop>
  </props>
</meta>
```

## XMeta 属性自动计算 {#def_attr_props_prop_autoExpr}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr_when"> when </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> 执行计算的条件 </TCol>
<TCol> 是 </TCol><TDesc>

其为调用 `OrmEntityCopier#copyToEntity` 的 `@BizAction`
的名称列表，以 `,` 分隔。表示只有在执行该列表内名称的 BizModel Action
时才计算<b>业务对象属性</b>的缺省值。默认的可选值如下：

- `save`: 保存时；
- `update`: 更新时；
- `copyForNew`: 复制新增时;

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr_body"> &lt;/> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 计算函数 </TCol>
<TCol> 是 </TCol><TDesc>

该函数的可用参数如下（详细执行逻辑见 `AutoExprRunner#runAutoExpr`）：

- `entity`: 其为业务对象自身；
- `data`: 其为客户端提交的数据；
- `objMeta`: `IObjSchema` 类型，其为业务对象的[结构](#attrs)；
- `propMeta`: `IObjPropMeta` 类型，其为<b>业务对象属性</b>的[结构](#def_attr_props_prop)；

</TDesc></TRow>

</Table>

属性自动计算在如下情况将被忽略：

- 客户端 _已提交_ **业务对象属性**的值；
- 客户端的提交 _已被禁用_（即，[insertable](#attr_props_prop_insertable)
  或 [updatable](#attr_props_prop_updatable) 为 `false`）；
- **业务对象属性** _已配置_ [缺省值](#attr_props_prop_defaultValue)；
- **业务对象属性** _已被设置_ 为[虚拟字段](#attr_props_prop_virtual)；

:::tip

[&lt;setter />](#attr_props_prop_setter)
和 [&lt;transformIn />](#attr_props_prop_transformIn)
只在客户端有提交<b>业务对象属性</b>的值时，才会被调用，因此，二者与
`<autoExpr />` 的调用是互斥的，不会同时被调用。

:::

若在<b>业务对象属性</b>上配置了 [biz:codeRule](#attr_props_prop_biz_codeRule)，
但未配置 `<autoExpr />` 时，则会自动构造该属性缺省值的计算函数：

```xml
<meta>
  <props>
    <prop name="code" biz:codeRule="D{@year}{@month}{@seq:5}">
      <autoExpr when="save">
        <c:script><![CDATA[
          const codeRuleGenerator = inject('nopCodeRuleGenerator');

          return codeRuleGenerator.generate(propMeta['biz:codeRule'], $scope);
        ]]></c:script>
      </autoExpr>
    </prop>
  </props>
</meta>
```

## XMeta 属性访问控制 {#def_attr_props_prop_auth}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_for"> for </TCol><TCol>

[xml-name](./dict/std-domain#opt_xml_name)

</TCol><TCol> 权限类型名 </TCol>
<TCol> 是 </TCol><TDesc>

权限类型名的可选值如下：

- `read`: 属性读权限；
- `write`: 属性写权限；
- `all`: 属性读和写权限；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_roles"> roles </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> 拥有 for 权限的角色列表 </TCol>
<TCol> 否 </TCol><TDesc>

以 `,` 分隔的角色列表。若操作者所拥有的角色存在于该列表内，则该操作者便拥有
[for](#attr_props_prop_auth_for) 对应的属性访问权限

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_permissions"> permissions </TCol><TCol>

[multi-csv-set](./dict/std-domain#opt_multi_csv_set)

</TCol><TCol> 拥有 for 权限的操作权限列表 </TCol>
<TCol> 否 </TCol><TDesc>

以 `,` 和 `|` 分隔的操作权限列表，`,` 之间为`与`的关系，`|` 之间为`或`的关系。
若操作者所拥有的操作权限满足该`与/或`关系（判断逻辑见
`IActionAuthChecker#isPermissionSetSatisfied`），则该操作者便拥有
[for](#attr_props_prop_auth_for) 对应的属性访问权限。

操作权限的格式为 `{bizObjName}:{actionName}`，即，对应于
[BizModel](./xbiz) 的 `@BizAction` 方法，
例如，`NopAuthUser:query`、`NopAuthUser:mutation`、`NopAuthUser:delete` 等

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_publicAccess"> publicAccess </TCol>
<TCol> boolean </TCol><TCol> 是否可公开访问？ </TCol>
<TCol> 是 </TCol><TDesc>

若该值为 `true`，则 [roles](#attr_props_prop_auth_roles)
和 [permissions](#attr_props_prop_auth_permissions) 的设置均无效，
所有的操作者均可读写<b>业务对象属性</b>。缺省值为 `false`

</TDesc></TRow>

</Table>

对 XMeta 属性的访问由 `ObjMetaBasedValidator#doCheckAuth` 进行控制，
并且，[roles](#attr_props_prop_auth_roles) 的设置优先于
[permissions](#attr_props_prop_auth_permissions)，
仅当 `roles` 未配置时，`permissions` 的配置才会起作用，
若二者均未配置，则视为无读写权限，将抛出无访问权限的异常。

`permissions` 的检查由 `IActionAuthChecker` 的实现类进行验证，
若是操作权限控制被禁用（即，配置 `nop.auth.enable-action-auth` 为 `false`），
或者在应用中未提供 `IActionAuthChecker` 的实现，则同样视为无读写权限。

> `IActionAuthChecker` 的实现实例需绑定到 `GraphQLEngine` 的实例上。

此外，由于在 nop-file 模块中需要建立 `IFileRecord` 与 `BizObject` 属性的关联，
因此，在上传或下载文件时，在 `NopFileStoreBizModel` 中也会通过
`IBizAuthChecker` 检查关联模型属性的访问权限，其检查逻辑与前面描述的一致，
具体见 `GraphQLActionAuthChecker#checkAuth`。

## XMeta GraphQL 输入参数列表 {#def_attr_props_prop_arg}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_name"> name </TCol><TCol>

[var-name](./dict/std-domain#opt_var_name)

</TCol><TCol> 参数名 </TCol>
<TCol> 是 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_mandatory"> mandatory </TCol>
<TCol> boolean </TCol><TCol> 参数是否必填？ </TCol>
<TCol> 是 </TCol><TDesc>

指示<b>当前参数</b>是否为必填项。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 参数显示名称 </TCol>
<TCol> 否 </TCol><TDesc>

<b>当前参数</b>的显示名称，方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 参数说明 </TCol>
<TCol> 否 </TCol><TDesc>

对参数作用、使用等进行说明

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_schema"> &lt;schema /> </TCol>
<TCol> ISchema </TCol><TCol> 参数 Schema </TCol>
<TCol> 否 </TCol><TDesc>

对当前参数值类型、值精度等的约束定义。
详细说明见 [基础 DSL - Schema](./dsl/schema#attrs)

</TDesc></TRow>

</Table>

NopGraphQL 引擎在通过 `DataFetcher` 获取关联数据时，会根据客户端指定的
[GraphQL 输入参数](https://graphql.org/learn/queries/#arguments)
进行关联数据的动态查询。

为了确保输入参数的完整性和准确性，并支持自动的数据转换和数据校验，
因此，需要对 GraphQL 输入参数进行类型定义。

在 Nop 中，除了通过 [&lt;arg />](#attr_props_prop_arg)
进行输入参数定义，还可以通过
[&lt;graphql:inputType />](#attr_props_prop_graphql_inputType)
以强类型方式进行定义。

而对于 [graphql:queryMethod](#attr_props_prop_graphql_queryMethod)
指定的[关联过滤查询](#relations-connection)则会使用
`GraphQLConnectionInput` 作为缺省的输入参数类型。

从 `ObjMetaToGraphQLDefinition#toFieldDefinition`
的实现中可以确定三种输入参数类型定义的优先级如下：

- 若设置了 `<graphql:inputType />`，则 `<arg />` 将被忽略；
- 若配置了 `<arg />`，则 `GraphQLConnectionInput` 将不会被使用；
- 若配置了 `graphql:queryMethod`，但未配置 `<graphql:inputType />`
  和 `<arg />`，则使用 `GraphQLConnectionInput` 为输入参数缺省类型；

实际开发中，可以在自定义的 [&lt;getter />](#attr_props_prop_getter)
函数中获取到客户端回传的输入参数（详见 `PropGetterFetcher`），并以此进行相应的数据加载处理。
