---
title: XMeta 模型
description: 关于 XMeta 模型的配置说明
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import Header from '@site/docs/\_header.md';
import {NopDocLink, NopVfsLink} from '@site/docs/NopLink';

<Header />

XMeta 为 Nop 平台内置的一种领域模型，主要用于描述业务对象的结构。其为
NopGraphQL 引擎的[核心模型](../implement/component/graphql#engine-core-models)
`IBizObject` 的重要组成部分。

> XMeta 解析后的模型类型即为 [`IObjMeta`](../implement/component/graphql#obj-meta)。

XMeta 模型的结构定义在 <NopVfsLink module="nop-xdefs" path="/nop/schema/xmeta.xdef" />
中，通过分析该 xdef 文件，便可以了解和掌握 XMeta 完整的配置和结构信息。

<!-- https://plantuml.com/object-diagram -->

```plantuml
object "/nop/schema/xmeta.xdef" as xmeta {
}
object "/nop/schema/schema/obj-schema.xdef" as obj_schema {
}
object "/nop/schema/schema/schema-node.xdef" as schema_node {
}

xmeta -down-> obj_schema: xdef:ref 引用

obj_schema -down-> schema_node: xdef:ref 引用
```

在分析 xdef 文件时，需注意以下几点：

- `xdef:name` 用于命名 XDef 节点，在 xdef 文件内的其他节点可以通过
  `xdef:ref` 引用该命名节点的定义。其名字也对应于为该节点所生成的 Java 类名；
- `xdef:ref` 用于引用内部或外部 xdef 定义，前者引用的是 `xdef:name` 所指定的名字，
  后者引用的则是 xdef 文件的虚拟文件系统（VFS）路径；
- `xdef:ref` 引用相当于继承，并且也可以在当前节点上添加其他属性或子节点；
- XDef 之间通过 `xdef:ref` 实现扩展，而 XDSL 之间则通过 `x:extends` 实现扩展；

XMeta 模型定义在 xmeta 文件（以 .xmeta 为后缀的文件）中， 该文件在 Nop 虚拟文件系统（VFS）中以
`_vfs/{一级子目录名}/{二级子目录名}/model/{bizObjName}/{bizObjName}.xmeta`
形式的路径存放（一二级子目录名中不能包含短横线 -，且字母需为小写形式），例如：

<!-- prettier-ignore -->
```xml title="_vfs/nop/demo/model/DepartmentEntity/DepartmentEntity.xmeta"
<meta xmlns:x="/nop/schema/xdsl.xdef"
     x:schema="/nop/schema/xmeta.xdef"
     displayName="部门"
>
  <x:gen-extends>
    <meta-gen:DefaultMetaGenExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:gen-extends>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:post-extends>

  <displayProp>name</displayProp>

  <entityName>io.nop.demo.entity.DepartmentEntity</entityName>
  <primaryKey>oid</primaryKey>
  <keys>
    <key name="UK_code" props="code"/>
  </keys>
  <orderBy>
    <field name="code" desc="true"/>
  </orderBy>

  <tree parentProp="parentId" childrenProp="children"/>

  <props>
    <prop name="oid" propId="1" mandatory="true"
          queryable="true" sortable="true"
          insertable="true" updatable="false"
    >
      <schema type="java.lang.String" precision="32"/>
    </prop>

    <prop name="name" propId="2" mandatory="true"
          queryable="true" sortable="true"
          insertable="true" updatable="true"
    >
      <schema type="java.lang.String" precision="50"/>
    </prop>
    <prop name="code" propId="3" mandatory="true"
          queryable="true" sortable="true"
          insertable="true" updatable="false">
      <schema type="java.lang.String" precision="50"/>
    </prop>

    <prop name="parentId" propId="4"
          queryable="true" sortable="true"
          insertable="true" updatable="true"
          ext:relation="parent"
    >
      <schema type="java.lang.String" precision="32"/>
    </prop>

    <prop name="parent"
          internal="true" queryable="true"
          insertable="false" updatable="false" lazy="true"
          ext:kind="to-one"
          ext:joinLeftProp="parentId" ext:joinRightProp="oid"
    >
      <schema bizObjName="DepartmentEntity"/>
    </prop>
    <prop name="children"
          internal="true"
          insertable="false" updatable="false" lazy="true"
          ext:kind="to-many"
          ext:joinLeftProp="oid" ext:joinRightProp="parentId"
    >
      <schema>
        <item bizObjName="DepartmentEntity"/>
      </schema>
    </prop>
  </props>
</meta>
```

## XMeta 结构 {#attrs}

XMeta 模型的定义以 `<meta />` 为根节点。其第一层级的主要结构如下：

```xml
<meta xmlns:x="/nop/schema/xdsl.xdef"
     x:schema="/nop/schema/xmeta.xdef"
     displayName="xxxx"
>
  <!-- ... -->

  <displayProp>name</displayProp>
  <description>xxxx</description>

  <entityName>io.nop.demo.entity.XxxEntity</entityName>
  <primaryKey>oid</primaryKey>

  <keys> <key .../> </keys>
  <filter>...</filter>
  <orderBy> <field .../> </orderBy>

  <tree .../>
  <selections> <selection .../> </selections>

  <props> <prop ...> </props>
</meta>
```

<Table head={['属性', '值类型', '属性名称']}>

<!-- -->

<TRow><TCol id="attr_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 业务对象的名称 </TCol>
<TDesc>

用于设置业务对象的显示名称，比如，为业务对象 `UserGroupEntity`
设置显示名称为**`用户分组`**，即：

```xml
<meta displayName="用户分组">
  <!-- ... -->
</meta>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_displayProp"> &lt;displayProp /> </TCol>
<TCol> string </TCol><TCol> 显示数据名称的属性 </TCol>
<TDesc>

用于显示业务对象数据名称的[属性名](#attr_props_prop_name)，比如，在业务对象
`RoleEntity` 中的 `name` 属性的值便为角色数据的显示名称，则设置：

```xml
  <displayProp>name</displayProp>
```

在下拉列表、树形控件等需要显示数据名称的组件中需要引用 `<displayProp />` 的设定值。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 描述说明 </TCol>
<TDesc>

用于阐述业务对象的作用、使用注意事项等，如：

```xml
  <description>用户分组：适用于对用户按能力、职能等进行分组的场景</description>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_entityName"> &lt;entityName /> </TCol><TCol>

[class-name](./dict/std-domain#opt_class_name)

</TCol><TCol> ORM 实体的名字 </TCol>
<TDesc>

用于设置与业务对象映射的 ORM 实体的[名字](./xorm#attr_entities_entity_name)（一般与实体的类名相同），
比如：

```xml
  <entityName>io.nop.demo.entity.RoleEntity</entityName>
```

只有在创建了对应的 ORM [实体](./xorm#def_attr_entities_entity)并启用 ORM 支持时才需要设置该值。

在集成了 [NopORM](../implement/component/orm) 后，[NopGraphQL](../implement/component/graphql)
将为业务对象构造相应的 [GraphQL 字段取值](../implement/component/graphql#engine-select-graphql-field)函数
`OrmEntityColumnFetcher`、`OrmEntityPropertyFetcher` 等，用于从数据库中获取该
ORM 实体的指定列（**Column**）的值。详细逻辑见 `io.nop.graphql.orm.OrmBizInitializer#initialize`。

**注意**：`OrmEntityColumnFetcher` 等字段取值函数也将采用
[GraphQL DataLoader 机制](../implement/component/graphql#biz-loader)做
ORM 列的批量加载，因此，不会存在性能问题。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_primaryKey"> &lt;primaryKey /> </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> ORM 实体的主键列表 </TCol>
<TDesc>

用于设置与 ORM
实体的[主键](./xorm#attr_entities_entity_columns_column_primary)相映射的[属性名](#attr_props_prop_name)，
对于复合主键，则需要以逗号分隔多个属性名，例如：

```xml
  <!-- 单一主键 -->
  <primaryKey>oid</primaryKey>

  <!-- 复合主键 -->
  <primaryKey>userId,groupId</primaryKey>
```

`id` 为 NopORM 的保留名字，一般要求不使用 `id` 作为主键属性的名字。但仍然可以通过名字
`id` 得到主键值（调用 `IOrmEntity#get_id`），如果是单一主键，则二者本质是相同的，而如果是复合主键，则通过
`id` 得到的是 `OrmCompositePk` 对象，其包含主键属性及其值，并且该对象的 `toString` 方法返回的是以
`IOrmCompositePk#COMPOSITE_PK_SEPARATOR` 作为分隔符将主键属性值拼接后的结果。

NopGraphQL 对于映射了 ORM 实体的业务对象，将会为名字为 `id` 的字段构造取值函数
`OrmEntityIdFetcher` 用于获取单一主键或复合主键的字符串结果。而若是在 GraphQL Document
的选择字段中未包含 `id` 字段，则会主动附加一个名为 `id` 的字段。该处理逻辑见
`OrmFetcherBuilder#initFetchers` 与 `OrmFetcherBuilder#buildFetcher`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key"> &lt;keys>&lt;key />&lt;/keys> </TCol>
<TCol> ObjKeyModel </TCol><TCol> ORM 实体的唯一键 </TCol>
<TDesc>

用于设置具有**唯一性约束**并与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的[属性名](#attr_props_prop_name)，
例如：

```xml
  <keys>
    <key name="UK_name" props="name"/>
  </keys>
```

在新增或修改 ORM 实体对象时，在 `CrudBizModel`
中将自动检查受唯一性约束的属性在数据库中是否存在重复值，若不唯一，则直接抛出异常。其检查逻辑见
`CrudBizModel#checkUniqueForSave`、`CrudBizModel#checkUniqueForUpdate`。

对 `<keys />` 列表的详细说明见[《ORM 实体唯一键》](#def_attr_keys_key)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_filter"> &lt;filter /> </TCol><TCol>

[filter-bean](./dict/std-domain#opt_filter_bean)

</TCol><TCol> ORM 实体的默认过滤条件 </TCol>
<TDesc>

用于设置在查询该 ORM 实体时需始终附加的过滤条件。其附加逻辑见
`CrudBizModel#prepareFindPageQuery`。

此外，在获取、删除、更新、复制某个确定的 ORM 实体对象时，在 `CrudBizModel`
中也会检查该实体对象是否满足该过滤条件，若不满足，则直接抛出异常。其检查逻辑见
`CrudBizModel#checkMetaFilter`。

因此，其可用于限定用户只能查看和操作特定范围内的数据，例如：

```xml
  <filter>
    <eq name="status" value="1" />
  </filter>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field"> &lt;orderBy>&lt;field />&lt;/orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> ORM 实体的默认排序条件 </TCol>
<TDesc>

用于设置在查询该 ORM 实体时需始终附加的排序条件，例如：

```xml
  <orderBy>
    <field name="status" desc="true"/>
  </orderBy>
```

其附加逻辑见 `CrudBizModel#prepareFindPageQuery`。

对 `<orderBy />` 列表的详细说明见[《ORM 实体排序条件》](#def_attr_orderBy_field)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree"> &lt;tree /> </TCol>
<TCol> ObjTreeModel </TCol><TCol> ORM 实体的树形结构配置 </TCol>
<TDesc>

用于配置 ORM 实体的树形结构信息，例如：

```xml
  <tree parentProp="parentId" childrenProp="children"/>
```

在 `CrudBizModel` 中将根据此结构查询和维护树形结构的
ORM 实体数据，及其父子关联关系（[参考用例](/practice/demo/v2#create-tree)）。

对 `<tree />` 的详细说明见[《ORM 实体树形结构》](#def_attr_tree)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection"> &lt;selections>&lt;selection />&lt;/selections> </TCol>
<TCol> ObjSelectionMeta </TCol><TCol> GraphQL 选择字段集 </TCol>
<TDesc>

对 GraphQL 的选择字段集命名，
用于指定对业务对象的哪些属性做[字段取值](../implement/component/graphql#about-graphql)，
例如：

```xml
  <selections>
    <selection id="F_simpleFields">
      oid, name
    </selection>
  </selections>
```

通过选择字段集的名字，可以以简单的方式引用常用的选择字段列表，不需要反复编写该列表。

对 `<selections />` 的详细说明见[《GraphQL 选择字段集》](#def_attr_selections_selection)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop"> &lt;props>&lt;prop />&lt;/props> </TCol>
<TCol> ObjPropMetaImpl </TCol><TCol> 业务对象的属性定义 </TCol>
<TDesc>

用于描述业务对象的属性信息，例如：

```xml
  <props>
    <prop name="oid" ...> ... </prop>
    <prop name="name" ...> ... </prop>
    <!-- ... -->
  </props>
```

详细说明见[《属性列表》](#def_attr_props_prop)。

</TDesc></TRow>

</Table>

### ORM 实体唯一键 {#def_attr_keys_key}

在新增或修改 ORM 实体对象时，`CrudBizModel`
将自动检查 XMeta 中受唯一性约束的属性（组合属性一起检查）在数据库中是否存在重复值。
若存在重复，则直接抛出异常，从而避免向数据库写入不唯一的数据，保证其唯一性。

> 其检查逻辑详见 `CrudBizModel#checkUniqueForSave`、`CrudBizModel#checkUniqueForUpdate`。

例如，配置 `name` 值唯一，`code1` 与 `code2` 的组合结果唯一：

```xml {5-6}
<meta>
  <!-- ... -->

  <keys>
    <key name="UK_name" props="name"/>
    <key name="UK_code" props="code1,code2"/>
  </keys>

  <!-- ... -->
</meta>
```

注意，`<keys />` 本身没有配置属性，以下仅对其子节点 `<key />` 的结构进行说明：

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_keys_key_name"> name </TCol>
<TCol> string </TCol><TCol> 唯一键名 </TCol>
<TCol> 是 </TCol><TDesc>

用于配置唯一键的名字，其对应数据库层面 `UNIQUE KEY` 的名字，仅包含字母、数字和下划线。

在不同的 `<key />` 标签之间的 `name` 需互不相同。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_props"> props </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> 唯一键属性名列表 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置具有**唯一性约束**并与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的[属性名](#attr_props_prop_name)。
多个属性之间采用逗号分隔

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 唯一键的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置唯一键的显示名称。一般显示 `name` 会更容易区分

</TDesc></TRow>

</Table>

### ORM 实体排序条件 {#def_attr_orderBy_field}

在查询 ORM 实体时，`CrudBizModel` 将会始终向查询语句中附加在
XMeta 中配置的排序条件，从而保证查询结果始终是有序的。

> 其附加逻辑详见 `CrudBizModel#prepareFindPageQuery`。

例如，配置按 `status` 降序排序，并按 `name` 升序排序：

```xml {5-6}
<meta>
  <!-- ... -->

  <orderBy>
    <field name="status" desc="true"/>
    <field name="name" desc="false"/>
  </orderBy>

  <!-- ... -->
</meta>
```

注意，`<orderBy />` 本身没有配置属性，以下仅对其子节点 `<field />` 的结构进行说明：

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_orderBy_field_name"> name </TCol>
<TCol> string </TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的、
参与排序的[属性名](#attr_props_prop_name)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_desc"> desc </TCol>
<TCol> boolean </TCol><TCol> 是否降序排序 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置排序属性值的排序方向。为 `true` 时，表示采用降序排序。
缺省为 `false`，即采用升序排序

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_nullsFirst"> nullsFirst </TCol>
<TCol> boolean </TCol><TCol> NULL 值优先？ </TCol>
<TCol> 否 </TCol><TDesc>

用于设置如何比较排序属性的 `NULL` 值：

- 为 `true` 时，表示 `NULL` 值小于所有非 `NULL` 值；
- 为 `false` 时，表示 `NULL` 值大于所有非 `NULL` 值；

</TDesc></TRow>

</Table>

### ORM 实体树形结构 {#def_attr_tree}

如果同一个 ORM 实体的对象之间存在父子或上下级关系，在逻辑上可构造成一棵或多棵树，
比如，父子部门，则可以在 XMeta 中配置 `<tree />`
节点，以指示如何映射对象之间的父子关系。

> 对于采用复合主键（在 [`<primaryKey />`](#attr_primaryKey) 中包含多个属性）的
> ORM 实体，不适用于树形结构配置，在 `CrudBizModel`
> 中尝试为其构造树形查询时将会抛出异常。

例如，配置以属性 `parentId` 指示父节点，并以属性 `children` 指示子节点的
ORM 实体对象树：

```xml {4}
<meta>
  <!-- ... -->

  <tree parentProp="parentId" childrenProp="children"/>

  <!-- ... -->
</meta>
```

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_tree_parentProp"> parentProp </TCol>
<TCol> string </TCol><TCol> 指示父节点的属性名 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的、
用于指示父节点的[属性名](#attr_props_prop_name)，如 `parentId`。

**注意**：该属性名对应的应该是父节点的主键值，而不是父节点的对象实例，也就是，应该使用
`parentId: String`，而不是 `parent: DepartmentEntity`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_childrenProp"> childrenProp </TCol>
<TCol> string </TCol><TCol> 指示子节点的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置与 ORM
实体的[一对多关联属性名](./xorm#attr_entities_entity_relations_to_many_name)相映射的、
指示子节点对象集合的[属性名](#attr_props_prop_name)，如
`children: List<DepartmentEntity>`。

如果设置了该值，则在通过 `CrudBizModel#delete` 或 `CrudBizModel#deleteByQuery`
删除 ORM 实体对象时，`CrudBizModel` 会在 `#checkChildrenNotExistsWhenDelete(...)`
函数中检查是否存在与其关联的子节点。若是存在关联的子节点对象，
并且在指示子节点的[属性](#def_attr_props_prop)上未配置
[`tagSet`](#attr_props_prop_tagSet) 包含
`cascade-delete`，也即，未启用对关联对象的级联删除，则将抛出异常。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_levelProp"> levelProp </TCol>
<TCol> string </TCol><TCol> 指示节点级别的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的、
用于指示节点级别的[属性名](#attr_props_prop_name)，如 `level`。

其可与 [`rootLevelValue`](#attr_tree_rootLevelValue) 配合使用，
用于设置根节点的过滤条件，也即，仅满足 `o.{levelProp} = ${rootLevelValue}`
的节点为树形结构的根节点。

**注意**：该属性名对应的属性类型必须为整型，如 `level: Integer`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootLevelValue"> rootLevelValue </TCol>
<TCol> string </TCol><TCol> 根节点所对应的节点级别属性的值 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置在表示 ORM 实体对象树的根节点时，[`levelProp`](#attr_tree_levelProp)
所指示的属性的值。例如：

```xml
  <tree ... levelProp="level" rootLevelValue="-1"/>
```

则表示，只有满足 `o.level = -1` 的对象才是对象树的根节点。

其必须与 `levelProp` 同时配置，否则，对二者的单一设置均不会对根节点的过滤起作用。

**注意**：为其配置的值必须能够被正常转换为 `Integer` 类型。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootParentValue"> rootParentValue </TCol>
<TCol> string </TCol><TCol> 根节点所对应的父节点属性的值 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置在表示 ORM 实体对象树的根节点时，[`parentProp`](#attr_tree_parentProp)
所指示的属性的值。例如：

```xml
  <tree ... parentProp="parentId" rootParentValue="root"/>
```

则表示，只有满足 `o.parentId = 'root'` 的对象才是对象树的根节点。

若未设置其值，则缺省以 `o.parentId is null` 作为根节点的判断条件。

**注意**：以 [`levelProp`](#attr_tree_levelProp) +
[`rootLevelValue`](#attr_tree_rootLevelValue)
作为根节点过滤条件的优先级**始终高于** `rootParentValue`，无论是否为其赋值。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_sortProp"> sortProp </TCol>
<TCol> string </TCol><TCol> 指示用于节点排序的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置与 ORM
实体的[列名](./xorm#attr_entities_entity_columns_column_name)相映射的、
用于指示节点排序的[属性名](#attr_props_prop_name)，如 `order`。

若设置了其值，则查询得到的节点将按其指定的属性名排序（未指定排序方向）。
而在其值未设定时，将缺省采用主键 [`<primaryKey />`](#attr_primaryKey)
指示的属性进行排序（未指定排序方向）。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_isLeafProp"> isLeafProp </TCol>
<TCol> string </TCol><TCol> 指示叶子节点的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未使用！**

</TDesc></TRow>

</Table>

在 `CrudBizModel` 中的以下 `@BizQuery`
[查询函数](../implement/component/graphql#biz-model)与 XMeta 的 `<tree />` 配置相关：

- `#findRoots`: 根据 [`levelProp`](#attr_tree_levelProp) +
  [`rootLevelValue`](#attr_tree_rootLevelValue) 或
  [`rootParentValue`](#attr_tree_rootParentValue)
  的配置做根节点的过滤查询，返回根节点所对应的业务对象列表，如 `List<DepartmentEntity>`；
- `#findTreeEntityPage`: 分页查询业务对象树的节点对象 `StdTreeEntity`，并返回
  `PageBean<StdTreeEntity>`；
- `#findTreeEntityList`: 与 `#findTreeEntityPage` 处理相同，只是返回结果为
  `List<StdTreeEntity>`，不包含分页信息；
- `#findPageForTree`: 分页查询业务对象树的节点所对应的业务对象，并返回业务对象的 `PageBean<?>`
  结果，如 `PageBean<DepartmentEntity>`；
- `#findListForTree`: 与 `#findListForTree` 处理相同，只是返回结果为业务对象的 `List<?>`
  数据，如 `List<DepartmentEntity>`，不包含分页信息；

以上查询函数除 `CrudBizModel#findRoots` 以外，均会通过
`TreeEntityHelper#buildTreeEntityBaseSql` 构造以下形式的
Recursive <NopDocLink title="EQL" path="/dev-guide/orm/eql.md" />
查询语句以对业务对象树做过滤查询：

<!-- prettier-ignore -->
```sql {1,6}
with recursive tree_page as (
  select
    b.oid as id, b.oid as joinId, b.parentId as parentId,
    b.name as displayName, b.level as level, b.order as sortProp
  from DepartmentEntity b
  where ${query.filter} and b.parentId is null
 union all
  select
    o.oid as id, o.oid as joinId, o.parentId as parentId,
    o.name as displayName, o.level as level, o.order as sortProp
  from DepartmentEntity o
    inner join tree_page p on o.parentId = p.joinId
)
select
  t.id, t.displayName, t.parentId, t.level, t.joinId
from tree_page t
order by t.sortProp
```

> 详细说明见文档<NopDocLink title="《树形结构相关》" path="/dev-guide/orm/tree-structure.md" />。

在以上 EQL 语句中的 `${query.filter}` 表示需插入的过滤条件，其由查询函数的参数 `query: QueryBean`
提供。从其插入位置可知，客户端指定的过滤条件仅对根节点有效，也就是最终的查询结果是满足过滤条件的根节点，
以及这些根节点在各个层级的全部子节点。

若是要返回指定节点及其子节点数据，则客户端可以在 GraphQL 服务调用数据中构造以下形式的过滤条件：

<!-- prettier-ignore -->
```json {6,12}
{
  "query": "query ($query: QueryBeanInput) { ... }",
  "variables": {
    "query": {
      "filter": {
        "$type": "or",
        "$body": [{
          "name": "oid", "$type": "eq", "value": "目标节点 id"
        }, {
          // Note: 只有显式指定对父节点的过滤条件
          // 才能替换默认的过滤条件：parentId is null
          "name": "parentId", "$type": "eq", "value": "任何一个无效值"
        }]
      }
    }
  }
}
```

> 该方式仅适用于不是以 [`levelProp`](#attr_tree_levelProp) +
> [`rootLevelValue`](#attr_tree_rootLevelValue) 组合过滤根节点的情况。

需要注意的是，以上查询函数得到的结果都是平面结构的，而不是树形结构。

若是需要直接得到树形结构的数据，则可以尝试采用 NopGraphQL 内置的 GraphQL 指令
`@TreeChildren`，以递归获取各个层级的子节点数据：

<!-- prettier-ignore -->
```graphql {5}
query ($query: QueryBeanInput) {
  DepartmentEntity_findList(query: $query) {
    value: oid
    label: displayName
    children @TreeChildren(max: 5)
  }
}
```

> 详细说明见[《GraphQL 指令：@TreeChildren》](../implement/component/graphql#graphql-directive-tree-children)。

该方式会比树形数据查询函数更加灵活，
只不过该方式在查询深度较大且子节点数量较多时会存在比较明显的性能问题，
需要权衡利弊后再选择合适的方案。

> 虽然可以采用批量加载机制降低性能影响，但依然需要逐个层级依次加载，而不像执行
> Recursive EQL 那样可以直接获得各个层级的子节点数据。

### GraphQL 选择字段集 {#def_attr_selections_selection}

在做 GraphQL 服务调用时，需要为 GraphQL 对象类型的字段指定
[GraphQL SelectionSet](https://spec.graphql.org/October2021/#SelectionSet)，
也即**选择字段集**，
用于对父字段的取值结果做[字段选择](../implement/component/graphql#about-graphql)。

而针对业务对象的选择字段集可能出现在多个调用位置，并且存在多个相同的字段，
在此种情况下，便可以将这些相同字段组合起来并命名，再通过其名字进行引用，
从而实现对其的复用目的。

例如，定义一个 `id` 为 `F_moreFields` 的选择字段集：

```xml {5-6}
<meta>
  <!-- ... -->

  <selections>
    <selection id="F_moreFields">
      oid, name, relatedRoleList{ oid, name }
    </selection>
  </selections>

  <!-- ... -->
</meta>
```

注意，`<selections />` 本身没有配置属性，以下仅对其子节点 `<selection />`
的结构进行说明：

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_selections_selection_id"> id </TCol>
<TCol> string </TCol><TCol> 选择字段集的标识 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置选择字段集的唯一标识，在 GraphQL Document 中以该标识引用其字段集合，
可以视为选择字段集的引用名字

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 选择字段集的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置选择字段集的显示名称

</TDesc></TRow>

</Table>

`<selection />` 标签的 body 内容为
[GraphQL SelectionSet](https://spec.graphql.org/October2021/#SelectionSet)
结构，只是第一层字段不加花括号 `{`、`}`：

```xml
<meta>
  <selections>
    <selection id="F_defaults">
      oid, name, status
    </selection>

    <selection id="F_moreFields">
      oid, name, status
      relatedRoleList {
        oid, name
        permissionList {
          oid, name
        }
      }
    </selection>

    <selection id="copyForNew">
      status, description
    </selection>
  </selections>
</meta>
```

对于选择字段集的标识 `id` 有如下使用约定：

- `id` 为 `copyForNew`: 特定用于 GraphQL 变更函数 `CrudBizModel#copyForNew` 中，
  以指定在对 ORM 实体对象做复制新增时，默认可被复制的属性。
  **注**：为了安全性，可复制的内容是不允许由前端指定的
  - 若是未定义该标识的选择字段集，则 `CrudBizModel#copyForNew` 将复制源对象的全部属性
- `id` 以 `F_` 为前缀：表示在 GraphQL Document 中可以被引用的选择字段集。其中，`F_defaults`
  表示默认的选择字段集，若未定义该 `id` 的选择字段集，则将以 XMeta 中所有非 lazy
  的[属性](#def_attr_props_prop)作为选择字段；
- `id` 为其余形式：此类选择字段集的用途可根据业务需求自行确定。比如，先通过
  `getObjMeta().getFieldSelection("my_selection")` 获得 `id` 为
  `my_selection` 的选择字段集合，再调用 `CrudBizModel#doSave`
  仅保存这些字段对应的属性数据；

下面列举一些选择字段集的使用样例：

- 引用 `F_defaults` 选择字段集：

<!-- prettier-ignore -->
```graphql
// 等价于 REST 调用：/r/Book__get?id=123
// 或 /r/Book__get?id=123&@selection=...F_defaults
query {
  Book__get(id: 123) {
    ...F_defaults
  }
}

// 等价于 REST 调用：/r/NopAuthUser__findList?@selection=...F_defaults,groupMappings
// 或 /r/NopAuthUser__findList?@selection=...F_defaults,groupMappings{...F_defaults}
query ($query: QueryBeanInput) {
  NopAuthUser__findList(query: $query) {
    ...F_defaults
    groupMappings { ...F_defaults }
  }
}
```

> 仅 REST 调用可以省略 `...F_defaults`，在 GraphQL Document 中不可省略。

- 引用其他 `F_` 前缀的选择字段集：

<!-- prettier-ignore -->
```graphql
// 等价于 REST 调用：/r/NopAuthUser__findList?@selection=...F_moreFields
query ($query: QueryBeanInput) {
  NopAuthUser__findList(query: $query) {
    ...F_moreFields
  }
}
```

> REST 调用中也不可省略选择字段集的标识，必须明确指定，否则将按照
> `...F_defaults` 做字段选择。

### 属性列表 {#def_attr_props_prop}

:::tip

目前仅关注与后端处理相关的 `<prop />` 配置项，对于仅在 XView 层面使用的配置项（如
`ui:maxUploadSize` 等）暂时未做整理。

:::

在 XMeta 中，业务对象的属性由 `<prop />` 节点定义，如下所示：

```xml {5-13}
<meta>
  <!-- ... -->

  <props>
    <prop name="oid" ...>
      <schema type="java.lang.String"/>
    </prop>

    <prop name="name" ...>
      <schema type="java.lang.String"/>
    </prop>

    <!-- ... -->
  </props>
</meta>
```

> `<prop />` 的结构定义在 <NopVfsLink module="nop-xdefs" path="/nop/schema/schema/obj-schema.xdef" />
> 中。

通过 `<prop />` 节点可以完整描述业务对象属性的基本信息，并且可附加与 GraphQL、ORM
等相关的配置信息。下面将对该节点的各个配置项进行详细说明：

<Table head={['配置项', '配置项类型', '配置项名称', '是否必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_name"> name </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

用于设置业务对象属性的名字，如 `DepartmentEntity` 的属性 `parent` 将被定义为：

```xml
    <prop name="parent" .../>
```

通过属性名可以直接与 ORM
实体对象中的[列属性](./xorm#def_attr_entities_entity_columns_column)、[关联属性](./xorm#def_attr_entities_entity_relations)、[别名属性](./xorm#def_attr_entities_entity_aliases_alias)、[组件属性](#./xorm#def_attr_entities_entity_components_component)等属性做同名映射，
也同样可以与 GraphQL 中的[字段](../implement/component/graphql#about-graphql)做同名映射。
也即，通过属性的名字便可获得其在 ORM 和 GraphQL 领域中的配置信息。

设置的属性名一般为 [prop-name](./dict/std-domain#opt_prop_name)
形式，并且只有该形式的属性名才能做同名映射。

属性名也可以是以 `.` 分隔的复合形式，如 `parent.name`，其主要用于显式声明是否可对关联对象
`parent` 的 `name` 属性做增改查或排序：

```xml {2}
    <prop name="parent" .../>
    <prop name="parent.name"
          insertable="true" updatable="false"
          queryable="true" sortable="true"
    >
      ...
    </prop>
```

为了安全性，NopGraphQL 默认是不允许对关联对象的属性直接做增改查等操作的。
只能为关联对象的相关属性定义相应的复合属性，如 `parent.name`，再在该复合属性上为其设置
[`queryable`](#attr_props_prop_queryable)、[`updatable`](#attr_props_prop_updatable)
等配置项，才能执行可被许可的操作。

反言之，若是没有对关联对象的属性做增改查的需求，则不需要定义复合形式的属性。

**注意**：复合属性不能作为 GraphQL 的字段。相关处理逻辑见
`ObjMetaToGraphQLDefinition#toObjectDefinition`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_schema"> &lt;schema /> </TCol>
<TCol> ISchema </TCol><TCol> 属性的类型模式 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置业务对象属性的数据类型、数据精度等信息，例如：

```xml {2}
    <prop name="name" ...>
      <schema type="java.lang.String"/>
    </prop>
```

通过该配置项，可以自动进行与属性相关的数据转换和数据校验等方面的处理操作。
对其结构的详细说明见参考手册[《基础 DSL：Schema》](./dsl/schema#attrs)。

**注意**：若未设置该配置项，则默认将业务对象属性视为 `String` 类型。
相关处理逻辑见 `ObjMetaToGraphQLDefinition#toGraphQLType`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 属性的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置业务对象属性的显示名称，例如：

```xml
    <prop name="parent" displayName="父部门"/>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 属性的描述内容 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置对业务对象属性的描述内容，如：

```xml {2}
    <prop name="parent" ...>
      <description>父部门：当前部门的直接上级部门</description>
    </prop>
```

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_defaultValue"> defaultValue </TCol><TCol>

[any](./dict/std-domain#opt_any)

</TCol><TCol> 属性的缺省值 </TCol>
<TCol> 否 </TCol><TDesc>

**[ORM Only]** 用于设置业务对象属性的缺省值，如：

```xml
    <prop name="name" defaultValue="匿名" />
```

在调用 GraphQL 变更函数 `CrudBizModel#save` 对 ORM 实体对象做新增操作时，
若客户端没有为业务对象属性设置非空（不为 `null` 或空字符串）的值，并且该属性也未配置
[`<autoExpr />`](#attr_props_prop_autoExpr)，则会以该配置项的值作为属性的缺省值复制到待新增的
ORM 实体对象上。

> 相关处理逻辑见 `AutoExprRunner#runAutoExpr`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_propId"> propId </TCol>
<TCol> int </TCol><TCol> 属性的唯一编号 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置属性的唯一编号，例如：

```xml
    <prop name="name" propId="2" />
```

在与 gRPC 集成时，该编号对应于 Protocol Buffers
中的[字段编号](https://protobuf.dev/reference/protobuf/proto3-spec/#fields)。
其映射逻辑见 `ServiceSchemaManager#buildObjSchema`。

> 可通过应用配置项 `nop.grpc.auto-init-prop-id`
> 设置是否启用自动初始化属性编号，从而对未设置编号的属性添加递增的编号。缺省为 `true`。

当业务对象属性与 ORM
实体的[列](./xorm#def_attr_entities_entity_columns_column)相映射时，
该属性编号与列的 [`propId`](./xorm#attr_entities_entity_columns_column_propId)
配置是一致的。NopORM 将会根据该编号对 ORM 实体对象的属性进行索引，用于属性赋值和取值等。

> 对 ORM 实体对象属性赋值的逻辑见
> `DynamicOrmEntity#orm_propValue(int, java.lang.Object)`。

属性编号的值必须大于 `0`，并且与 ORM 实体列相映射时，该值不能超过
`OrmModelConstants#MAX_PROP_ID`（固定为 `2000`），而与
gRPC 字段映射时，则没有为其值设定上限。

**注意**：在与 NopORM、gRPC 的列或字段映射以外的场景中，不需要设置该配置项。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mapToProp"> mapToProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 属性所映射的 ORM 实体对象属性名 </TCol>
<TCol> 否 </TCol><TDesc>

**[ORM Only]** 用于为 ORM 实体对象的属性定义一个别名，例如：

```xml
    <prop name="parentName" mapToProp="parent.name" />
```

其表示为 ORM 实体对象的 `parent.name` 属性定义别名 `parentName`，
这样，在客户端便可使用 `parentName` 指代 `parent.name`。

比如，通过别名 `parentName` 做过滤查询：

<!-- prettier-ignore -->
```json {4}
{
  "query": "query ($query: QueryBeanInput) { ... }",
  "variables": { "query": { "filter": {
    "name": "parentName", "$type": "eq", "value": "人力资源部"
  } } }
}
```

> 在过滤条件 `filter` 中的别名 `parentName` 会被函数
> `BizQueryHelper#transformMapToProp` 替换为其所指代的
> ORM 实体对象的属性 `parent.name`。

还可以通过别名 `parentName` 对 ORM 实体对象的属性做新增和修改，
并通过别名做 GraphQL 字段选择，例如：

<!-- prettier-ignore -->
```graphql {3} title="定义 GraphQL 变更文档"
mutation ($data: Map) {
  DepartmentEntity_save(data: $data) {
    parentName
  }
}
```

<!-- prettier-ignore -->
```json {5} title="通过别名设置待变更属性的值"
{
  "query": "mutation ($data: Map) { ... }",
  "variables": {
    "data": {
      "parentName": "信息技术部"
    }
  }
}
```

最终，为别名 `parentName` 设置的值将先被复制到 ORM 实体对象的
`parent.name` 属性上，再保存关联对象 `parent`。完成后，又可以通过
GraphQL 字段 `parentName` 得到保存后的 `parent.name` 的值。

> 在新增或修改 ORM 实体对象时，将调用 `OrmEntityCopier#copyField`
> 将别名的值复制到 `parent.name` 上。而在做 GraphQL
> 字段选择时，则会通过该别名字段的取值函数 `OrmDependsPropFetcher`
> 获取 `parent.name` 的值。注：别名字段的取值函数是在
> `OrmFetcherBuilder#initFetchers` 中被绑定的。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_depends"> depends </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> 属性所依赖的 ORM 实体对象属性 </TCol>
<TCol> 否 </TCol><TDesc>

**[ORM Only]** 用于设置在对业务对象属性做 GraphQL 字段取值时，需要先获取 ORM
实体对象中的哪些[关联属性](./xorm#def_attr_entities_entity_relations)的值。
也就是，配置<u>对该属性的取值</u>所要依赖的属性，例如：

```xml {1,7,15-16}
    <!-- <prop name="userMappings" ...>
      <schema>
        <item bizObjName="NopAuthUserRole"/>
      </schema>
    </prop> -->
    <prop name="relatedUserList"
          depends="~userMappings" ...>
      <schema>
        <item bizObjName="NopAuthUser"/>
      </schema>
      <getter><![CDATA[
        import io.nop.orm.support.OrmEntityHelper;

        return OrmEntityHelper.getRefProps(
          entity.getUserMappings(),
          'user'
        );
      ]]></getter>
    </prop>
```

可以看到，属性 `relatedUserList` 依赖于 ORM 实体对象的属性
`userMappings`，因为，其对应的 GraphQL 字段取值函数为自定义的
[`<getter />`](#attr_props_prop_getter) 函数，该函数需要通过
ORM 实体对象 `entity` 的 `userMappings` 属性的值才能得到该字段的值。

> 设置了 `depends` 的字段将绑定取值函数 `OrmDependsPropFetcher`。该绑定逻辑在
> `OrmFetcherBuilder#initFetchers` 中实现。

该配置项的值是以 `,` 分隔的依赖属性名字符串，其中，依赖属性名采用
[prop-path](./dict/std-domain#opt_prop_path)
形式，也就是，即可以为单一属性名，也可以为复合属性名。

所配置的依赖属性必须为 ORM 实体对象中的[关联属性](./xorm#def_attr_entities_entity_relations)，
但其可以在当前的 XMeta 中有相应的映射属性，也可以没有。若未定义相应的
XMeta 属性，则需为该属性名添加前缀 `~`，如
`~userMappings`，用以表示其为内部属性（非强制性要求，有无前缀并不影响取值）。

> 对属性前缀的处理逻辑见 `ObjPropMetaImpl#getDependOnProps`。

**注意**：若在 `<getter />` 中引用的不是 ORM 实体对象的关联属性，或者引用的属性并未与
ORM 实体对象的属性相映射，则无需将其配置为依赖属性，直接通过 `entity` 引用即可。
因为，只有 ORM 实体对象的关联属性不是即时加载的，需要声明对其的依赖以便于提前批量加载其数据。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mandatory"> mandatory </TCol>
<TCol> boolean </TCol><TCol> 是否为必填属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则业务对象属性的值不能为空值（`null` 或空字符串）。缺省为 `false`。

在对 ORM 实体对象做新增或修改时，必须为必填属性设置非空值，
否则，将抛出属性值为空的异常 `nop.err.biz.mandatory-prop-is-empty`。

> 相关处理逻辑见 `ObjMetaBasedValidator#_validate`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_internal"> internal </TCol>
<TCol> boolean </TCol><TCol> 是否为内部属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则表示业务对象属性为内部属性。缺省为 `false`。

在 Nop XView 中默认不会在生成的页面中为内部属性创建相应的组件。
但标记内部属性，并不影响其作为 GraphQL 的选择字段，也不影响对其所映射的
ORM 实体对象属性做新增或修改操作。

> 仅 [`published`](#attr_props_prop_published)
> 才会影响业务对象属性是否可作为 GraphQL 的选择字段。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_deprecated"> deprecated </TCol>
<TCol> boolean </TCol><TCol> 是否为已废弃属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则表示业务对象属性已被废弃，已废弃的属性将不再被使用。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_insertable"> insertable </TCol>
<TCol> boolean </TCol><TCol> 是否为可新增属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则表示在新增业务对象时，可以插入业务对象属性的值，
否则，其值将被忽略。缺省为 `false`。

> 相关处理逻辑见 `ObjMetaBasedValidator#validateForSave`。

**注意**：在调用变更函数 `CrudBizModel#copyForNew` 时，ORM 实体对象的可新增字段由
`id` 为 `copyForNew` 的 [&lt;selection />](#def_attr_selections_selection)
指定，不受 `insertable` 的配置约束。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_updatable"> updatable </TCol>
<TCol> boolean </TCol><TCol> 是否为可更新属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则表示在更新业务对象时，可以更新业务对象属性的值，
否则，其值将被忽略。缺省为 `false`。

> 相关处理逻辑见 `ObjMetaBasedValidator#validateForUpdate`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_virtual"> virtual </TCol>
<TCol> boolean </TCol><TCol> 是否为虚拟属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置其值为 `true`，则在新增、修改 ORM 实体对象时，业务对象属性的值不会被复制到
ORM 实体对象上，其对于 ORM 实体对象而言是不可见的。缺省为 `false`。

> 相关处理逻辑见 `OrmEntityCopier#copyField`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_published"> published </TCol>
<TCol> boolean </TCol><TCol> 是否为开放属性 </TCol>
<TCol> 是 </TCol><TDesc>

若设置为 `false`，则业务对象属性不能作为 GraphQL 选择字段出现在
GraphQL Document 中，否则将报字段未定义的异常
`nop.err.graphql.undefined-field`。缺省为 `true`。

> 相关处理逻辑见 `ObjMetaToGraphQLDefinition#toObjectDefinition`。

对于密码等敏感数据，需设置该配置项为 `false`，或者通过
[`ui:maskPattern`](#attr_props_prop_ui_maskPattern) 对其做脱敏处理。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_exportable"> exportable </TCol>
<TCol> boolean </TCol><TCol> 是否为可导出属性 </TCol>
<TCol> 是 </TCol><TDesc>

只有将其设置为 `true` 且 [`published`](#attr_props_prop_published)
也为 `true`，才可以导出当前属性的值。缺省为 `true`。

> 相关处理逻辑见 `BizExportHelper#isAllowExport`。

**注意**：该配置项目前还未真正使用。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_sortable"> sortable </TCol>
<TCol> boolean </TCol><TCol> 是否为可排序属性 </TCol>
<TCol> 是 </TCol><TDesc>

只有将其设置为 `true`，才能够在 GraphQL 服务调用时，在 `$query`
变量中指定根据业务对象属性做数据排序，否则，将抛出属性不可排序的异常
`nop.err.biz.prop-not-sortable`，例如：

```xml title="声明属性可排序"
    <prop name="status" sortable="true" />
```

<!-- prettier-ignore -->
```json {5} title="指定属性的排序方向"
{
  "query": "query ($query: QueryBeanInput) { ... }",
  "variables": { "query": {
    "orderBy": [{
      "name": "status", "desc" : false
    }, { ... }, ...]
  } }
}
```

其缺省值为 `false`。

> 相关处理逻辑见 `CrudBizModel#prepareFindPageQuery`
> -> `CrudBizModel#checkAllowQuery`
> -> `BizObjMetaHelper#checkPropSortable`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_queryable"> queryable </TCol>
<TCol> boolean </TCol><TCol> 是否为可查询属性 </TCol>
<TCol> 是 </TCol><TDesc>

只有将其设置为 `true`，才能够在 GraphQL 服务调用时，在 `$query`
变量中使用业务对象属性构造过滤条件，否则，将抛出属性不可被用于查询条件的异常
`nop.err.biz.prop-not-support-query`，例如：

```xml title="声明属性可查询"
    <prop name="status" queryable="true" />
```

<!-- prettier-ignore -->
```json {4} title="构造过滤条件"
{
  "query": "query ($query: QueryBeanInput) { ... }",
  "variables": { "query": { "filter": {
    "name": "status", "$type": "eq", "value": "2"
  } } }
}
```

其缺省值为 `false`。

> 相关处理逻辑见 `ObjMetaBasedFilterValidator#validateVarFilter`。

该配置将与 [`allowFilterOp`](#attr_props_prop_allowFilterOp) 配合使用。

**注意**：对于作为[过滤器转换](#def_attr_props_prop_graphql_transFilter)的业务对象属性，
则需要强制设置该配置项为 `true`。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_allowFilterOp"> allowFilterOp </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> 可在属性上应用的过滤运算符 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置可在业务对象属性上应用的过滤运算符，例如：

```xml {2,3} title="声明许可的过滤运算符"
    <prop name="status"
          queryable="true"
          allowFilterOp="eq,gt,lt"
    />
```

<!-- prettier-ignore -->
```json {5} title="应用许可范围内的过滤运算符"
{
  "query": "query ($query: QueryBeanInput) { ... }",
  "variables": { "query": { "filter": {
    "name": "status",
    "$type": "gt",
    "value": "2"
  } } }
}
```

该配置项的值是以 `,` 分隔的运算符字符串，且运算符只能为 `FilterBeanConstants` 中以
`FILTER_OP_` 开头的常量的值。若是对业务对象属性应用许可之外的运算符，则将抛出运算符不被支持的异常
`nop.err.biz.prop-not-support-filter-op`。

缺省只支持 `ObjMetaBasedFilterValidator#DEFAULT_ALLOW_FILTER_OP`
列表中的运算符，即，该配置项的缺省值为 `eq,in,dateBetween,dateTimeBetween`。

> 相关处理逻辑见 `ObjMetaBasedFilterValidator#validateVarFilter`。

**注意**：只有 [`queryable`](#attr_props_prop_queryable) 为 `true`
时，该配置项才有意义。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_lazy"> lazy </TCol>
<TCol> boolean </TCol><TCol> 是否为懒加载属性 </TCol>
<TCol> 是 </TCol><TDesc>

用于标记业务对象属性是否为懒加载的。缺省为 `false`。

若业务对象属性映射的是 ORM 实体对象的[关联属性](./xorm#def_attr_entities_entity_relations)，
则该配置项应始终为 `true`。

> 详细的配置逻辑可参考 CodeGen 模板 <NopVfsLink module="nop-codegen" path="/nop/templates/meta/src/main/resources/_vfs/{moduleId}/model/{!entityModel.notGenCode}{entityModel.shortName}/{deltaDir}/_{entityModel.shortName}.xmeta.xgen" />。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_tagSet"> tagSet </TCol><TCol>

[tag-set](./dict/std-domain#opt_tag_set)

</TCol><TCol> 特性标记列表 </TCol>
<TCol> 否 </TCol><TDesc>

**[ORM Only]** 该配置项的值与业务对象属性所映射的 ORM
实体对象的[列属性](./xorm#def_attr_entities_entity_columns_column)、[关联属性](./xorm#def_attr_entities_entity_relations)、[别名属性](./xorm#def_attr_entities_entity_aliases_alias)、[组件属性](#./xorm#def_attr_entities_entity_components_component)上的
`tagSet` 一致

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_type"> graphql:type </TCol>
<TCol> string </TCol><TCol> 属性的 GraphQL 类型 </TCol>
<TCol> 否 </TCol><TDesc>

用于显式设置业务对象属性的
[GraphQL 类型](https://graphql.org/learn/schema/)，NopGraphQL
将按此设置对业务对象属性所对应的 GraphQL 字段做类型转换，例如：

```xml {3}
    <prop name="args"
          mapToProp="funcMetaComponent.args"
          graphql:type="[Map]"
    />
    <prop name="funcMetaComponent"
          tagSet="json" ext:kind="component"
    >
      <schema type="io.nop.orm.component.JsonOrmComponent"/>
    </prop>
```

其中，`funcMetaComponent` 为 [ORM JSON 组件](#orm_component_json)，
这里以[别名属性](#attr_props_prop_mapToProp) `args`
映射该组件内部的数据 `funcMetaComponent.args`，这里假设其为 JSON 对象数组形式，
但 NopGraphQL 无法自动推导 JSON 组件内部数据的类型，因此，需要显式设置
`graphql:type` 为 `[Map]`，从而确保返回给客户端的 `args` 的字段值**保持**为
JSON 对象形式，而不是将其转换为字符串。

> 对 GraphQL 字段的取值结果做类型转换的逻辑见 `GraphQLExecutor#normalizeValue`。

该配置项的可选值为枚举类 `GraphQLScalarType` 中的各个枚举项的名字（大小写敏感），如
`String`、`Map` 等。若 GraphQL 字段为列表类型，则需要将可选值包裹在 `[ ]`
内，如 `[String]`（字符串列表）、`[Map]`（Map 列表）。注意，
对于[对象类型](https://graphql.org/learn/schema/#object-types-and-fields)以外（不包括元素为对象类型的列表）的字段，
不能再对其做字段选择，否则将抛出异常 `nop.err.graphql.not-obj-type`。

> 对于 `GraphQLScalarType` 的枚举项对应的 GraphQL 类型以外（包括列表类型）的字段将使用
> `IdentityTypeConverter` 作为类型转换器，其直接返回数据本身，
> 所以，需确保字段取值结果与设定的类型是相同的。相关处理逻辑见
> `GraphQLFieldDefinition#getTypeConverter`。

默认通过 [`<schema />](#attr_props_prop_schema) 来确定业务对象属性所对应的
GraphQL 字段的 GraphQL 类型，但对于 ORM JSON 组件的内部数据或其他未配置
`<schema />` 的情况，则一般通过 `graphql:type` 指定其 GraphQL 类型。`graphql:type`
的优先级高于 `<schema />`，在二者均未配置的情况下，缺省将业务对象属性视为 `String` 类型。

> 通过 `graphql:type` 确定字段的 GraphQL 类型的逻辑见
> `ObjMetaToGraphQLDefinition#toGraphQLType`
> -> `GraphQLObjMetaHelper#getPropGraphQLType`
> -> `GraphQLDocumentParser#parseType`
> -> `GraphQLNamedType#setName` -> `GraphQLScalarType#fromText`。

此外，对于映射到类型为 `Long` 的[主键](#attr_primaryKey)属性，一般要求其对应的
GraphQL 字段返回 `String` 类型，因为 JS 无法处理超过一定大小数值的 `Long`
型数据，这时，便需要设置 `graphql:type="String"`，从而忽略 `<schema />` 设定的类型。

但在做 GraphQL 变更时，
客户端提供的输入数据则需由相应的[业务操作函数](../implement/component/graphql#biz-model)进行转换处理，
如 `CrudBizModel#doSave`，NopGraphQL 不会主动根据业务对象属性的类型对输入数据做类型转换。

> 对 ORM 实体对象属性的输入数据的转换逻辑见
> `DynamicOrmEntity#orm_propValue(int, java.lang.Object)`。

**注意**：对于类型的转换，不是从任意类到任意类型均可支持的，
需要由转换的目标类型确定可被转换的源类型。对于 Nop 内置的标准类型可通过
`StdDataType#getConverter` 得到在 `SysConverterRegistry`
中注册的类型转换器，查看其对应的转换器便可确认可被转换的源类型。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_mapper"> graphql:mapper </TCol>
<TCol> string </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未使用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_labelProp"> graphql:labelProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 作为属性的显示文本的属性 </TCol>
<TCol> 否 </TCol><TDesc>

**[View Only]** 当业务对象属性是对象类型（含对象列表）或数据字典时，
一般需要声明使用业务对象中的哪个[属性](#def_attr_props_prop)的值作为其显示文本，例如：

```xml {2,6}
    <prop name="relatedRoleList_ids"
          graphql:labelProp="relatedRoleList_label"
    >
      <!-- ... -->
    </prop>
    <prop name="relatedRoleList_label">
      <schema type="String"/>
      <!-- ... -->
    </prop>
```

其优先级高于 [`ext:joinRightDisplayProp`](#attr_props_prop_ext_joinRightDisplayProp)。

详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)。

**注意**：该配置项不是强制性的，其主要在 Nop XView
中用于指定从哪个属性中获取业务对象属性的显示文本信息。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictName"> graphql:dictName </TCol>
<TCol> string </TCol><TCol> 属性所对应的数据字典 </TCol>
<TCol> 否 </TCol><TDesc>

当业务对象属性的值对应的是数据字典的显示文本时，
需通过该配置项指定从哪个数据字典中获取该属性的值，例如：

```xml {2-3}
    <prop name="status_label"
          graphql:dictName="auth/user-status"
          graphql:dictValueProp="status"
    >
      <schema type="String"/>
    </prop>
    <prop name="status">
      <schema type="Integer" dict="auth/user-status"/>
    </prop>
```

该配置项必须与 [`graphql:dictValueProp`](#attr_props_prop_graphql_dictValueProp)
配合使用才有效。后者用于指定字典值应该从业务对象中的哪个属性获取。

也就是，`status_label` 对应的字典显示文本，需要以 `status`
作为字典值，再从数据字典 `auth/user-status` 中获取该字典值对应的显示文本而得到。

> 该属性的 GraphQL 字段取值函数的构造逻辑见 `DictLabelFetcherProvider#provideFetcher`。

详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictValueProp"> graphql:dictValueProp </TCol><TCol>

[prop-path](./dict/std-domain#opt_prop_path)

</TCol><TCol> 作为数据字典值的属性 </TCol>
<TCol> 否 </TCol><TDesc>

该配置项必须与 [`graphql:dictName`](#attr_props_prop_graphql_dictName) 配合使用才有效

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinLeftProps"> graphql:joinLeftProps </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未使用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinRightProps"> graphql:joinRightProps </TCol><TCol>

[word-set](./dict/std-domain#opt_word_set)

</TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未使用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_datePattern"> graphql:datePattern </TCol>
<TCol> string </TCol><TCol> 日期转换格式 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置对业务对象属性对应的 GraphQL 字段的取值结果做日期格式化，例如：

```xml
    <prop name="createTime" graphql:datePattern="ms"/>
```

若要支持对日期的格式化，需满足前提条件：应用配置项 `nop.graphql.ignore-millis-in-timestamp`
为 `true`（缺省值即为 `true`），并且业务对象属性的[类型](./dsl/schema#attr_type)为
`java.sql.Timestamp`。在此条件下，若设置了该配置项，则按其指定的形式对
GraphQL 字段值做日期格式化，否则，缺省按 `yyyy-MM-dd HH:mm:ss` 进行格式化。

> 相应的 GraphQL 类型转换器的构造逻辑见 `GraphQLFieldDefinition#getTypeConverter`。

该配置项支持的格式化形式如下：

- `ms`: 得到日期的毫秒值字符串；
- `SimpleDateFormat` 支持的形式：如 `yyyy-MM-dd HH:mm:ss` 等；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_transFilter"> &lt;graphql:transFilter /> </TCol><TCol>

[xpl-fn](./dict/std-domain#opt_xpl_fn): `(filter, query, forEntity) => any`

</TCol><TCol> 属性的过滤条件转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

若设置了该配置项，则在业务对象属性上构造的查询过滤条件，
将在做过滤查询前，被替换为该转换函数所构造的新的过滤条件，例如：

```xml
    <prop name="hasResourceStatus" queryable="true">
      <graphql:transFilter>
        <filter:sql>
          exists (
            select o2 from NopAuthResource o2
            where o2.siteId= o.id
              and o2.status >= ${ filter.getAttr('value') }
          )
        </filter:sql>
      </graphql:transFilter>
    </prop>
```

> 对过滤条件的转换逻辑见 `BizQueryHelper#transformFilter`。

其可以将复杂的过滤条件以属性的形式进行引用，从而简化对过滤条件的构造逻辑。

但是，此类属性只能用于构造过滤条件，而不能被用于 GraphQL 字段选择。
并且，对其的使用也必须符合 [`queryable`](#attr_props_prop_queryable)
和 [`allowFilterOp`](#attr_props_prop_allowFilterOp) 的配置要求。

详细说明见 [XMeta 过滤条件转换](#def_attr_props_prop_graphql_transFilter)。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ui_maskPattern"> ui:maskPattern </TCol>
<TCol> string </TCol><TCol> 属性的掩码模式 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置对业务对象属性对应的 GraphQL 字段的取值结果做掩码处理，从而实现对敏感数据的脱敏，例如：

```xml
    <prop name="mobile" ui:maskPattern="4*"/>
```

该配置项指定的掩码由函数 `StringHelper#maskPattern` 解析，其必须为
`3*4`、`3*` 或 `*4` 形式，其中，数字代表字符串的开头或结尾所要保留的字符个数，
中间的字符则将被挨个替换为 `*`（替换前后的字符总数不变）。

> 只能针对字符串做掩码处理，对于非字符串类型，则将调用其
> `toString` 方法得到其字符串后，再做掩码。

对 `ui:maskPattern` 的处理发生在解析 XMeta 的 `x:post-extends` 阶段，
其将由 Xpl 函数 `meta-gen:GenMaskingExpr` 为业务对象属性自动构造配置项
[`<transformOut />`](#attr_props_prop_transformOut)，
并在该配置项中指定相应的掩码转换逻辑。

> `meta-gen:GenMaskingExpr`
> 函数定义在 <NopVfsLink module="nop-xlang" path="/nop/core/xlib/meta-gen.xlib" />
> 中。

**注意**：若是要设置自定义的输出函数 `<transformOut />`，则不能再设置该配置项。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_moduleId"> biz:moduleId </TCol>
<TCol> string </TCol><TCol> 属性对应的关联对象所属的模块 </TCol>
<TCol> 否 </TCol><TDesc>

用于设置业务对象属性所关联的业务对象所属的 Nop 模块标识，例如：

```xml
    <prop name="product" biz:moduleId="demo/product">
      <schema bizObjName="DemoProduct"/>
    </prop>
```

在属性所关联的业务对象来自于外部模块时，需设置该配置项以标记其所属的模块。

**注意**：目前还未发现其实际用途，仅将其当作业务对象所属模块的识别标记即可。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_codeRule"> biz:codeRule </TCol>
<TCol> string </TCol><TCol> 编码属性的生成规则 </TCol>
<TCol> 否 </TCol><TDesc>

在业务对象属性是形式统一且具备唯一性的某种编码时，可以通过该配置项指定其生成规则，
可用于自动生成订单号、卡号等，例如：

```xml {2}
    <prop name="orderNo"
          biz:codeRule="D{@year}{@month}{@seq:5}"
          insertable="false" updatable="false"
    />
```

该配置项指定的编码规则由接口 `ICodeRuleGenerator` 的实现进行解析并生成相应的编码值。

对 `biz:codeRule` 的处理发生在解析 XMeta 的 `x:post-extends` 阶段，
其将由 Xpl 函数 `meta-gen:GenCodeRuleAutoExpr` 为业务对象属性自动构造配置项
[`<autoExpr />`](#attr_props_prop_autoExpr)，并在该配置项中指定相应的编码生成逻辑。
默认仅在新增 ORM 实体对象时才自动生成编码，更新操作不会重新生成，但是该编码依然可被客户端修改，
因此，还需要为业务对象属性设定 `insertable="false"` 且 `updatable="false"`，
以**忽略**客户端对其的修改。

> `meta-gen:GenCodeRuleAutoExpr`
> 函数定义在 <NopVfsLink module="nop-xlang" path="/nop/core/xlib/meta-gen.xlib" />
> 中。

在引入了 Nop 模块 `nop-sys-dao` 后，将由该模块提供 `ICodeRuleGenerator` 的缺省实现
`SysCodeRuleGenerator`，该编码器通过数据库记录各类编码信息，并确保生成编码的唯一性。
其编码生成规则详见文档<NopDocLink title="《编码规则》" path="/dev-guide/biz/coderule.md" />。

**注意**：若已设置了配置项 `<autoExpr />`，则对 `biz:codeRule` 的设置将被忽略。

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_kind"> ext:kind </TCol>
<TCol> string </TCol><TCol> 类别 </TCol>
<TCol> 否 </TCol><TDesc>

可选值：

- `to-one`：业务对象与属性对应的对象为一对一关联；
- `to-many`：业务对象与属性对应的对象为一对多关联；
- `alias`：表示其为在 ORM 实体上定义的别名，通过该属性名，可以找到别名映射的源属性；
- `component`：表示其为 ORM 实体中的组件字段，比如，JSON 字段。
  注意，对于文件字段，会通过 `mapToProp` 映射到 ORM 实体对应组件字段的
  `fileStatus`/`fileStatusList` 属性上，不再设置 `ext:kind="component"`；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_relation"> ext:relation </TCol>
<TCol> string </TCol><TCol> 关联映射到的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinLeftProp"> ext:joinLeftProp </TCol>
<TCol> string </TCol><TCol> 关联的源端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightProp"> ext:joinRightProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightDisplayProp"> ext:joinRightDisplayProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的显示属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_orm_manyToManyRefProp"> orm:manyToManyRefProp </TCol>
<TCol> string </TCol><TCol> 多对多关联的中间模型中另一方的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于多对多关联，其指向在中间模型中用于映射对端模型的属性。
详细说明见 [XMeta 对象关联配置 - 多对多](#relations-many-to-many)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_queryMethod"> graphql:queryMethod </TCol>
<TCol> GraphQLQueryMethod </TCol><TCol> 关联过滤查询的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于指定关联过滤查询的返回结果类型。
详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_connectionProp"> graphql:connectionProp </TCol><TCol>

[prop-name](./dict/std-domain#opt_prop_name)

</TCol><TCol> 关联过滤查询所指向的业务对象的属性 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_authObjName"> graphql:authObjName </TCol>
<TCol> string </TCol><TCol> 关联过滤查询的数据权限模型名称 </TCol>
<TCol> 否 </TCol><TDesc>

指定在[关联过滤查询](#relations-connection)时所应用的数据权限模型。
默认为被过滤对象的 [BizModel](./xbiz) 名称。`IDataAuthChecker#getFilter`
将根据该数据权限模型生成额外的过滤条件，从而实现按行对数据进行访问控制

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_inputType"> &lt;graphql:inputType /> </TCol><TCol>

[class-name](./dict/std-domain#opt_class_name)

</TCol><TCol> GraphQL 输入参数类型的类全名 </TCol>
<TCol> 否 </TCol><TDesc>

以强类型方式定义
[GraphQL 输入参数](https://graphql.org/learn/queries/#arguments)，
以对输入参数自动进行数据校验和类型转换。

例如，`GraphQLConnectionInput` 就被定义为[关联过滤查询](#relations-connection)的默认输入参数类型。

该类型的定义需满足以下条件：

- 在类上标注 `@GraphQLInput`；
- 各参数均需提供 getter 方法，并在方法上标注 `@PropMeta`；
- 在注解 `@PropMeta` 上按顺序递增设置 `propId` 的值；

**注**：该设置还未真正被使用，当前在 BizModel 中使用的是 `Map` 弱类型形式

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg"> &lt;arg /> </TCol>
<TCol> ObjPropArgModel </TCol><TCol> GraphQL 输入参数定义列表 </TCol>
<TCol> 否 </TCol><TDesc>

与 [&lt;graphql:inputType />](#attr_props_prop_graphql_inputType)
的作用相同，只不过后者是以 Java Class 方式定义输入参数，并且，在配置了
`<graphql:inputType />` 的情况下，`<arg />` 将被忽略。
详细说明见 [XMeta GraphQL 输入参数列表](#def_attr_props_prop_arg)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_maxFetchSize"> graphql:maxFetchSize </TCol>
<TCol> int </TCol><TCol> 当前<b>关联查询属性</b>一次查询所能取的最大数据量 </TCol>
<TCol> 否 </TCol><TDesc>

缺省值为 `-1`。仅对**关联查询属性**有效，用于控制每次查询所能取得的最多数据，
前端指定的分页大小将被限制在该值及其以下。在其值小于或等于 `0` 时，则分页大小不能超过应用配置
`nop.graphql.max-page-size` 的设定值（缺省为 `1000`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_filter"> &lt;graphql:filter /> </TCol><TCol>

[filter-bean](./dict/std-domain#opt_filter_bean)

</TCol><TCol> 当前<b>关联查询属性</b>的默认过滤条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的过滤条件。其将与前端设置的过滤条件以 `and` 方式组合

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_orderBy"> &lt;graphql:orderBy>&lt;field />&lt;/graphql:orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> 当前<b>关联查询属性</b>的默认排序条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的排序条件。其将与前端设置的排序条件组合在一起。
详细说明见 [ORM 实体排序条件](#def_attr_orderBy_field)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformIn"> &lt;transformIn /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 输入数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

将接口调用回传的业务对象属性的值按该转换函数处理后，再赋值给业务对象。
比如，将提交的数据从逗号分隔的字符串转换为 `List<String>` 类型。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformOut"> &lt;transformOut /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 输出数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

NopGraphQL 将业务对象属性的值按该转换函数处理后，再返回给接口调用方。
比如，将 `List<String>` 类型数据转换为逗号分隔的字符串，或者将密码等敏感数据脱敏后再返回。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_getter"> &lt;getter /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 业务对象属性的 Getter 函数 </TCol>
<TCol> 否 </TCol><TDesc>

为业务对象属性定义 Getter 函数，其将覆盖对象实体上的 Getter 方法，
以便于添加动态处理逻辑。

其用于 NopGraphQL 向客户端返回数据之前的准备阶段。

其可以与 [&lt;transformOut />](#attr_props_prop_transformOut)
同时设定，且该 Getter 函数先执行，而其执行结果将作为参数 `value`
传给 `<transformOut />` 函数。该 Getter 函数的可用参数如下（详细执行逻辑见
`PropGetterFetcher`）：

- `entity`: 其为业务对象自身；
- 其他：在 [GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
  上的输入参数；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_setter"> &lt;setter /> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 业务对象属性的 Setter 函数 </TCol>
<TCol> 否 </TCol><TDesc>

为业务对象属性定义 Setter 函数，其将覆盖对象实体上的 Setter 方法，
以便于添加动态处理逻辑。

其用于 NopGraphQL 根据客户端提交数据构造业务对象的过程中。

其可以与 [&lt;transformIn />](#attr_props_prop_transformIn)
同时设定，`<transformIn />` 函数的执行结果将作为参数 `value`
传给该 Setter 函数。该 Setter 函数的可用参数如下（详细执行逻辑见
`OrmEntityCopier#copyField`）：

- `entity`: 其为业务对象自身；
- `value`: 其为业务对象属性的值。可能为 `null`；
- `propMeta`: `IObjPropMeta` 类型，其为业务对象属性的[结构](#def_attr_props_prop)；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr"> &lt;autoExpr /> </TCol>
<TCol> ObjConditionExpr </TCol><TCol> 自动计算属性缺省值 </TCol>
<TCol> 否 </TCol><TDesc>

用于新增或者修改的时候自动计算业务对象属性的缺省值，
比如，根据子表中的商品价格自动计算汇总价格等。
详细说明见 [XMeta 属性自动计算](#def_attr_props_prop_autoExpr)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth"> &lt;auth /> </TCol>
<TCol> ObjPropAuthModel </TCol><TCol> 字段级别的访问控制 </TCol>
<TCol> 否 </TCol><TDesc>

用于配置对业务对象属性的读写权限，从而实现对业务对象属性的访问权限控制。
详细说明见 [XMeta 属性访问控制](#def_attr_props_prop_auth)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_selection"> &lt;graphql:selection /> </TCol><TCol>

[field-selection](./dict/std-domain#opt_field_selection)

</TCol><TCol> 默认的 GraphQL 选择字段集 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
若业务对象属性映射的是一个对象，则可以配置该属性，用于指定默认的
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addDispSelection`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_jsonComponentProp"> graphql:jsonComponentProp </TCol>
<TCol> string </TCol><TCol> 业务对象属性对应的 JSON 组件属性名 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
在业务对象属性为 JSON 文本时会自动构造一个 [&lt;schema />](#attr_props_prop_schema) 为
`JsonOrmComponent` 的对象属性，并赋值 `graphql:jsonComponentProp` 以指向该属性，从而建立起二者的关联。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addJsonComponent`

</TDesc></TRow>

</Table>

## XMeta 属性显示文本 {#def_attr_props_prop_graphql_labelProp}

在业务对象的属性对应的是数据字典，或者为[关联对象](#relations)的 ID 列表时，
可以在业务对象中定义一个作为其**显示文本**的属性，以便于在前端显示，再通过
`graphql:labelProp` 指向该显示文本属性，以建立二者之间的引用关系，比如：

```xml {4,10,11} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="status"
          graphql:labelProp="status_label"
    >
      <schema type="Integer" dict="auth/user-status"/>
    </prop>

    <prop name="status_label"
          graphql:dictValueProp="status"
          graphql:dictName="auth/user-status"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

在本例中，`status` 赋值的是数据字典 `auth/user-status` 的 `value`
值，其类型是 `Integer`，若在前端直接显示该属性值，则不方便用户进行识别，
因此，可以为 `status` 构建一个相应的<u>用于显示其对应数据字典的 `label`
文本</u>的属性 `status_label`。

NopGraphQL 引擎将会根据 `graphql:dictValueProp`
所指定的业务对象属性（即本例中的 `status`）的实际值，从 `graphql:dictName`
对应的数据字典（`auth/user-status`）中获取到字典枚举值的显示文本，
并将该文本内容作为 `status_label` 的值返回给前端。

前端仅需要在 GraphQL Field Selection 中包含 `status_label`
即可得到 `status` 对应的显示文本内容，从而避免前端单独处理对数据字典的文本回显：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    status
    status_label
  }
}
```

而对于[一对多/多对多](#relations-many-to-many)的对象关联场景中：

```xml {14} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="relatedRoleList"
          ext:kind="to-many"
          lazy="true"
    >
      <schema>
        <item bizObjName="NopAuthRole"/>
      </schema>
    </prop>

    <prop name="relatedRoleIdList"
          ext:relation="relatedRoleList"
          graphql:labelProp="relatedRoleList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.String&gt;"/>
    </prop>

    <prop name="relatedRoleList_label"
          lazy="true"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

可为关联目标端的主键（`id`）列表 `relatedRoleIdList` 构造一个对应的显示文本列表
`relatedRoleList_label`，而在 [Nop Orm](./xorm) 层中将会在实体对象的
Java 代码中为属性 `relatedRoleList_label` 自动生成如下 getter 代码：

```java
  public String getRelatedRoleList_label() {
    return io.nop.core.lang.utils.Underscore.pluckThenJoin(
      getRelatedRoleList(),
      io.nop.auth.dao.entity.NopAuthRole.PROP_NAME_roleName
    );
  }
```

也就是，从关联目标端列表 `relatedRoleList` 中依次取其[显示属性](#attr_displayProp)（本例中为
`roleName`）的值，再以逗号 `,` 分隔组成字符串（`Underscore#pluckThenJoin`）后返回。

如此，前端便可以在获取关联目标端 id 列表的同时获取对应的显示文本列表：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleIdList
    relatedRoleIdList_label
  }
}
```

当然，在实际使用时也没有必要分别获取 id 及其显示文本列表，
直接返回关联对象列表及其必要属性，应该作为优先选择方案：

```graphql {5-8}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleList {
      id
      roleName
    }
  }
}
```

## XMeta 过滤条件转换 {#def_attr_props_prop_graphql_transFilter}

对业务对象的过滤可能会涉及较为复杂的组合条件（如，子查询等），或者是组合条件会出现多次，
亦或是直接拼接 SQL 片段，在这些情况下，便需要通过过滤器转换机制来实现。

过滤器转换机制就是通过一个转换函数，对过滤器（其为 `TreeBean`
类型）的树形结构上的节点（子过滤器）进行替换。

> 具体的转换逻辑见 `io.nop.api.core.beans.query.QueryBean#transformFilter`。

在 XMeta 中仅需要定义一个配置了过滤器转换函数 `graphql:transFilter`
的[对象属性](#def_attr_props_prop)即可，例如：

```xml {3,9,16} title="NopAuthSite.xmeta"
<meta>
  <x:gen-extends>
    <meta-gen:DefaultMetaGenExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:gen-extends>

  <props>
    <!-- Note：只有可查询（queryable = true）的属性才能参与过滤运算 -->
    <prop name="hasResourceStatus" queryable="true">
      <graphql:transFilter>
        <filter:sql>
          exists (
            select o2
            from NopAuthResource o2
            where
              o2.siteId = o.id
              and o2.status >= ${ filter.getAttr('value') }
          )
        </filter:sql>
      </graphql:transFilter>
    </prop>
  </props>
</meta>
```

在该例中，为对象属性 `hasResourceStatus` 配置了过滤器转换函数，其通过 Xpl 函数
`filter:sql` 构造了一个包含 SQL 片段的子过滤器，用于替换以 `hasResourceStatus`
作为运算条件的过滤器，并且，在该 SQL 片段中还以 `${ filter.getAttr('value') }`
形式引用了被替换过滤器的属性 `value` 的值。

> 注意，Xpl 函数 `meta-gen:DefaultMetaGenExtends` 会在
> XMeta 解析前全局引入 `filter:sql` 所在的函数库
> `/nop/core/xlib/filter.xlib`（即 `<c:import from="/nop/core/xlib/filter.xlib"/>`），
> 因此，不需要再在 `<filter:sql/>` 节点上配置
> `xpl:lib` 属性（即 `<filter:sql xpl:lib="/nop/core/xlib/filter.xlib"/>`）。

在调用对应的 GraphQL 接口时，可以构造如下形式的根过滤器 `filter`：

<!-- prettier-ignore -->
```json {10} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "and",
      "$body": [
        {
          "$type": "gt", "name": "orderNo", "value": 100
        },
        {
          "$type": "eq", "name": "hasResourceStatus", "value": 1
        }
      ]
    }
  }
}
```

以上调用最终生成的 SQL 如下：

```sql {5-10}
select o
from NopAuthSite o
where
  o.orderNo > 100 and
  exists (
    select o2
    from NopAuthResource o2
    where o2.siteId = o.id
    and o2.status >= 1
  )
```

也就是，以 `hasResourceStatus` 作为运算条件的过滤器均会被替换为
`graphql:transFilter` 所构造出的过滤器。

`graphql:transFilter` 的类型是 `xpl-fn`，即，一个 Xpl 函数，其函数签名为
`(filter, query, forEntity) => any`，函数参数分别为：

- `filter`：类型为 `TreeBean`，表示将要被替换的过滤器，即上例中的
  `{"$type": "eq", "name": "hasResourceStatus", "value": 1}`；
- `query`：类型为 `QueryBean`，对应于 GraphQL 接口中的 `query` 参数；
- `forEntity`：类型为 `Boolean`，始终为 `false`；

> `graphql:transFilter` 的执行逻辑见 `io.nop.biz.crud.BizQueryHelper#transformFilter`。

根据 `TreeBean#transformChild` 的处理逻辑可以发现 `graphql:transFilter`
函数的返回值可以是 `Boolean`、`XNode`、`null` 或者 `Collection<XNode>`，
因此，该函数的签名中指定的返回值类型为 `any`，并未直接限定返回 `XNode`。

但实际开发中，该函数一般只会返回 `XNode` 节点，以构造过滤条件，
而在构造过程中可以通过 `${...}` 引用该函数的参数，比如，前例中的
`${ filter.getAttr('value') }` 表示从参数 `filter` 中取其属性名为
`value` 的值（即，`1`）。

> 在 `TreeBean` 中除了属性 `$type` 是通过 `TreeBean#getTagName`
> 获取值以外，其余的属性均通过 `TreeBean#getAttr` 获取属性值。

由于 `graphql:transFilter` 函数的返回值是 `XNode` 节点，因此，除了通过
`filter:sql` 构造 SQL 过滤节点以外，还可以直接构造 EQL 过滤节点，甚至是二者共用：

```xml {3,4,12}
    <prop name="withOrderNoAndResourceStatus" queryable="true">
      <graphql:transFilter>
        <and xpl:outputMode="node">
          <gt name="orderNo" value="${ filter.getAttr('orderNo') }"/>

          <filter:sql>
            exists (
              select o2
              from NopAuthResource o2
              where
                o2.siteId = o.id
                and o2.status >= ${ filter.getAttr('resourceStatus') }
            )
          </filter:sql>
        </and>
      </graphql:transFilter>
    </prop>
```

> - `graphql:transFilter` 本身不支持输出，所以，需要在其标签内通过输出模式
>   `xpl:outputMode` 为 `node` 的 Xpl 脚本输出一个 `XNode` 节点；

在前端仅需要构造一个如下的过滤器即可得到与前面例子相同的过滤条件：

<!-- prettier-ignore -->
```json title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

注意，在该过滤器中不再设置 `value` 属性，而是分别指定了两个混合过滤器所需的参数
`orderNo` 和 `resourceStatus`，并调用 `TreeBean#getAttr` 获得了过滤器的传入值。

可以发现，虽然上面的过滤器传入了两个附加参数，但依然采用的是 `eq` 运算符。
这是因为，在属性定义上，默认的 `allowFilterOp`（允许的过滤运算）仅有 `eq` 和 `in`。
若是需要采用其他运算符，则需要显式设置 `allowFilterOp`，比如：

```xml {3}
    <prop name="withOrderNoAndResourceStatus"
          queryable="true"
          allowFilterOp="with"
    >
      <graphql:transFilter>
        <!-- ... -->
      </graphql:transFilter>
    </prop>
```

然后，构造过滤器为：

<!-- prettier-ignore -->
```json {4} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "with",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

此外，`filter` 实际所使用的运算符可以通过 `filter.getTagName()` 得到，
所以，在某些动态场景下，还可以根据实际使用的运算符来构造不同的过滤器：

```xml {7,18}
    <prop name="resourceStatus"
          queryable="true"
          allowFilterOp="eq,in"
    >
      <graphql:transFilter>
        <c:choose xpl:outputMode="node">
          <when test="${ filter.getTagName() == 'eq' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status = ${ filter.getAttr('value') }
              )
            </filter:sql>
          </when>
          <when test="${ filter.getTagName() == 'in' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status in (${ filter.getAttr('value') })
              )
            </filter:sql>
          </when>
          <otherwise>
            <!-- Note：若不做任何处理，则会删除待替换的过滤器 filter -->
            <c:throw
                errorCode="nop.err.xmeta.trans-filter.not-supported-op"
                params="${ {name: filter.getAttr('name'), op: filter.getTagName()} }"
            />
            <!-- 直接返回待替换的过滤器 filter，不做替换或删除 -->
            <!--<c:script>filter</c:script>-->
          </otherwise>
        </c:choose>
      </graphql:transFilter>
    </prop>
```

> 在涉及多分支判断时，不能采用 `c:if` 或 `xpl:if` 做分支处理，否则
> `graphql:transFilter` 将返回最后一个 if 分支的结果，若该分支不满足判断条件，则实际将返回
> `null`，而不是满足判断条件的分支结果。

如此，便可以按需使用 `eq` 或 `in` 过滤器来进行过滤查询：

<!-- prettier-ignore -->
```json {4,12} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq", "name": "resourceStatus", "value": 1
    }
  }
}
// 或者
{
  "query": {
    "filter": {
      "$type": "in", "name": "resourceStatus", "value": [1, 2, 3]
    }
  }
}
```

## XMeta 对象关联配置 {#relations}

### 一对一 {#relations-one-to-one}

```plantuml
class Left {
  + id: int
  + rightId: int
  + right: Right
}

class Right {
  + id: int
  + displayName: string
}

Left "1" -right-> "1" Right
```

根据以上图例所生成的 XMeta 为：

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

- `ext:relation` 用在 `Left`（关联的源端）直接与关联目标端（`Right`）建立关联的属性上，
  其指向在 `Left` 中与映射到关联目标端对象的属性上，如，`rightId -> right`；
- 在与关联目标端对象映射的属性上声明关联关系，包括：`ext:kind`、`ext:joinLeftProp`、`ext:joinRightProp` 等；
- `ext:kind` 设置为 `to-one`（一对一）模式关联 `Right`；
- `ext:joinLeftProp` 表示在 `Left`（关联的源端）中用于与 `Right`（关联的目标端）建立关联的属性；
- `ext:joinRightProp` 表示在 `Left`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
  `Right`（关联的目标端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Right`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 一对多 {#relations-one-to-many}

> 注意，一对多和一对一是互为反方向的关联配置，因此，二者是分别配置在关联的源端和目标端中的。

```plantuml
class Left {
  + id: int
  + rightId: int
  + displayName: string
}

class Right {
  + id: int
  + leftList: List<Left>
}

Right "1" -left-> "0..*" Left
```

根据以上图例所生成的 XMeta 为：

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftList"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
  </props>
</meta>
```

- `ext:kind` 设置为 `to-many`（一对多）模式关联 `Left`；
- `ext:joinRightProp` 表示在 `Left`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
- `ext:joinLeftProp` 表示在 `Left`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
  `Right`（关联的源端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Left`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 多对多 {#relations-many-to-many}

在 Nop 中是通过中间模型来建立多对多的关联，并通过中间模型将多对多分解为中间模型与关联双方的一对多关联：

> 详细的说明文件见文档<NopDocLink title="《多对多关联》" path="/dev-guide/orm/many-to-many.md" />。

```plantuml
class Left {
  + id: int
  + rightMappings: List<Ref>
}

map Ref {
  leftId => rightId
}

class Right {
  + id: int
  + leftMappings: List<Ref>
}

Ref "1" -left-> "1" Left::id
Ref "1" -right-> "1" Right::id
```

根据以上图例所生成的 XMeta 分别为：

- 配置 `Left` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Right`

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="leftId"
          orm:manyToManyRefProp="rightId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedRightIdList"
          ext:relation="relatedRightList"
          graphql:labelProp="relatedRightList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedRightList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Right"/>
      </schema>
    </prop>
    <prop name="relatedRightList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Left`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Left`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Right`（即，多对多的目标端模型）建立关联的属性；
> - `relatedRightList` 和 `relatedRightIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Left` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Right` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Left`

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          orm:manyToManyRefProp="leftId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedLeftIdList"
          ext:relation="relatedLeftList"
          graphql:labelProp="relatedLeftList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedLeftList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
    <prop name="relatedLeftList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Right`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Left`（即，多对多的目标端模型）建立关联的属性；
> - `relatedLeftList` 和 `relatedLeftIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Right` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Ref` 与 `Left` 和 `Right` 的一对一关联

```xml title="Ref.xmeta"
<meta>
  <props>
    <prop name="leftId" ext:relation="left">
      <schema type="java.lang.Integer"/>
    </prop>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="left"
          ext:kind="to-one"
          ext:joinLeftProp="leftId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Left"/>
    </prop>
    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-one`（一对一）模式关联 `Left` 或 `Right`；
> - `ext:joinLeftProp` 表示在 `Ref`（关联的源端）中用于与关联目标端（`Left` 或 `Right`）建立关联的属性；
> - `ext:joinRightProp` 表示在 `Ref`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
>   关联目标端（`Left` 或 `Right`）的属性；
> - `ext:relation` 用在 `Ref`（关联的源端）直接与关联目标端（`Left` 或 `Right`）建立关联的属性上，
>   其指向在 `Ref` 中与映射到关联目标端对象的属性上，如，`leftId -> left`、`rightId -> right`；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 关联过滤查询 {#relations-connection}

> 详细的说明请参考：
>
> - <NopDocLink title="Connection 配置" path="/dev-guide/graphql/connection.md" />
> - <NopDocLink title="Nop 入门：如何实现复杂查询" path="/tutorial/simple/4-complex-query.md" />
> - <NopDocLink title="如何实现对列表列表数据的过滤" path="/dev-guide/recipe/filter-list.md" />

:::tip

NopGraphQL 的 `DataFetcher` 机制会在获得主查询的结果后，
再逐条进行子查询，因此可能会出现明显的性能问题，在性能问题较明显时，需考虑在
<NopDocLink title="@SqlLibMapper" path="/dev-guide/orm/sql-lib.md" />
中做自定义查询或者采用按需加载机制。

:::

NopGraphQL 引擎提供 `DataFetcher` 机制，可以通过 `OrmEntityPropConnectionFetcher`
实现按需对关联对象进行过滤和排序，比如，按指定条件 `filter` 过滤出 `NopAuthSite`
的资源列表 `resourcesList`：

```graphql {6}
query($filter: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    resourcesList(filter: $filter, limit: 10, offset: 0) {
      total
      items {
        id
        displayName
      }
    }
  }
}

variables:
  filter: {
    "$type": "or",
    "$body": [
      { "$type": "eq", "status", 1},
      { "$type": "eq", "status", 2}
    ]
  }
```

则只需要在 `NopAuthSite.xmeta` 中为其对象属性 `resourcesList` 设置
`graphql:queryMethod`，将其定义为**关联查询属性**：

```xml {3,6,12} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="id"/>

    <prop name="resourcesList"
          graphql:queryMethod="findPage"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:filter>
        <eq name="siteId" value="@prop-ref:id"/>
      </graphql:filter>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

> - `<schema bizObjName="NopAuthResource"/>` 指示了关联对象（即，资源列表）的类型为 `NopAuthResource`；
> - `graphql:filter` 则用于指定关联查询的过滤条件，`@prop-ref:` 前缀表示从业务对象上获取属性值，
>   本例表示，过滤出 `NopAuthResource#siteId` 与业务对象上的属性 `id` 的值相等的数据；
> - `graphql:orderBy` 则指定了查询结果的排序条件，本例表示，按属性 `NopAuthResource#orderNo` 升序排序；
> - 前端传入的 `filter` 和 `orderBy` 参数不会覆盖对 `graphql:filter` 与 `graphql:orderBy`
>   的默认配置，而是会被组合在一起后，再进行过滤和排序；

属性 `graphql:queryMethod` 的可选值如下（具体实现参考 `io.nop.graphql.orm.fetcher.OrmEntityPropConnectionFetcher#get`）：

- `findCount`：返回 `long` 类型数据，表示符合过滤条件的数据总量；
- `findFirst`：返回关联对象类型数据，表示查询结果中的第一条对象数据；
- `findList`：返回 `List` 类型数据，表示查询结果中的全部对象数据；
- `findPage`：返回 `PageBean` 类型数据，表示指定分页的对象数据；
- `findConnection`：返回 `GraphQLConnection` 类型数据，表示指定分页的对象数据；

虽然关联查询的返回结果类型与指定的 `graphql:queryMethod` 相关，但其输入参数类型都是
`GraphQLConnectionInput`，如，`resourcesList(filter: $filter, limit: 10, offset: 0)`
中的括号内的部分既是 `GraphQLConnectionInput` 的各项属性配置。

关联过滤查询并不需要业务对象和关联对象在 ORM 层面存在确切的关联关系，
即使二者没有直接关联关系，甚至可以不在同一数据库中，也能够进行关联过滤查询，只需要通过
`graphql:filter` 指定相应的关联过滤条件即可。

而若是二者在 ORM 层面定义了一对一（`ext:kind="to-one"`）或一对多（`ext:kind="to-many"`）的关联关系，
则可以设置属性 `graphql:connectionProp` 指向对应的关联属性，从而按二者的关联关系自动推导
`graphql:filter` 的配置，如：

```xml {3,14} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="resources"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="siteId"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>
    </prop>

    <prop name="resourcesConnection"
          graphql:queryMethod="findPage"
          graphql:connectionProp="resources"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

也就是，`resourcesConnection` 在查询时会根据 `graphql:connectionProp`
指向的 `resources` 属性的一对多关联自动推导得到过滤条件 `NopAuthResource#siteId = ${id}`。
而若是在 `resourcesConnection` 中再配置 `graphql:filter`，
则表示在已推导得到的过滤条件的基础上再补充额外的过滤条件。

此外，定义的**关联查询属性**（前例中的 `resourcesList` 或 `resourcesConnection`）是可以复用的，利用
GraphQL 的[别名](https://graphql.org/learn/queries/#aliases)机制，
可以实现用同一个关联查询属性返回不同的查询结果：

```graphql {6,13}
query ($filter1: Map, $filter2: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    activeResources: resourcesList(filter: $filter1, limit: 10, offset: 0) {
      items {
        id
        displayName
      }
    }

    inactiveResources: resourcesList(filter: $filter2, limit: 10, offset: 20) {
      items {
        id
        displayName
      }
    }
  }
}
```

## XMeta 输入/输出转换 {#data_transform_in_and_out}

### 输入转换 {#data_transform_in}

为了适配组件规范或者方便用户输入等原因，客户端可能会将本身为列表类型的数据，
采用分隔符拼接为字符串后再提交给服务端，在这种情况下，
屏蔽客户端与服务端之间数据结构差异的最好方式就是对提交数据做**输入转换**，
从而确保在处理业务逻辑时无需关注客户端的变化。

在 XMeta 中可以通过 `<transformIn />` 配置相应的**输入转换函数**，
从而将客户端的输入数据转换为服务端需要的结构，例如，将以 `,` 分隔的
`types` 字符串转换为字符串数组：

```xml {5-7}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>
    </prop>
  </props>
</meta>
```

该输入转换函数的可用参数如下（该函数的调用逻辑见 `ObjMetaBasedValidator#transformIn`）：

- `data`: `Map` 类型，其为客户端提交的全部输入数据；
- `value`: 其为业务对象属性对应的待转换输入数据。可能为 `null`；
- `transData`: `Map` 类型，其包含当前已处理的输入数据，其将被用于构造出业务对象；
- `propMeta`: `IObjPropMeta` 类型，其为业务对象属性的[结构](#def_attr_props_prop)；

在 `<transformIn />` 标签内可以编写任意 <NopDocLink title="Xpl" path="/dev-guide/xlang/xpl.md" />
标签，或者直接编写 <NopDocLink title="XScript" path="/dev-guide/xlang/xscript.md" />
脚本，仅需要确保最后一段的执行逻辑会返回转换后的值即可：

```xml {5}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        return value?.split(',');
      </transformIn>
    </prop>
  </props>
</meta>
```

### 输出转换 {#data_transform_out}

输出转换可以视为[输入转换](#data_transform_in)的逆过程，
也就是，将服务端输出的数据转换为客户端所接受的数据格式：

```xml {5-9}
<meta>
  <props>
    <prop name="types">
      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

不过，与 `<transformIn />` 不同的是，`<transformOut />` 采用的是
NopGraphQL 的 `DataFetcher` 机制进行调用的，其转换逻辑由
`EvalActionTransformFetcher` 执行。

输出转换函数可访问的参数如下：

- `entity`: 其为业务对象自身；
- `value`: 其为业务对象属性的值，也就是待转换的输出数据。可能为 `null`；

### 自动转换 {#data_transform_auto}

得益于 Nop 内置的 `x:post-extends` 元编程机制，在 XMeta 中可以引入 Xpl 函数
`meta-gen:DefaultMetaPostExtends`：

```xml {9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>
</meta>
```

该函数将会根据 [&lt;schema />](#attr_props_prop_schema)
上设置的 [domain](./dsl/schema#attr_domain)
或 [stdDomain](./dsl/schema#attr_stdDomain)，从
`/nop/core/xlib/meta-prop.xlib` 中查找名称为 `domain-{domain}`
或 `domain-{stdDomain}` 的 Xpl 函数，并自动将该函数生成的 `XNode`
合并到业务对象属性节点上（处理逻辑见 Xpl 函数 `meta-gen:GenPropForDomain`）。

假设，将前面的例子中的属性 `types` 的 Schema Domain 设置为 `comma-list`：

```xml {3,9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>

  <props>
    <prop name="types">
      <schema domain="comma-list" />
    </prop>
  </props>
</meta>
```

然后，通过 Nop delta 机制，在 `/nop/core/xlib/meta-prop.xlib`
中添加函数 `domain-comma-list`（即命名为 `domain-{domain}` 形式）：

```xml {12} title="/_vfs/_delta/default/nop/core/xlib/meta-prop.xlib"
<lib xmlns:x="/nop/schema/xdsl.xdef"
      x:schema="/nop/schema/xlib.xdef"
      x:extends="super"
>
  <tags>
    <domain-comma-list outputMode="node">
      <attr name="propNode"/>

      <source>
        <prop name="${propNode.getAttr('name')}">
          <!-- type 为客户端所接受的类型 -->
          <schema type="String"/>

          <transformIn>
            <c:script><![CDATA[
              return value?.split(',');
            ]]]></c:script>
          </transformIn>

          <transformOut>
            <c:script><![CDATA[s
              import java.lang.String;

              return value ? String.join(',', value) : null;
            ]]]></c:script>
          </transformOut>
        </prop>
      </source>
    </domain-comma-list>
  </tags>
</lib>
```

最终，生成的 `types` 属性的结构如下：

```xml
<meta>
  <props>
    <prop name="types">
      <schema type="String"/>

      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>

      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

此外，对于配置了掩码模式 [ui:maskPattern](#attr_props_prop_ui_maskPattern)
的属性，也会由 Xpl 函数 `meta-gen:GenMaskingExpr` 自动构造并生成如下输出转换函数：

```xml {3,5}
<meta>
  <props>
    <prop name="mobile" ui:maskPattern="3*4">
      <transformOut>
        return value?.toString()?.$maskPattern("3*4");
      </transformOut>
    </prop>
  </props>
</meta>
```

## XMeta 属性自动计算 {#def_attr_props_prop_autoExpr}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr_when"> when </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> 执行计算的条件 </TCol>
<TCol> 是 </TCol><TDesc>

其为调用 `OrmEntityCopier#copyToEntity` 的 `@BizAction`
的名称列表，以 `,` 分隔。表示只有在执行该列表内名称的 BizModel Action
时才计算业务对象属性的缺省值。默认的可选值如下：

- `save`: 保存时；
- `update`: 更新时；
- `copyForNew`: 复制新增时;

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr_body"> &lt;/> </TCol><TCol>

[xpl](./dict/std-domain#opt_xpl)

</TCol><TCol> 计算函数 </TCol>
<TCol> 是 </TCol><TDesc>

该函数的可用参数如下（详细执行逻辑见 `AutoExprRunner#runAutoExpr`）：

- `entity`: 其为业务对象自身；
- `data`: 其为客户端提交的数据；
- `objMeta`: `IObjSchema` 类型，其为业务对象的[结构](#attrs)；
- `propMeta`: `IObjPropMeta` 类型，其为业务对象属性的[结构](#def_attr_props_prop)；

</TDesc></TRow>

</Table>

属性自动计算在如下情况将被忽略：

- 客户端 _已提交_ **业务对象属性**的值；
- 客户端的提交 _已被禁用_（即，[insertable](#attr_props_prop_insertable)
  或 [updatable](#attr_props_prop_updatable) 为 `false`）；
- **业务对象属性** _已配置_ [缺省值](#attr_props_prop_defaultValue)；
- **业务对象属性** _已被设置_ 为[虚拟字段](#attr_props_prop_virtual)；

:::tip

[&lt;setter />](#attr_props_prop_setter)
和 [&lt;transformIn />](#attr_props_prop_transformIn)
只在客户端有提交业务对象属性的值时，才会被调用，因此，二者与
`<autoExpr />` 的调用是互斥的，不会同时被调用。

:::

若在业务对象属性上配置了 [biz:codeRule](#attr_props_prop_biz_codeRule)，
但未配置 `<autoExpr />` 时，则会自动构造该属性缺省值的计算函数：

```xml
<meta>
  <props>
    <prop name="code" biz:codeRule="D{@year}{@month}{@seq:5}">
      <autoExpr when="save">
        <c:script><![CDATA[
          const codeRuleGenerator = inject('nopCodeRuleGenerator');

          return codeRuleGenerator.generate(propMeta['biz:codeRule'], $scope);
        ]]></c:script>
      </autoExpr>
    </prop>
  </props>
</meta>
```

## XMeta 属性访问控制 {#def_attr_props_prop_auth}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_for"> for </TCol><TCol>

[xml-name](./dict/std-domain#opt_xml_name)

</TCol><TCol> 权限类型名 </TCol>
<TCol> 是 </TCol><TDesc>

权限类型名的可选值如下：

- `read`: 属性读权限；
- `write`: 属性写权限；
- `all`: 属性读和写权限；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_roles"> roles </TCol><TCol>

[csv-set](./dict/std-domain#opt_csv_set)

</TCol><TCol> 拥有 for 权限的角色列表 </TCol>
<TCol> 否 </TCol><TDesc>

以 `,` 分隔的角色列表。若操作者所拥有的角色存在于该列表内，则该操作者便拥有
[for](#attr_props_prop_auth_for) 对应的属性访问权限

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_permissions"> permissions </TCol><TCol>

[multi-csv-set](./dict/std-domain#opt_multi_csv_set)

</TCol><TCol> 拥有 for 权限的操作权限列表 </TCol>
<TCol> 否 </TCol><TDesc>

以 `,` 和 `|` 分隔的操作权限列表，`,` 之间为`与`的关系，`|` 之间为`或`的关系。
若操作者所拥有的操作权限满足该`与/或`关系（判断逻辑见
`IActionAuthChecker#isPermissionSetSatisfied`），则该操作者便拥有
[for](#attr_props_prop_auth_for) 对应的属性访问权限。

操作权限的格式为 `{bizObjName}:{actionName}`，即，对应于
[BizModel](./xbiz) 的 `@BizAction` 方法，
例如，`NopAuthUser:query`、`NopAuthUser:mutation`、`NopAuthUser:delete` 等

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth_publicAccess"> publicAccess </TCol>
<TCol> boolean </TCol><TCol> 是否可公开访问？ </TCol>
<TCol> 是 </TCol><TDesc>

若该值为 `true`，则 [roles](#attr_props_prop_auth_roles)
和 [permissions](#attr_props_prop_auth_permissions) 的设置均无效，
所有的操作者均可读写业务对象属性。缺省值为 `false`

</TDesc></TRow>

</Table>

对 XMeta 属性的访问由 `ObjMetaBasedValidator#doCheckAuth` 进行控制，
并且，[roles](#attr_props_prop_auth_roles) 的设置优先于
[permissions](#attr_props_prop_auth_permissions)，
仅当 `roles` 未配置时，`permissions` 的配置才会起作用，
若二者均未配置，则视为无读写权限，将抛出无访问权限的异常。

`permissions` 的检查由 `IActionAuthChecker` 的实现类进行验证，
若是操作权限控制被禁用（即，配置 `nop.auth.enable-action-auth` 为 `false`），
或者在应用中未提供 `IActionAuthChecker` 的实现，则同样视为无读写权限。

> `IActionAuthChecker` 的实现实例需绑定到 `GraphQLEngine` 的实例上。

此外，由于在 nop-file 模块中需要建立 `IFileRecord` 与 `BizObject` 属性的关联，
因此，在上传或下载文件时，在 `NopFileStoreBizModel` 中也会通过
`IBizAuthChecker` 检查关联模型属性的访问权限，其检查逻辑与前面描述的一致，
具体见 `GraphQLActionAuthChecker#checkAuth`。

## XMeta GraphQL 输入参数列表 {#def_attr_props_prop_arg}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_name"> name </TCol><TCol>

[var-name](./dict/std-domain#opt_var_name)

</TCol><TCol> 参数名 </TCol>
<TCol> 是 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_mandatory"> mandatory </TCol>
<TCol> boolean </TCol><TCol> 参数是否必填？ </TCol>
<TCol> 是 </TCol><TDesc>

指示<b>当前参数</b>是否为必填项。缺省为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 参数显示名称 </TCol>
<TCol> 否 </TCol><TDesc>

<b>当前参数</b>的显示名称，方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 参数说明 </TCol>
<TCol> 否 </TCol><TDesc>

对参数作用、使用等进行说明

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg_schema"> &lt;schema /> </TCol>
<TCol> ISchema </TCol><TCol> 参数 Schema </TCol>
<TCol> 否 </TCol><TDesc>

对当前参数值类型、值精度等的约束定义。
详细说明见 [基础 DSL - Schema](./dsl/schema#attrs)

</TDesc></TRow>

</Table>

NopGraphQL 引擎在通过 `DataFetcher` 获取关联数据时，会根据客户端指定的
[GraphQL 输入参数](https://graphql.org/learn/queries/#arguments)
进行关联数据的动态查询。

为了确保输入参数的完整性和准确性，并支持自动的数据转换和数据校验，
因此，需要对 GraphQL 输入参数进行类型定义。

在 Nop 中，除了通过 [&lt;arg />](#attr_props_prop_arg)
进行输入参数定义，还可以通过
[&lt;graphql:inputType />](#attr_props_prop_graphql_inputType)
以强类型方式进行定义。

而对于 [graphql:queryMethod](#attr_props_prop_graphql_queryMethod)
指定的[关联过滤查询](#relations-connection)则会使用
`GraphQLConnectionInput` 作为缺省的输入参数类型。

从 `ObjMetaToGraphQLDefinition#toFieldDefinition`
的实现中可以确定三种输入参数类型定义的优先级如下：

- 若设置了 `<graphql:inputType />`，则 `<arg />` 将被忽略；
- 若配置了 `<arg />`，则 `GraphQLConnectionInput` 将不会被使用；
- 若配置了 `graphql:queryMethod`，但未配置 `<graphql:inputType />`
  和 `<arg />`，则使用 `GraphQLConnectionInput` 为输入参数缺省类型；

实际开发中，可以在自定义的 [&lt;getter />](#attr_props_prop_getter)
函数中获取到客户端回传的输入参数（详见 `PropGetterFetcher`），并以此进行相应的数据加载处理。
