---
title: XMeta 模型
description: 关于 XMeta 模型的配置说明
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import Header from '@site/docs/\_header.md';

<Header />

XMeta 为 Nop 平台提供了标准化的**对象元数据**模型，所有需要定义对象结构的地方都统一使用 XMeta 模型来定义。

> XMeta 和 XDef 可以相互转换。XDef 对应于 XML 结构，而 XMeta 对应于对象属性结构。

XMeta 定义了后台服务对象的元数据，描述了对象具有哪些属性，以及这些属性是否可以修改、是否可以用于查询等信息。
NopGraphQL 引擎返回的对象信息也完全由 XMeta 来定义。

<!-- https://plantuml.com/object-diagram -->

```plantuml
object "/nop/schema/xmeta.xdef" as xmeta {
  orderBy => /nop/schema/query/order-by.xdef
}
object "/nop/schema/schema/schema-node.xdef" as schema_node {
}
object "/nop/schema/schema/obj-schema.xdef" as obj_schema {
}
object "/nop/schema/query/order-by.xdef" as order_by {
}

xmeta -down-> obj_schema: xdef:ref 引用
obj_schema -down-> schema_node: xdef:ref 引用

xmeta::orderBy -> order_by
```

> - `xdef:name` 代表节点对应的 Java 类名；
> - `xdef:ref` 代表当前节点类的基类；

## XMeta 结构 {#attrs}

<Table head={['属性', '值类型', '属性名称']}>

<!-- -->

<TRow><TCol id="attr_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 对象的显示名称 </TCol>
<TDesc>

<b>当前对象</b>的显示名称，方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_displayProp"> &lt;displayProp /> </TCol>
<TCol> string </TCol><TCol> 显示属性 </TCol>
<TDesc>

指定用于显示<b>当前对象</b>数据名称的[对象属性](#def_attr_props_prop)，
用于下拉列表等需要显示<b>当前对象</b>数据名称的地方

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 描述说明 </TCol>
<TDesc>

说明对象用途、使用注意事项等

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_entityName"> &lt;entityName /> </TCol>
<TCol> class-name </TCol><TCol> ORM 实体类名（全名） </TCol>
<TDesc>

仅在映射了 ORM 实体对象时指定

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_primaryKey"> &lt;primaryKey /> </TCol>
<TCol> word-set </TCol><TCol> ORM 实体主键列表 </TCol>
<TDesc>

逗号分隔的作为 ORM 实体主键的[对象属性](#def_attr_props_prop)列表。
只能包含映射了 ORM 表字段的[对象属性](#def_attr_props_prop)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key"> &lt;keys>&lt;key />&lt;/keys> </TCol>
<TCol> ObjKeyModel </TCol><TCol> ORM 实体唯一键列表 </TCol>
<TDesc>

在新增或修改 ORM 实体时，将自动检查该唯一键不冲突。
详细说明见 [实体唯一键列表](#def_attr_keys_key)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_filter"> &lt;filter /> </TCol>
<TCol> filter-bean </TCol><TCol> 默认的 ORM 实体过滤条件 </TCol>
<TDesc>

指定在对象级别始终自动添加的过滤条件，如，`<eq name="status" value="1" />`，
用于过滤活跃状态的实体对象。新增或修改 ORM 实体时会自动设置 filter
中对应的属性值，确保查询时不会突破过滤条件限制

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field"> &lt;orderBy>&lt;field />&lt;/orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> 默认的 ORM 实体排序条件列表 </TCol>
<TDesc>

指定在对象级别的缺省排序条件。详细说明见 [实体排序条件列表](#def_attr_orderBy_field)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree"> &lt;tree /> </TCol>
<TCol> ObjTreeModel </TCol><TCol> ORM 实体树形结构配置 </TCol>
<TDesc>

用于补充 ORM 实体的树形结构相关的属性信息。
根据此结构查询和维护树形结构的实体数据和父子关联（[参考用例](/practice/demo/v2#create-tree)）。
详细说明见 [实体树形结构配置](#def_attr_tree)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection"> &lt;selections>&lt;selection />&lt;/selections> </TCol>
<TCol> ObjSelectionMeta </TCol><TCol> GraphQL 字段选择集合 </TCol>
<TDesc>

用于控制 GraphQL 返回对象所包含的属性结构，即，指定哪些属性的值需要返回。
详细说明见 [GraphQL 字段选择集合](#def_attr_selections_selection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop"> &lt;props>&lt;prop />&lt;/props> </TCol>
<TCol> ObjPropMetaImpl </TCol><TCol> 对象属性列表 </TCol>
<TDesc>

详细说明见 [对象属性列表](#def_attr_props_prop)

</TDesc></TRow>

</Table>

### 实体唯一键列表：`<keys><key /></keys>` {#def_attr_keys_key}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_keys_key_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 唯一键的显示名称 </TCol>
<TCol> 否 </TCol><TDesc>

显示名称，方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_name"> name </TCol>
<TCol> string </TCol><TCol> 唯一键名 </TCol>
<TCol> 是 </TCol><TDesc>

对应数据库层面的 `UNIQUE KEY` 名称，仅包含字母、数字和下划线

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_keys_key_props"> props </TCol>
<TCol> word-set </TCol><TCol> 唯一键属性列表 </TCol>
<TCol> 是 </TCol><TDesc>

逗号分隔的具有唯一性约束的[对象属性](#def_attr_props_prop)列表。
只能包含映射了 ORM 表字段的[对象属性](#def_attr_props_prop)

</TDesc></TRow>

</Table>

### 实体排序条件列表：`<orderBy><field /></orderBy>` {#def_attr_orderBy_field}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_orderBy_field_name"> name </TCol>
<TCol> string </TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

映射了 ORM 表字段的[对象属性](#def_attr_props_prop)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_desc"> desc </TCol>
<TCol> boolean </TCol><TCol> 是否降序排序 </TCol>
<TCol> 是 </TCol><TDesc>

默认为 `false`，即，升序排序

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_orderBy_field_nullsFirst"> nullsFirst </TCol>
<TCol> boolean </TCol><TCol> NULL 值优先？ </TCol>
<TCol> 否 </TCol><TDesc>

- 为 `true` 时，表示 `NULL` 值小于所有非 `NULL` 值；
- 为 `false` 时，表示 `NULL` 值大于所有非 `NULL` 值；

</TDesc></TRow>

</Table>

### 实体树形结构配置：`<tree />` {#def_attr_tree}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_tree_parentProp"> parentProp </TCol>
<TCol> string </TCol><TCol> 指向父实体的属性名 </TCol>
<TCol> 是 </TCol><TDesc>

这里填写的不是与父实体同类型的属性名（如 `parent`），
而是与 ORM 表字段直接映射的属性名（如 `parentId`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_childrenProp"> childrenProp </TCol>
<TCol> string </TCol><TCol> 指向子实体的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

在父实体中对应的子实体的集合类型的属性名，如 `children`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_levelProp"> levelProp </TCol>
<TCol> string </TCol><TCol> 表示节点级别的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

其值对应的属性须为整数类型。若其值为 `level`，
则 `level = 1` 表示一级节点，`level = 2` 表示二级节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootLevelValue"> rootLevelValue </TCol>
<TCol> string </TCol><TCol> 根节点所对应的节点级别属性的值 </TCol>
<TCol> 否 </TCol><TDesc>

若 `levelProp` 所对应的属性的值为该属性的值时，表示得到的实体数据为根节点。
例如，其值为 `0` 则表示 `level = 0` 的结果为根节点，
若未指定该值，则以 `rootParentValue` 对应的结果为根节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_rootParentValue"> rootParentValue </TCol>
<TCol> string </TCol><TCol> 根节点的初始值 </TCol>
<TCol> 否 </TCol><TDesc>

若 `parentProp` 所对应的属性的值为该初始值时，表示得到的实体数据为根节点。
例如，其值为 `0` 则表示 `parentId = 0` 的结果为根节点，
若未指定该值，则表示 `parentId is null` 的结果为根节点

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_sortProp"> sortProp </TCol>
<TCol> string </TCol><TCol> 排序属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于对树形数据排序的[对象属性](#def_attr_props_prop)，默认为
`XMeta#primaryKey` 指定的单一[对象属性](#def_attr_props_prop)（复合主键将抛异常）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_tree_isLeafProp"> isLeafProp </TCol>
<TCol> string </TCol><TCol> 表示叶子节点的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

用于指示实体数据是否为叶子节点的[对象属性](#def_attr_props_prop)，
该属性须为 `Boolean` 类型。**暂时不确定其用途！**

</TDesc></TRow>

</Table>

根据 `<tree />` 的配置拼接 SQL 的逻辑见 `io.nop.biz.crud.TreeEntityHelper#buildTreeEntityBaseSql`，
也可以参考文档 [树形结构相关](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/orm/tree-structure.md)。

根节点默认以条件 `o.{parentProp} is null` 来过滤。如果指定了 `rootParentValue`
或 `rootLevelValue`，则以条件 `o.{parentProp} = ${rootParentValue}`
或 `o.{levelProp} = ${rootLevelValue}`，且以 `rootLevelValue` 来过滤根节点的优先级高于
`rootParentValue`。

### GraphQL 字段选择集合：`<selections><selection /></selections>` {#def_attr_selections_selection}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_selections_selection_id"> id </TCol>
<TCol> string </TCol><TCol> 选择集合唯一标识 </TCol>
<TCol> 是 </TCol><TDesc>

用于区分其他字段选择集合

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_selections_selection_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 显示名 </TCol>
<TCol> 否 </TCol><TDesc>

方便人阅读

</TDesc></TRow>

</Table>

`<selection />` 标签的 body 为
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
语法：

```xml
<meta>
  <selections>
    <selection id="F_defaults">
      userId, userName, status
    </selection>

    <selection id="F_moreFields">
      userId, userName, status, relatedRoleList{ roleId, roleName, permissionList{ id, name } }
    </selection>

    <selection id="copyForNew">
      status, description
    </selection>
  </selections>
</meta>
```

关于 `<selection />` 有如下内置约定：

- `id` 为 `copyForNew`：特定用于接口 `@mutation:{BizObjName}__copyForNew/id`
  做 ORM 实体的复制新增，指定默认的可被复制的属性。其实现逻辑见
  `io.nop.biz.crud.CrudBizModel#copyForNew`
  - 为了安全性，可复制内容不允许前端指定
- `id` 以 `F_` 为前缀：表示查询接口可以使用的 GraphQL Fragment 定义。其中，`F_defaults`
  表示默认可返回的字段集合，若未配置该 selection，则返回所有的缺省字段（非 lazy 加载的字段）
- `id` 为其余名称：其用途可根据业务需求自行决定。比如，通过
  `getObjMeta().getFieldSelection("my_selection")` 获得配置的字段，再调用
  `io.nop.biz.crud.CrudBizModel#doSave` 保存指定字段的数据

关于 `<selection />` 的使用：

- 指定返回默认字段：

```graphql
// 等价于 REST 调用: /r/Book__get?id=123
query {
  Book__get(id:123) {
    ...F_defaults
  }
}

// 等价于 REST 调用: /r/Book__get?id=123&@selection=...F_defaults,author
query {
  Book__get(id:123) {
    ...F_defaults,
    author {
      ...F_defaults
    }
  }
}

// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_defaults,groupMappings
query {
  NopAuthUser__findList {
    ...F_defaults, groupMappings{ ...F_defaults }
  }
}
```

- 指定返回其他字段：

```graphql
// 等价于 REST 调用: /r/NopAuthUser__findList?@selection=...F_moreFields
query {
  NopAuthUser__findList {
    ...F_moreFields
  }
}
```

### 对象属性列表：`<props><prop /></props>` {#def_attr_props_prop}

:::tip

目前仅关注与后端处理相关的属性，对于仅在 XView 层面使用的属性（如
`ui:maxUploadSize` 等）暂时未做整理。

:::

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_name"> name </TCol>
<TCol> prop-path </TCol><TCol> 属性名 </TCol>
<TCol> 是 </TCol><TDesc>

Java 复合属性名，可以由一个或者多个 `prop-name` 构成，通过字符 `.` 来分隔。
注：`prop-name` 为 Java 属性名，一般由字母和数字、下划线组成，不包含字符 `.` 和 `$`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_schema"> &lt;schema /> </TCol>
<TCol> ISchema </TCol><TCol> 属性 Schema </TCol>
<TCol> 否 </TCol><TDesc>

对<b>当前属性</b>值类型、值精度等的约束定义。详细说明见 [XMeta 属性 Schema](#def_attr_props_prop_schema)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_displayName"> displayName </TCol>
<TCol> string </TCol><TCol> 属性显示名称 </TCol>
<TCol> 否 </TCol><TDesc>

方便人阅读

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_description"> &lt;description /> </TCol>
<TCol> string </TCol><TCol> 属性描述 </TCol>
<TCol> 否 </TCol><TDesc>

描述属性

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_defaultValue"> defaultValue </TCol>
<TCol> any </TCol><TCol> 属性默认值 </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_propId"> propId </TCol>
<TCol> int </TCol><TCol> 属性的顺序标识 </TCol>
<TCol> 否 </TCol><TDesc>

可以对应于 protobuf 标准中的 `propId` 属性，同时也与 ORM 实体上的 `propId` 对应

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mapToProp"> mapToProp </TCol>
<TCol> prop-path </TCol><TCol> 映射到 ORM 实体的指定属性 </TCol>
<TCol> 否 </TCol><TDesc>

为 ORM 实体的属性（注意，**不是当前对象的属性**）映射一个别名，
如，将 ORM 实体的属性 `a.b` 映射到别名 `b` 上，在 GraphQL 返回结果时，
会通过 `OrmDependsPropFetcher` 从 ORM 实体上获取 `a.b` 的值后赋值给对象的属性 `b`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_depends"> depends </TCol>
<TCol> csv-set </TCol><TCol> <b>当前属性</b>所依赖的属性列表 </TCol>
<TCol> 否 </TCol><TDesc>

逗号分隔的属性列表（需在 ORM 实体上有映射）。在获取<b>当前属性</b>的值时，需要依赖其他字段。
例如，在批量加载<b>当前属性</b>时，需要把依赖的属性也进行批量加载

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_mandatory"> mandatory </TCol>
<TCol> boolean </TCol><TCol> 属性值必填？ </TCol>
<TCol> 是 </TCol><TDesc>

指示<b>当前属性</b>是否为必填项。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_internal"> internal </TCol>
<TCol> boolean </TCol><TCol> 是否内部属性？ </TCol>
<TCol> 是 </TCol><TDesc>

自动推导生成的<b>当前对象</b>属性，将被设置为内部属性，即，`internal="true"`。
在 XView 中默认不显示内部属性。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_deprecated"> deprecated </TCol>
<TCol> boolean </TCol><TCol> 是否已废弃？ </TCol>
<TCol> 是 </TCol><TDesc>

已废弃的属性将不再被使用。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_insertable"> insertable </TCol>
<TCol> boolean </TCol><TCol> 是否可新增？ </TCol>
<TCol> 是 </TCol><TDesc>

若为 `false`，则新增的 ORM 实体将不会插入该属性数据。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_updatable"> updatable </TCol>
<TCol> boolean </TCol><TCol> 是否可更新？ </TCol>
<TCol> 是 </TCol><TDesc>

若为 `false`，则更新的 ORM 实体将不会更新该属性数据。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_virtual"> virtual </TCol>
<TCol> boolean </TCol><TCol> 是否虚拟字段？ </TCol>
<TCol> 是 </TCol><TDesc>

虚拟字段不会被复制到 ORM 实体上。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_published"> published </TCol>
<TCol> boolean </TCol><TCol> 是否对外开放？ </TCol>
<TCol> 是 </TCol><TDesc>

为 `false` 时，则在 GraphQL 返回的对象中将不包含该属性，对外不可见，
比如，密码等敏感属性。默认为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_exportable"> exportable </TCol>
<TCol> boolean </TCol><TCol> 是否可导出？ </TCol>
<TCol> 是 </TCol><TDesc>

仅当该值为 `true` 且
[published](#attr_props_prop_published) 也为 `true`
时，该属性才能够被导出。默认为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_sortable"> sortable </TCol>
<TCol> boolean </TCol><TCol> 是否可排序？ </TCol>
<TCol> 是 </TCol><TDesc>

是否可以被作为排序字段出现在 SQL 的 `order by` 语句中。默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_queryable"> queryable </TCol>
<TCol> boolean </TCol><TCol> 是否可查询？ </TCol>
<TCol> 是 </TCol><TDesc>

该属性对应的 ORM 表字段是否可以被作为查询字段出现在 SQL 的 `where` 语句中，
与 `allowFilterOp` 配合，可限制在该属性对应的 ORM 表字段上能够应用的过滤运算。默认为 `false`。
注：作为[过滤器转换](#def_attr_props_prop_graphql_transFilter)的对象属性需要设置该属性值为 `true`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_allowFilterOp"> allowFilterOp </TCol>
<TCol> word-set </TCol><TCol> 允许的过滤运算 </TCol>
<TCol> 否 </TCol><TDesc>

可以在该属性对应的 ORM 表字段上执行哪些查询运算，如
`gt`、`ge`、`contains`、`like`等，默认只允许 `in`、`eq`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_lazy"> lazy </TCol>
<TCol> boolean </TCol><TCol> 是否懒加载？ </TCol>
<TCol> 是 </TCol><TDesc>

默认为 `false`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_kind"> ext:kind </TCol>
<TCol> string </TCol><TCol> 类别 </TCol>
<TCol> 否 </TCol><TDesc>

可选值：

- `to-one`：<b>当前对象</b>与属性对应的对象为一对一关联；
- `to-many`：<b>当前对象</b>与属性对应的对象为一对多关联；
- `alias`：表示其为在 ORM 实体上定义的别名，通过该属性名，可以找到别名映射的源属性；
- `component`：表示其为 ORM 实体中的组件字段，比如，JSON 字段。
  注意，对于文件字段，会通过 `mapToProp` 映射到 ORM 实体对应组件字段的
  `fileStatus`/`fileStatusList` 属性上，不再设置 `ext:kind="component"`；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_tagSet"> tagSet </TCol>
<TCol> tag-set </TCol><TCol> 附加标识列表 </TCol>
<TCol> 否 </TCol><TDesc>

**[XOrm Only]**
逗号分隔的自定义标识列表。用于 CodeGen 在通过 `app.orm.xml`
生成 xmeta 时，会根据这些标识来设置其他属性的值。其实际来自于设置在
ORM 实体属性上的 `tagSet`。注意，**若是以 XMeta 为中心设计模型，是不需要该属性的**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_type"> graphql:type </TCol>
<TCol> string </TCol><TCol> <b>当前属性</b>值的返回类型 </TCol>
<TCol> 否 </TCol><TDesc>

将<b>当前属性</b>的值按该设定的类型转换后返回。该属性的可选值为枚举类
`io.nop.graphql.core.schema.GraphQLScalarType`
中的各个枚举量的名称（大小写敏感），如 `String`、`Map`。
如果返回的是集合类型，则需要将可选值包裹在 `[]` 内，如
`[String]`（字符串集合）、`[Map]`（键值对集合）。
注意：

- 作为主键的 `Long` 型数据，一般要求将其转换为 `String`
  后返回，因为，JS 对于超过一定大小的 `Long` 型数据会无法正常处理；
- 对于内容为 JSON 格式的字符串，可以设定返回类型为 `[Map]`，以便于前后端以
  JSON 对象交换数据；

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_mapper"> graphql:mapper </TCol>
<TCol> string </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_labelProp"> graphql:labelProp </TCol>
<TCol> prop-path </TCol><TCol> 作为<b>当前属性</b>显示文本的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>指向的是对象（含对象集合）或数据字典时，
一般需要声明使用<b>当前对象</b>中的哪个[属性](#def_attr_props_prop)的值作为其显示文本。
其优先级高于 [ext:joinRightDisplayProp](#attr_props_prop_ext_joinRightDisplayProp)。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictName"> graphql:dictName </TCol>
<TCol> string </TCol><TCol> 数据字典名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于 [graphql:labelProp](#attr_props_prop_graphql_labelProp)
所指向的<b>当前对象</b>属性，其值为所关联的数据字典。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_dictValueProp"> graphql:dictValueProp </TCol>
<TCol> prop-path </TCol><TCol> 与数据字典关联的<b>当前对象</b>的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于 [graphql:labelProp](#attr_props_prop_graphql_labelProp)
所指向的<b>当前对象</b>属性，其值为对应的 `graphql:labelProp`
所在的<b>当前对象</b>属性，从而使 `graphql:dictValueProp`
与 `graphql:labelProp` 构成双向关联。
详细说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinLeftProps"> graphql:joinLeftProps </TCol>
<TCol> word-set </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_joinRightProps"> graphql:joinRightProps </TCol>
<TCol> word-set </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

**预留配置，暂时未启用！**

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_datePattern"> graphql:datePattern </TCol>
<TCol> string </TCol><TCol> 日期转换格式 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>的数据类型为 `Timestamp`，且系统配置
`nop.graphql.ignore-millis-in-timestamp`（`Timestamp` 类型是否不以毫秒形式返回）为 `true`
时，NopGraphQL 引擎会自动将<b>当前属性</b>的值按该设定的形式格式化为字符串后返回。
注意，若设定的转换格式为 `ms`，则返回日期的毫秒值字符串，其余的转换格式按
`SimpleDateFormat` 支持的形式进行设定即可，如 `yyyy-MM-dd HH:mm:ss`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_transFilter"> &lt;graphql:transFilter /> </TCol>
<TCol> xpl-fn:(filter, query, forEntity) => any </TCol><TCol> 过滤器转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

在<b>当前属性</b>上做过滤运算的过滤器均会被替换为该转换函数所构造的过滤器，从而简化复杂过滤条件的使用。
详细说明见 [XMeta 过滤器转换](#def_attr_props_prop_graphql_transFilter)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ui_maskPattern"> ui:maskPattern </TCol>
<TCol> string </TCol><TCol> 掩码模式 </TCol>
<TCol> 否 </TCol><TDesc>

GraphQL 返回的数据会自动按照其指定的模式调用 `StringHelper#maskPattern`
函数对<b>当前属性</b>的值做掩码处理，如，`ui:maskPattern="3*4"` 表示保留前 3 位以及后 4 位字符，
中间部分用 `*` 来代替。可应用于安全性要求较高的属性上。其将在 `x:post-extends`
阶段为<b>当前属性</b>自动生成
[&lt;transformOut />](#attr_props_prop_transformOut)（详见 Xpl 函数 `meta-gen:GenMaskingExpr`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_moduleId"> biz:moduleId </TCol>
<TCol> string </TCol><TCol> 关联对象所属的模块 </TCol>
<TCol> 否 </TCol><TDesc>

Nop 模块标识（如，`nop/auth`）。在<b>当前属性</b>关联的是其他模块的对象时，需要通过该属性指示该关联对象所属的模块

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_biz_codeRule"> biz:codeRule </TCol>
<TCol> string </TCol><TCol> 编码规则 </TCol>
<TCol> 否 </TCol><TDesc>

用于自动生成订单号、卡号等，该值不为空时，将在 `x:post-extends` 阶段为<b>当前属性</b>自动生成
[&lt;autoExpr />](#attr_props_prop_autoExpr)（详见 Xpl 函数 `meta-gen:GenCodeRuleAutoExpr`）。
详细说明见 [编码规则](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/biz/coderule.md)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_relation"> ext:relation </TCol>
<TCol> string </TCol><TCol> 关联映射到的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinLeftProp"> ext:joinLeftProp </TCol>
<TCol> string </TCol><TCol> 关联的源端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightProp"> ext:joinRightProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_ext_joinRightDisplayProp"> ext:joinRightDisplayProp </TCol>
<TCol> string </TCol><TCol> 关联的目标端对象的显示属性名 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 一对一](#relations-one-to-one)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_orm_manyToManyRefProp"> orm:manyToManyRefProp </TCol>
<TCol> string </TCol><TCol> 多对多关联的中间模型中另一方的属性名 </TCol>
<TCol> 否 </TCol><TDesc>

仅用于多对多关联，其指向在中间模型中用于映射对端模型的属性。
详细说明见 [XMeta 对象关联配置 - 多对多](#relations-many-to-many)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_queryMethod"> graphql:queryMethod </TCol>
<TCol> GraphQLQueryMethod </TCol><TCol> 关联过滤查询的名称 </TCol>
<TCol> 否 </TCol><TDesc>

用于指定关联过滤查询的返回结果类型。
详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_connectionProp"> graphql:connectionProp </TCol>
<TCol> prop-name </TCol><TCol> 关联过滤查询所指向的<b>当前对象</b>的属性 </TCol>
<TCol> 否 </TCol><TDesc>

详细说明见 [XMeta 对象关联配置 - 关联过滤查询](#relations-connection)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_authObjName"> graphql:authObjName </TCol>
<TCol> string </TCol><TCol> 关联过滤查询的数据权限模型名称 </TCol>
<TCol> 否 </TCol><TDesc>

指定在[关联过滤查询](#relations-connection)时所应用的数据权限模型。
默认为被过滤对象的 [BizModel](./xbiz) 名称。`IDataAuthChecker#getFilter`
将根据该数据权限模型生成额外的过滤条件，从而实现按行对数据进行访问控制

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_inputType"> &lt;graphql:inputType /> </TCol>
<TCol> class-name </TCol><TCol> GraphQL 输入参数类型的类全名 </TCol>
<TCol> 否 </TCol><TDesc>

以强类型方式定义
[GraphQL 输入参数](https://graphql.org/learn/queries/#arguments)，从而限定
[Field Selection](https://www.graphql-java.com/documentation/field-selection)
的可用参数并自动进行数据校验和类型转换。

例如，`GraphQLConnectionInput` 就被定义为[关联过滤查询](#relations-connection)的默认输入参数类型。

该类型的定义需满足以下条件：

- 在类上标注 `@GraphQLInput`；
- 各参数均需提供 getter 方法，并在方法上标注 `@PropMeta`；
- 在注解 `@PropMeta` 上按顺序递增设置 `propId` 的值；

**注**：该设置还未真正被使用，当前在 BizModel 中使用的是 `Map` 弱类型形式

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_maxFetchSize"> graphql:maxFetchSize </TCol>
<TCol> int </TCol><TCol> 当前<b>关联查询属性</b>一次查询所能取的最大数据量 </TCol>
<TCol> 否 </TCol><TDesc>

默认值为 `-1`。仅对**关联查询属性**有效，用于控制每次查询所能取得的最多数据，
前端指定的分页大小将被限制在该值及其以下。在其值小于或等于 `0` 时，则分页大小不能超过系统配置
`nop.graphql.max-page-size` 的设定值（默认为 `1000`）

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_filter"> &lt;graphql:filter /> </TCol>
<TCol> filter-bean </TCol><TCol> 当前<b>关联查询属性</b>的默认过滤条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的过滤条件。其将与前端设置的过滤条件以 `and` 方式组合

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_orderBy"> &lt;graphql:orderBy>&lt;field />&lt;/graphql:orderBy> </TCol>
<TCol> OrderFieldBean </TCol><TCol> 当前<b>关联查询属性</b>的默认排序条件 </TCol>
<TCol> 否 </TCol><TDesc>

仅对**关联查询属性**有效，用于设置关联对象的排序条件。其将与前端设置的排序条件组合在一起。
详细说明见 [实体排序条件列表](#def_attr_orderBy_field)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformIn"> &lt;transformIn /> </TCol>
<TCol> xpl </TCol><TCol> 输入数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

将接口调用回传的<b>当前对象属性</b>的值按该转换函数处理后，再赋值给当前对象。
比如，将提交的数据从逗号分隔的字符串转换为 `List<String>` 类型。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_transformOut"> &lt;transformOut /> </TCol>
<TCol> xpl </TCol><TCol> 输出数据转换函数 </TCol>
<TCol> 否 </TCol><TDesc>

NopGraphQL 将<b>当前对象属性</b>的值按该转换函数处理后，再返回给接口调用方。
比如，将 `List<String>` 类型数据转换为逗号分隔的字符串，或者将密码等敏感数据脱敏后再返回。
详细说明见 [XMeta 输入/输出转换](#data_transform_in_and_out)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_getter"> &lt;getter /> </TCol>
<TCol> xpl </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_setter"> &lt;setter /> </TCol>
<TCol> xpl </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_auth"> &lt;auth /> </TCol>
<TCol> ObjPropAuthModel </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

。详细说明见 [auth](#attr_props_prop_auth)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_arg"> &lt;arg /> </TCol>
<TCol> ObjPropArgModel </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

。详细说明见 [arg](#attr_props_prop_arg)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_autoExpr"> &lt;autoExpr /> </TCol>
<TCol> ObjConditionExpr </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

。详细说明见 [autoExpr](#attr_props_prop_autoExpr)

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_selection"> &lt;graphql:selection /> </TCol>
<TCol> field-selection </TCol><TCol> 默认的 GraphQL 字段选择集合 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
若<b>当前属性</b>映射的是一个对象，则可以配置该属性，用于指定默认的
[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addDispSelection`

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_graphql_jsonComponentProp"> graphql:jsonComponentProp </TCol>
<TCol> string </TCol><TCol> <b>当前属性</b>对应的 JSON 组件属性名 </TCol>
<TCol> 否 </TCol><TDesc>

**[XView Only]**
在<b>当前属性</b>为 JSON 文本时会自动构造一个 [&lt;schema />](#attr_props_prop_schema) 为
`JsonOrmComponent` 的对象属性，并赋值 `graphql:jsonComponentProp` 以指向该属性，从而建立起二者的关联。
**注**：目前仅在 XView 中构造 GraphQL Field Selection 会时用到，具体处理逻辑见
`XuiViewAnalyzer#addJsonComponent`

</TDesc></TRow>

</Table>

## XMeta 属性 Schema {#def_attr_props_prop_schema}

<Table head={['属性', '值类型', '属性名称', '必填']}>

<!-- -->

<TRow><TCol id="attr_props_prop_schema_domain"> domain </TCol>
<TCol> xml-name </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

<!-- -->

<TRow><TCol id="attr_props_prop_schema_stdDomain"> stdDomain </TCol>
<TCol> xml-name </TCol><TCol> </TCol>
<TCol> 否 </TCol><TDesc>

</TDesc></TRow>

</Table>

## XMeta 属性显示文本 {#def_attr_props_prop_graphql_labelProp}

在<b>当前对象</b>的属性对应的是数据字典，或者为[关联对象](#relations)的 ID 列表时，
可以在<b>当前对象</b>中定义一个作为其**显示文本**的属性，以便于在前端显示，再通过
`graphql:labelProp` 指向该显示文本属性，以建立二者之间的引用关系，比如：

```xml {4,10,11} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="status"
          graphql:labelProp="status_label"
    >
      <schema type="Integer" dict="auth/user-status"/>
    </prop>

    <prop name="status_label"
          graphql:dictValueProp="status"
          graphql:dictName="auth/user-status"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

在本例中，`status` 赋值的是数据字典 `auth/user-status` 的 `value`
值，其类型是 `Integer`，若在前端直接显示该属性值，则不方便用户进行识别，
因此，可以为 `status` 构建一个相应的<u>用于显示其对应数据字典的 `label`
文本</u>的属性 `status_label`。

NopGraphQL 引擎将会根据 `graphql:dictValueProp`
所指定的<b>当前对象</b>属性（即本例中的 `status`）的实际值，从 `graphql:dictName`
对应的数据字典（`auth/user-status`）中获取到字典枚举值的显示文本，
并将该文本内容作为 `status_label` 的值返回给前端。

前端仅需要在 GraphQL Field Selection 中包含 `status_label`
即可得到 `status` 对应的显示文本内容，从而避免前端单独处理对数据字典的文本回显：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    status
    status_label
  }
}
```

而对于[一对多/多对多](#relations-many-to-many)的对象关联场景中：

```xml {14} title="NopAuthUser.xmeta"
<meta>
  <props>
    <prop name="relatedRoleList"
          ext:kind="to-many"
          lazy="true"
    >
      <schema>
        <item bizObjName="NopAuthRole"/>
      </schema>
    </prop>

    <prop name="relatedRoleIdList"
          ext:relation="relatedRoleList"
          graphql:labelProp="relatedRoleList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.String&gt;"/>
    </prop>

    <prop name="relatedRoleList_label"
          lazy="true"
    >
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

可为关联目标端的主键（`id`）列表 `relatedRoleIdList` 构造一个对应的显示文本列表
`relatedRoleList_label`，而在 [Nop Orm](./orm) 层中将会在实体对象的
Java 代码中为属性 `relatedRoleList_label` 自动生成如下 getter 代码：

```java
  public String getRelatedRoleList_label() {
    return io.nop.core.lang.utils.Underscore.pluckThenJoin(
      getRelatedRoleList(),
      io.nop.auth.dao.entity.NopAuthRole.PROP_NAME_roleName
    );
  }
```

也就是，从关联目标端列表 `relatedRoleList` 中依次取其[显示属性](#attr_displayProp)（本例中为
`roleName`）的值，再以逗号 `,` 分隔组成字符串（`Underscore#pluckThenJoin`）后返回。

如此，前端便可以在获取关联目标端 id 列表的同时获取对应的显示文本列表：

```graphql {5,6}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleIdList
    relatedRoleIdList_label
  }
}
```

当然，在实际使用时也没有必要分别获取 id 及其显示文本列表，
直接返回关联对象列表及其必要属性，应该作为优先选择方案：

```graphql {5-8}
query {
  NopAuthUser_get(id: "1427826172") {
    id

    relatedRoleList {
      id
      roleName
    }
  }
}
```

## XMeta 过滤器转换 {#def_attr_props_prop_graphql_transFilter}

对<b>当前对象</b>的过滤可能会涉及较为复杂的组合条件（如，子查询等），或者是组合条件会出现多次，
亦或是直接拼接 SQL 片段，在这些情况下，便需要通过过滤器转换机制来实现。

过滤器转换机制就是通过一个转换函数，对过滤器（其为 `TreeBean`
类型）的树形结构上的节点（子过滤器）进行替换。

> 具体的转换逻辑见 `io.nop.api.core.beans.query.QueryBean#transformFilter`。

在 XMeta 中仅需要定义一个配置了过滤器转换函数 `graphql:transFilter`
的[对象属性](#def_attr_props_prop)即可，例如：

```xml {3,9,16} title="NopAuthSite.xmeta"
<meta>
  <x:gen-extends>
    <meta-gen:DefaultMetaGenExtends xpl:lib="/nop/core/xlib/meta-gen.xlib"/>
  </x:gen-extends>

  <props>
    <!-- Note：只有可查询（queryable = true）的属性才能参与过滤运算 -->
    <prop name="hasResourceStatus" queryable="true">
      <graphql:transFilter>
        <filter:sql>
          exists (
            select o2
            from NopAuthResource o2
            where
              o2.siteId = o.id
              and o2.status >= ${ filter.getAttr('value') }
          )
        </filter:sql>
      </graphql:transFilter>
    </prop>
  </props>
</meta>
```

在该例中，为对象属性 `hasResourceStatus` 配置了过滤器转换函数，其通过 Xpl 函数
`filter:sql` 构造了一个包含 SQL 片段的子过滤器，用于替换以 `hasResourceStatus`
作为运算条件的过滤器，并且，在该 SQL 片段中还以 `${ filter.getAttr('value') }`
形式引用了被替换过滤器的属性 `value` 的值。

> 注意，Xpl 函数 `meta-gen:DefaultMetaGenExtends` 会在
> XMeta 解析前全局引入 `filter:sql` 所在的函数库
> `/nop/core/xlib/filter.xlib`（即 `<c:import from="/nop/core/xlib/filter.xlib"/>`），
> 因此，不需要再在 `<filter:sql/>` 节点上配置
> `xpl:lib` 属性（即 `<filter:sql xpl:lib="/nop/core/xlib/filter.xlib"/>`）。

在调用对应的 GraphQL 接口时，可以构造如下形式的根过滤器 `filter`：

<!-- prettier-ignore -->
```json {10} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "and",
      "$body": [
        {
          "$type": "gt", "name": "orderNo", "value": 100
        },
        {
          "$type": "eq", "name": "hasResourceStatus", "value": 1
        }
      ]
    }
  }
}
```

以上调用最终生成的 SQL 如下：

```sql {5-10}
select o
from NopAuthSite o
where
  o.orderNo > 100 and
  exists (
    select o2
    from NopAuthResource o2
    where o2.siteId = o.id
    and o2.status >= 1
  )
```

也就是，以 `hasResourceStatus` 作为运算条件的过滤器均会被替换为
`graphql:transFilter` 所构造出的过滤器。

`graphql:transFilter` 的类型是 `xpl-fn`，即，一个 Xpl 函数，其函数签名为
`(filter, query, forEntity) => XNode`，函数参数分别为：

- `filter`：类型为 `TreeBean`，表示将要被替换的过滤器，即上例中的
  `{"$type": "eq", "name": "hasResourceStatus", "value": 1}`；
- `query`：类型为 `QueryBean`，对应于 GraphQL 接口中的 `query` 参数；
- `forEntity`：类型为 `Boolean`，始终为 `false`；

> `graphql:transFilter` 的执行逻辑见 `io.nop.biz.crud.BizQueryHelper#transformFilter`。

`graphql:transFilter` 函数的返回值类型为 `XNode`，在构造该 `XNode` 时可以通过
`${...}` 引用该函数的参数，比如，前例中的 `${ filter.getAttr('value') }`
表示从参数 `filter` 中取其属性名为 `value` 的值（即，`1`）。

> 在 `TreeBean` 中除了属性 `$type` 是通过 `TreeBean#getTagName`
> 获取值以外，其余的属性均通过 `TreeBean#getAttr` 获取属性值。

由于 `graphql:transFilter` 函数的返回值是 `XNode` 节点，因此，除了通过
`filter:sql` 构造 SQL 过滤节点以外，还可以直接构造 EQL 过滤节点，甚至是二者共用：

```xml {3,4,12}
    <prop name="withOrderNoAndResourceStatus" queryable="true">
      <graphql:transFilter>
        <and xpl:outputMode="node">
          <gt name="orderNo" value="${ filter.getAttr('orderNo') }"/>

          <filter:sql>
            exists (
              select o2
              from NopAuthResource o2
              where
                o2.siteId = o.id
                and o2.status >= ${ filter.getAttr('resourceStatus') }
            )
          </filter:sql>
        </and>
      </graphql:transFilter>
    </prop>
```

> - `graphql:transFilter` 本身不支持输出，所以，需要在其标签内通过输出模式
>   `xpl:outputMode` 为 `node` 的 Xpl 脚本输出一个 `XNode` 节点；

在前端仅需要构造一个如下的过滤器即可得到与前面例子相同的过滤条件：

<!-- prettier-ignore -->
```json title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

注意，在该过滤器中不再设置 `value` 属性，而是分别指定了两个混合过滤器所需的参数
`orderNo` 和 `resourceStatus`，并调用 `TreeBean#getAttr` 获得了过滤器的传入值。

可以发现，虽然上面的过滤器传入了两个附加参数，但依然采用的是 `eq` 运算符。
这是因为，在属性定义上，默认的 `allowFilterOp`（允许的过滤运算）仅有 `eq` 和 `in`。
若是需要采用其他运算符，则需要显式设置 `allowFilterOp`，比如：

```xml {3}
    <prop name="withOrderNoAndResourceStatus"
          queryable="true"
          allowFilterOp="with"
    >
      <graphql:transFilter>
        <!-- ... -->
      </graphql:transFilter>
    </prop>
```

然后，构造过滤器为：

<!-- prettier-ignore -->
```json {4} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "with",
      "name": "withOrderNoAndResourceStatus",
      "orderNo": 100,
      "resourceStatus": 1
    }
  }
}
```

此外，`filter` 实际所使用的运算符可以通过 `filter.getTagName()` 得到，
所以，在某些动态场景下，还可以根据实际使用的运算符来构造不同的过滤器：

```xml {7,18}
    <prop name="resourceStatus"
          queryable="true"
          allowFilterOp="eq,in"
    >
      <graphql:transFilter>
        <c:choose xpl:outputMode="node">
          <when test="${ filter.getTagName() == 'eq' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status = ${ filter.getAttr('value') }
              )
            </filter:sql>
          </when>
          <when test="${ filter.getTagName() == 'in' }">
            <filter:sql>
              exists (
                select o2
                from NopAuthResource o2
                where
                  o2.siteId = o.id
                  and o2.status in (${ filter.getAttr('value') })
              )
            </filter:sql>
          </when>
          <otherwise>
            <!-- Note：若不做任何处理，则会删除待替换的过滤器 filter -->
            <c:throw
                errorCode="nop.err.xmeta.trans-filter.not-supported-op"
                params="${ {name: filter.getAttr('name'), op: filter.getTagName()} }"
            />
            <!-- 直接返回待替换的过滤器 filter，不做替换或删除 -->
            <!--<c:script>filter</c:script>-->
          </otherwise>
        </c:choose>
      </graphql:transFilter>
    </prop>
```

> 在涉及多分支判断时，不能采用 `c:if` 或 `xpl:if` 做分支处理，否则
> `graphql:transFilter` 将返回最后一个 if 分支的结果，若该分支不满足判断条件，则实际将返回
> `null`，而不是满足判断条件的分支结果。

如此，便可以按需使用 `eq` 或 `in` 过滤器来进行过滤查询：

<!-- prettier-ignore -->
```json {4,12} title="POST /r/NopAuthSite__findPage"
{
  "query": {
    "filter": {
      "$type": "eq", "name": "resourceStatus", "value": 1
    }
  }
}
// 或者
{
  "query": {
    "filter": {
      "$type": "in", "name": "resourceStatus", "value": [1, 2, 3]
    }
  }
}
```

## XMeta 对象关联配置 {#relations}

### 一对一 {#relations-one-to-one}

```plantuml
class Left {
  + id: int
  + rightId: int
  + right: Right
}

class Right {
  + id: int
  + displayName: string
}

Left "1" -right-> "1" Right
```

根据以上图例所生成的 XMeta 为：

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

- `ext:relation` 用在 `Left`（关联的源端）直接与关联目标端（`Right`）建立关联的属性上，
  其指向在 `Left` 中与映射到关联目标端对象的属性上，如，`rightId -> right`；
- 在与关联目标端对象映射的属性上声明关联关系，包括：`ext:kind`、`ext:joinLeftProp`、`ext:joinRightProp` 等；
- `ext:kind` 设置为 `to-one`（一对一）模式关联 `Right`；
- `ext:joinLeftProp` 表示在 `Left`（关联的源端）中用于与 `Right`（关联的目标端）建立关联的属性；
- `ext:joinRightProp` 表示在 `Left`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
  `Right`（关联的目标端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Right`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 一对多 {#relations-one-to-many}

> 注意，一对多和一对一是互为反方向的关联配置，因此，二者是分别配置在关联的源端和目标端中的。

```plantuml
class Left {
  + id: int
  + rightId: int
  + displayName: string
}

class Right {
  + id: int
  + leftList: List<Left>
}

Right "1" -left-> "0..*" Left
```

根据以上图例所生成的 XMeta 为：

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftList"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          ext:joinRightDisplayProp="displayName"
          lazy="true"
    >
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
  </props>
</meta>
```

- `ext:kind` 设置为 `to-many`（一对多）模式关联 `Left`；
- `ext:joinRightProp` 表示在 `Left`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
- `ext:joinLeftProp` 表示在 `Left`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
  `Right`（关联的源端）的属性；
- `ext:joinRightDisplayProp` 表示关联目标端（`Left`）用于显示对象名称的属性（显示名），如，`displayName`；
- 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 多对多 {#relations-many-to-many}

在 Nop 中是通过中间模型来建立多对多的关联，并通过中间模型将多对多分解为中间模型与关联双方的一对多关联：

> 详细的说明文件见 [多对多关联](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/orm/many-to-many.md)。

```plantuml
class Left {
  + id: int
  + rightMappings: List<Ref>
}

map Ref {
  leftId => rightId
}

class Right {
  + id: int
  + leftMappings: List<Ref>
}

Ref "1" -left-> "1" Left::id
Ref "1" -right-> "1" Right::id
```

根据以上图例所生成的 XMeta 分别为：

- 配置 `Left` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Right`

```xml title="Left.xmeta"
<meta>
  <props>
    <prop name="rightMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="leftId"
          orm:manyToManyRefProp="rightId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedRightIdList"
          ext:relation="relatedRightList"
          graphql:labelProp="relatedRightList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedRightList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Right"/>
      </schema>
    </prop>
    <prop name="relatedRightList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Left`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Left`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Right`（即，多对多的目标端模型）建立关联的属性；
> - `relatedRightList` 和 `relatedRightIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Left` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Right` 与 `Ref` 的一对多关联，也就是，通过 `Ref` 可以获取到关联上的多个 `Left`

```xml title="Right.xmeta"
<meta>
  <props>
    <prop name="leftMappings"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="rightId"
          orm:manyToManyRefProp="leftId"
          lazy="true"
    >
      <schema>
        <item bizObjName="Ref"/>
      </schema>
    </prop>

    <prop name="relatedLeftIdList"
          ext:relation="relatedLeftList"
          graphql:labelProp="relatedLeftList_label"
          lazy="true"
    >
      <schema type="List&lt;java.lang.Integer&gt;"/>
    </prop>
    <prop name="relatedLeftList" ext:kind="to-many" lazy="true">
      <schema>
        <item bizObjName="Left"/>
      </schema>
    </prop>
    <prop name="relatedLeftList_label" lazy="true">
      <schema type="String"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-many`（一对多）模式关联 `Ref`；
> - `ext:joinRightProp` 设置为在 `Ref`（关联的目标端）中用于与 `Right`（关联的源端）建立关联的属性；
> - `ext:joinLeftProp` 设置为在 `Ref`（关联的目标端）中对应的 `ext:joinRightProp` 所指向的
>   `Right`（关联的源端）的属性；
> - `orm:manyToManyRefProp` 设置为在 `Ref` 中用于与 `Left`（即，多对多的目标端模型）建立关联的属性；
> - `relatedLeftList` 和 `relatedLeftIdList` 为根据 `orm:manyToManyRefProp`
>   在 `Right` 模型上自动生成的属性，以便于直接获取多对多关联中的对端的对象和对象 `id` 列表；
> - `ext:relation` 参考[一对一](#relations-one-to-one)的说明；
> - `graphql:labelProp` 的配置说明见 [XMeta 属性显示文本](#def_attr_props_prop_graphql_labelProp)；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

- 配置 `Ref` 与 `Left` 和 `Right` 的一对一关联

```xml title="Ref.xmeta"
<meta>
  <props>
    <prop name="leftId" ext:relation="left">
      <schema type="java.lang.Integer"/>
    </prop>
    <prop name="rightId" ext:relation="right">
      <schema type="java.lang.Integer"/>
    </prop>

    <prop name="left"
          ext:kind="to-one"
          ext:joinLeftProp="leftId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Left"/>
    </prop>
    <prop name="right"
          ext:kind="to-one"
          ext:joinLeftProp="rightId"
          ext:joinRightProp="id"
          lazy="true"
    >
      <schema bizObjName="Right"/>
    </prop>
  </props>
</meta>
```

> - `ext:kind` 设置为 `to-one`（一对一）模式关联 `Left` 或 `Right`；
> - `ext:joinLeftProp` 表示在 `Ref`（关联的源端）中用于与关联目标端（`Left` 或 `Right`）建立关联的属性；
> - `ext:joinRightProp` 表示在 `Ref`（关联的源端）中对应的 `ext:joinLeftProp` 所指向的
>   关联目标端（`Left` 或 `Right`）的属性；
> - `ext:relation` 用在 `Ref`（关联的源端）直接与关联目标端（`Left` 或 `Right`）建立关联的属性上，
>   其指向在 `Ref` 中与映射到关联目标端对象的属性上，如，`leftId -> left`、`rightId -> right`；
> - 非必要情况，对关联目标对象的加载方式默认均为懒加载，即，`lazy="true"`；

### 关联过滤查询 {#relations-connection}

> 详细的说明请参考：
>
> - [Connection 配置](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/graphql/connection.md)
> - [Nop 入门：如何实现复杂查询](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/simple/4-complex-query.md)
> - [如何实现对列表列表数据的过滤](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/recipe/filter-list.md)

:::tip

NopGraphQL 的 `DataFetcher` 机制会在获得主查询的结果后，
再逐条进行子查询，因此可能会出现明显的性能问题，在性能问题较明显时，需考虑在
[@SqlLibMapper](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/dev-guide/orm/sql-lib.md)
中做自定义查询或者采用按需加载机制。

:::

NopGraphQL 引擎提供 `DataFetcher` 机制，可以通过 `OrmEntityPropConnectionFetcher`
实现按需对关联对象进行过滤和排序，比如，按指定条件 `filter` 过滤出 `NopAuthSite`
的资源列表 `resourcesList`：

```graphql {6}
query($filter: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    resourcesList(filter: $filter, limit: 10, offset: 0) {
      total
      items {
        id
        displayName
      }
    }
  }
}

variables:
  filter: {
    "$type": "or",
    "$body": [
      { "$type": "eq", "status", 1},
      { "$type": "eq", "status", 2}
    ]
  }
```

则只需要在 `NopAuthSite.xmeta` 中为其对象属性 `resourcesList` 设置
`graphql:queryMethod`，将其定义为**关联查询属性**：

```xml {3,6,12} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="id"/>

    <prop name="resourcesList"
          graphql:queryMethod="findPage"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:filter>
        <eq name="siteId" value="@prop-ref:id"/>
      </graphql:filter>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

> - `<schema bizObjName="NopAuthResource"/>` 指示了关联对象（即，资源列表）的类型为 `NopAuthResource`；
> - `graphql:filter` 则用于指定关联查询的过滤条件，`@prop-ref:` 前缀表示从<b>当前对象</b>上获取属性值，
>   本例表示，过滤出 `NopAuthResource#siteId` 与<b>当前对象</b>上的属性 `id` 的值相等的数据；
> - `graphql:orderBy` 则指定了查询结果的排序条件，本例表示，按属性 `NopAuthResource#orderNo` 升序排序；
> - 前端传入的 `filter` 和 `orderBy` 参数不会覆盖对 `graphql:filter` 与 `graphql:orderBy`
>   的默认配置，而是会被组合在一起后，再进行过滤和排序；

属性 `graphql:queryMethod` 的可选值如下（具体实现参考 `io.nop.graphql.orm.fetcher.OrmEntityPropConnectionFetcher#get`）：

- `findCount`：返回 `long` 类型数据，表示符合过滤条件的数据总量；
- `findFirst`：返回关联对象类型数据，表示查询结果中的第一条对象数据；
- `findList`：返回 `List` 类型数据，表示查询结果中的全部对象数据；
- `findPage`：返回 `PageBean` 类型数据，表示指定分页的对象数据；
- `findConnection`：返回 `GraphQLConnection` 类型数据，表示指定分页的对象数据；

虽然关联查询的返回结果类型与指定的 `graphql:queryMethod` 相关，但其输入参数类型都是
`GraphQLConnectionInput`，如，`resourcesList(filter: $filter, limit: 10, offset: 0)`
中的括号内的部分既是 `GraphQLConnectionInput` 的各项属性配置。

关联过滤查询并不需要<b>当前对象</b>和关联对象在 ORM 层面存在确切的关联关系，
即使二者没有直接关联关系，甚至可以不在同一数据库中，也能够进行关联过滤查询，只需要通过
`graphql:filter` 指定相应的关联过滤条件即可。

而若是二者在 ORM 层面定义了一对一（`ext:kind="to-one"`）或一对多（`ext:kind="to-many"`）的关联关系，
则可以设置属性 `graphql:connectionProp` 指向对应的关联属性，从而按二者的关联关系自动推导
`graphql:filter` 的配置，如：

```xml {3,14} title="NopAuthSite.xmeta"
<meta>
  <props>
    <prop name="resources"
          ext:kind="to-many"
          ext:joinLeftProp="id"
          ext:joinRightProp="siteId"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>
    </prop>

    <prop name="resourcesConnection"
          graphql:queryMethod="findPage"
          graphql:connectionProp="resources"
          lazy="true"
    >
      <schema bizObjName="NopAuthResource"/>

      <graphql:orderBy>
        <field name="orderNo" desc="false"/>
      </graphql:orderBy>
    </prop>
  </props>
</meta>
```

也就是，`resourcesConnection` 在查询时会根据 `graphql:connectionProp`
指向的 `resources` 属性的一对多关联自动推导得到过滤条件 `NopAuthResource#siteId = ${id}`。
而若是在 `resourcesConnection` 中再配置 `graphql:filter`，
则表示在已推导得到的过滤条件的基础上再补充额外的过滤条件。

此外，定义的**关联查询属性**（前例中的 `resourcesList` 或 `resourcesConnection`）是可以复用的，利用
GraphQL 的[别名](https://graphql.org/learn/queries/#aliases)机制，
可以实现用同一个关联查询属性返回不同的查询结果：

```graphql {6,13}
query ($filter1: Map, $filter2: Map) {
  NopAuthSite_get(id: "main") {
    id
    displayName

    activeResources: resourcesList(filter: $filter1, limit: 10, offset: 0) {
      items {
        id
        displayName
      }
    }

    inactiveResources: resourcesList(filter: $filter2, limit: 10, offset: 20) {
      items {
        id
        displayName
      }
    }
  }
}
```

## XMeta 输入/输出转换 {#data_transform_in_and_out}

### 输入转换 {#data_transform_in}

为了适配组件规范或者方便用户输入等原因，客户端可能会将本身为列表类型的数据，
采用分隔符拼接为字符串后再提交给服务端，在这种情况下，
屏蔽客户端与服务端之间数据结构差异的最好方式就是对提交数据做**输入转换**，
从而确保在处理业务逻辑时无需关注客户端的变化。

在 XMeta 中可以通过 `<transformIn />` 配置相应的**输入转换函数**，
从而将客户端的输入数据转换为服务端需要的结构，例如，将以 `,` 分隔的
`types` 字符串转换为字符串数组：

```xml {5-7}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>
    </prop>
  </props>
</meta>
```

该输入转换函数的可用参数如下（该函数的调用逻辑见 `ObjMetaBasedValidator#transformIn`）：

- `data`: `Map` 类型，其为客户端提交的全部输入数据；
- `value`: 其为<b>当前对象属性</b>对应的待转换输入数据。可能为 `null`；
- `transData`: `Map` 类型，其包含当前已处理的输入数据，其将被用于构造出<b>当前对象</b>；
- `propMeta`: `IObjPropMeta` 类型，其为<b>当前对象属性</b>的[结构](#def_attr_props_prop)；

在 `<transformIn />` 标签内可以编写任意
[Xpl](https://gitee.com/canonical-entropy/nop-entropy/tree/master/docs/dev-guide/xlang/xpl.md)
标签，或者直接编写
[XScript](https://gitee.com/canonical-entropy/nop-entropy/tree/master/docs/dev-guide/xlang/xscript.md)
脚本，仅需要确保最后一段的执行逻辑会返回转换后的值即可：

```xml {5}
<meta>
  <props>
    <prop name="types">
      <transformIn>
        return value?.split(',');
      </transformIn>
    </prop>
  </props>
</meta>
```

### 输出转换 {#data_transform_out}

输出转换可以视为[输入转换](#data_transform_in)的逆过程，
也就是，将服务端输出的数据转换为客户端所接受的数据格式：

```xml {5-9}
<meta>
  <props>
    <prop name="types">
      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

不过，与 `<transformIn />` 不同的是，`<transformOut />` 采用的是
NopGraphQL 的 `DataFetcher` 机制进行调用的，其转换逻辑由
`EvalActionTransformFetcher` 执行。

输出转换函数可访问的参数如下：

- `entity`: 其为<b>当前对象</b>自身；
- `value`: 其为<b>当前对象属性</b>的值，也就是待转换的输出数据。可能为 `null`；

### 自动转换 {#data_transform_auto}

得益于 Nop 内置的 `x:post-extends` 元编程机制，在 XMeta 中可以引入 Xpl 函数
`meta-gen:DefaultMetaPostExtends`：

```xml {9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>
</meta>
```

该函数将会根据 [XMeta 属性 Schema](#def_attr_props_prop_schema)
上设置的 [domain](#attr_props_prop_schema_domain)
或 [stdDomain](#attr_props_prop_schema_stdDomain)，从
`/nop/core/xlib/meta-prop.xlib` 中查找名称为 `domain-{domain}`
或 `domain-{stdDomain}` 的 Xpl 函数，并自动将该函数生成的 `XNode`
合并到<b>当前属性</b>节点上（处理逻辑见 Xpl 函数 `meta-gen:GenPropForDomain`）。

假设，将前面的例子中的属性 `types` 的 Schema Domain 设置为 `comma-list`：

```xml {3,9}
<meta>
  <x:post-extends>
    <meta-gen:DefaultMetaPostExtends
        xpl:lib="/nop/core/xlib/meta-gen.xlib" />
  </x:post-extends>

  <props>
    <prop name="types">
      <schema domain="comma-list" />
    </prop>
  </props>
</meta>
```

然后，通过 Nop delta 机制，在 `/nop/core/xlib/meta-prop.xlib`
中添加函数 `domain-comma-list`（即命名为 `domain-{domain}` 形式）：

```xml {12} title="/_vfs/_delta/default/nop/core/xlib/meta-prop.xlib"
<lib xmlns:x="/nop/schema/xdsl.xdef"
      x:schema="/nop/schema/xlib.xdef"
      x:extends="super"
>
  <tags>
    <domain-comma-list outputMode="node">
      <attr name="propNode"/>

      <source>
        <prop name="${propNode.getAttr('name')}">
          <!-- type 为客户端所接受的类型 -->
          <schema type="String"/>

          <transformIn>
            <c:script><![CDATA[
              return value?.split(',');
            ]]]></c:script>
          </transformIn>

          <transformOut>
            <c:script><![CDATA[s
              import java.lang.String;

              return value ? String.join(',', value) : null;
            ]]]></c:script>
          </transformOut>
        </prop>
      </source>
    </domain-comma-list>
  </tags>
</lib>
```

最终，生成的 `types` 属性的结构如下：

```xml
<meta>
  <props>
    <prop name="types">
      <schema type="String"/>

      <transformIn>
        <c:script><![CDATA[
          return value?.split(',');
        ]]]></c:script>
      </transformIn>

      <transformOut>
        <c:script><![CDATA[
          import java.lang.String;

          return value ? String.join(',', value) : null;
        ]]]></c:script>
      </transformOut>
    </prop>
  </props>
</meta>
```

此外，对于配置了掩码模式 [ui:maskPattern](#attr_props_prop_ui_maskPattern)
的属性，也会由 Xpl 函数 `meta-gen:GenMaskingExpr` 自动构造并生成如下输出转换函数：

```xml {3,5}
<meta>
  <props>
    <prop name="mobile" ui:maskPattern="3*4">
      <transformOut>
        return value?.toString()?.$maskPattern("3*4");
      </transformOut>
    </prop>
  </props>
</meta>
```

## XMeta 解析 {#parser}
