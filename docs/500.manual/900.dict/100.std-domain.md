---
title: 标准数据域
description: 关于标准数据域的字典项说明
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import Header from '@site/docs/\_header.md';
import {NopDocLink, NopVfsLink} from '@site/docs/NopLink';

<Header />

## 前言 {#preface}

标准数据域的枚举值定义在 <NopVfsLink module="nop-xlang" path="/dict/core/std-domain.dict.yaml" />
中，但其并不完整，完整的可选值详见 `XDefConstants` 中以 `STD_DOMAIN_` 开头的常量值。

对标准数据域字典项的解析和校验在
`SimpleStdDomainHandlers`、`XplStdDomainHandlers`、`ConverterStdDomainHandler`
等中实现，并通过 `StdDomainRegistry#registerStdDomainHandler` 进行注册。

在 `nop-xlang` 模块中已注册的数据域详见 `StdDomainRegistry#registerDefaults`，
本手册所收录的数据域便来自于此。若是需要自定义数据域，
可参考[《XDef - 注册并使用属性类型》](../xlang/xdef#appendix_register_and_use_attr_type)编写代码。

## 数据域 {#opts}

### any {#opt_any}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> any </TCol><TCol>

`java.lang.Object`

</TCol><TDesc>

接受任意类型的源数据，并保持不变，不对其做类型转换。

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#ANY`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### string {#opt_string}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> string </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

通过 `ConvertHelper#toString` 按如下规则将源数据转换为 `String` 类型：

- `null` 值不做转换，直接返回 `null`；
- `MonthDay` 类型数据通过 `ConvertHelper#monthDayToString`
  转换为 `MM-dd` 形式的字符串，如 `12-08`；
- `LocalDateTime` 类型数据通过 `ConvertHelper#localDateTimeToString`
  转换为 `yyyy-MM-dd HH:mm:ss` 形式的字符串，如 `2025-06-05`；
- 其他类型数据直接调用其 `#toString()` 函数得到对应的字符串；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#STRING`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### boolean {#opt_boolean}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> boolean </TCol><TCol>

`java.lang.Boolean`

</TCol><TDesc>

通过 `ConvertHelper#toBoolean` 按如下规则将源数据转换为 `Boolean` 类型：

- `null` 值不做转换，直接返回 `null`；
- `Boolean` 不做转换，直接返回原值；
- `Integer`、`Long`、`Number` 类型数据不为 `0` 时，返回 `true`，否则，返回 `false`；
- `String` 类型数据通过 `ConvertHelper#stringToBoolean` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - `1`、`true`、`Y`、`y` 对应为 `true`；
  - `0`、`false`、`N`、`n` 对应为 `false`；
  - 其他字符抛出转换异常；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#BOOLEAN`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### boolFlag {#opt_boolFlag}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> boolFlag </TCol><TCol>

`java.lang.Byte`

</TCol><TDesc>

通过 `ConvertHelper#toByte` 按如下规则将源数据转换为 `Byte` 类型：

- `null` 值不做转换，直接返回 `null`；
- `Boolean` 不做转换，直接返回原值；
- `Number` 类型数据调用其 `#byteValue()` 得到结果；
- `Boolean` 类型数据通过 `ConvertHelper#booleanToByte` 按以下规则进行转换：
  - `true` 对应为 `1`；
  - `false` 对应为 `0`；
- `String` 类型数据通过 `ConvertHelper#stringToByte` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - 调用 `ConvertHelper#stringToShort` 将字符串转换为 `Short`，再由
    `Short#byteValue()` 得到结果，若转换失败，则抛出转换异常；
- 其他类型数据抛出转换异常；

**注**：其由 `SimpleStdDomainHandlers.BoolFlagType` 对源数据做类型转换。

</TDesc></TRow>

</Table>

### date {#opt_date}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> date </TCol><TCol>

`java.time.LocalDate`

</TCol><TDesc>

通过 `ConvertHelper#toLocalDate` 按如下规则将源数据转换为 `LocalDate` 类型：

- `null` 值不做转换，直接返回 `null`；
- `LocalDate` 不做转换，直接返回原值；
- `LocalDateTime` 类型数据调用其 `#toLocalDate()` 得到结果；
- `Timestamp` 类型数据通过 `ConvertHelper#timestampToLocalDate` 按以下规则进行转换：
  - 调用 `Timestamp#toLocalDateTime().toLocalDate()` 得到结果；
- `Date`、`Long` 类型数据通过 `ConvertHelper#millisToLocalDate` 按以下规则进行转换：
  - 通过 `Calendar` 将毫秒值转换为 `LocalDate`；
- `String` 类型数据通过 `ConvertHelper#stringToLocalDate` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - 若为纯数字，则将其转为 `Long` 后再通过 `ConvertHelper#millisToLocalDate` 进行转换；
  - 按形式 `yyyy-MM-dd` 做 `LocalDate` 解析和转换，若字符串为 `yyyy-MM-dd 00:00:00`
    形式，则会在去掉 ` 00:00:00` 后再做转换；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#DATE`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### time {#opt_time}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> time </TCol><TCol>

`java.time.LocalTime`

</TCol><TDesc>

通过 `ConvertHelper#toLocalTime` 按如下规则将源数据转换为 `LocalTime` 类型：

- `null` 值不做转换，直接返回 `null`；
- `LocalTime` 不做转换，直接返回原值；
- `String` 类型数据通过 `ConvertHelper#stringToLocalTime` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - 按形式 `HH:mm:ss` 做 `LocalTime` 解析和转换；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#TIME`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### datetime {#opt_datetime}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> datetime </TCol><TCol>

`java.time.LocalDateTime`

</TCol><TDesc>

通过 `ConvertHelper#toLocalDateTime` 按如下规则将源数据转换为 `LocalDateTime` 类型：

- `null` 值不做转换，直接返回 `null`；
- `LocalDateTime` 不做转换，直接返回原值；
- `LocalDate` 类型数据由 `LocalDateTime#of` 对其时分秒补零后得到结果；
- `Timestamp` 类型数据通过 `ConvertHelper#timestampToLocalDateTime` 按以下规则进行转换：
  - 调用 `Timestamp#toLocalDateTime` 得到结果；
- `Date` 类型数据通过 `ConvertHelper#millisToLocalDateTime` 按以下规则进行转换：
  - 将毫秒值转换为 `Timestamp` 后，再调用 `Timestamp#toLocalDateTime` 得到结果；
- `String` 类型数据通过 `ConvertHelper#stringToLocalDateTime` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - 若为纯数字，则将其转为 `Long` 后再通过 `ConvertHelper#millisToLocalDateTime` 进行转换；
  - 若为 `yyyy-MM-dd` 形式，则通过 `ConvertHelper#stringToLocalDate`
    将其转换为 `LocalDate`，再调用 `LocalDate#atStartOfDay()` 得到结果；
  - 按形式 `yyyy-MM-dd HH:mm:ss`、`yyyy-MM-ddTHH:mm:ss.SSSZ`
    或 `yyyy-MM-ddTHH:mm:ss` 做 `LocalDateTime` 解析和转换；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#DATETIME`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### timestamp {#opt_timestamp}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> timestamp </TCol><TCol>

`java.sql.Timestamp`

</TCol><TDesc>

通过 `ConvertHelper#toTimestamp` 按如下规则将源数据转换为 `Timestamp` 类型：

- `null` 值不做转换，直接返回 `null`；
- `Timestamp` 不做转换，直接返回原值；
- `Long`、`Date` 类型数据作为毫秒值构造 `Timestamp`；
- `LocalDateTime` 类型数据通过 `ConvertHelper#localDateTimeToTimestamp` 按以下规则进行转换：
  - 调用 `Timestamp#valueOf(LocalDateTime)` 得到结果；
- `LocalDate` 类型数据通过 `ConvertHelper#localDateToTimestamp` 按以下规则进行转换：
  - 由 `LocalDateTime#of` 对其时分秒补零后，再调用
    `ConvertHelper#localDateTimeToTimestamp` 得到结果；
- `String` 类型数据通过 `ConvertHelper#stringToTimestamp` 按以下规则进行转换：
  - 空字符串对应为 `null`；
  - 若为纯数字，则将其转为 `Long` 后，作为毫秒值构造 `Timestamp`；
  - 若为 `yyyy-MM-dd` 形式，则通过 `ConvertHelper#stringToLocalDate`
    将其转换为 `LocalDate`，再调用 `LocalDate#atStartOfDay()` 得到
    `LocalDateTime`，最后，由 `ConvertHelper#localDateTimeToTimestamp` 转换得到结果；
  - 按形式 `yyyy-MM-dd HH:mm:ss`、`yyyy-MM-ddTHH:mm:ss.SSSZ`
    或 `yyyy-MM-ddTHH:mm:ss` 做 `LocalDateTime` 解析和转换，最后，由
    `ConvertHelper#localDateTimeToTimestamp` 转换得到结果；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#TIMESTAMP`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### duration {#opt_duration}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> duration </TCol><TCol>

`java.time.Duration`

</TCol><TDesc>

通过 `ConvertHelper#toDuration` 按如下规则将源数据转换为 `Duration` 类型：

- `null` 值不做转换，直接返回 `null`；
- `Duration` 不做转换，直接返回原值；
- `String` 类型数据通过 `ConvertHelper#stringToDuration` 按以下规则进行转换：
  - 空白字符串对应为 `null`；
  - 若为纯数字，则将其转为 `Long` 后，作为毫秒值构造 `Duration`；
  - 若为 `数字+后缀` 形式，如 `123s`，则按不同后缀构造相应的毫秒或纳秒（仅针对
    `ns` 和 `us` 后缀）`Duration`。可选后缀为：
    - `ns`（纳秒）、`us`（微秒）、`ms`（毫秒）、`s`（秒）、`m`（分）、`h`（时）、`d`（天）
  - 若为 `PnDTnHnMn.nS` 形式（`n` 可替换为任意数字），如 `P2DT3H4M20.345S`（表示
    `2 days, 3 hours and 4 minutes 20.345 seconds`），
    其由 `Duration#parse` 解析得到结果；
  - 其他字符抛出转换异常；
- 其他类型数据抛出转换异常；

**注**：其由 `ConverterStdDomainHandler` 调用 `StdDataType#DURATION`
对应的转换器对源数据做类型转换。

</TDesc></TRow>

</Table>

### generic-type {#opt_generic_type}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> generic-type </TCol><TCol>

`io.nop.core.type.IGenericType`

</TCol><TDesc>

Java 泛型类型，解析得到 `IGenericType` 类型。
例如 `List<String>`、`Map<String, io.nop.auth.entity.NopAuthUser>` 等。
除了 Java 内置的 `String`、`Object`、`List`、`Map`、`Long` 等基础类型之外，
其他类名都需要使用全类名引用

</TDesc></TRow>

</Table>

### class-name {#opt_class_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> class-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由 [package-name](#opt_package_name)
和 [java-name](#opt_java_name) 组成，并以 `.` 分隔

</TDesc></TRow>

</Table>

### class-name-set {#opt_class_name_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> class-name-set </TCol><TCol>

`java.util.Set<String>`

</TCol><TDesc>


</TDesc></TRow>

</Table>

### package-name {#opt_package_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> package-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由 `.` 号分隔，不包含除 `$` 之外的特殊字符。
按照 Java 规范一般应为全小写字符

</TDesc></TRow>

</Table>

### java-name {#opt_java_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> java-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

一般为中英文字母和数字、`_` 组成，与
[var-name](#opt_var_name) 不同的是 `java-name` 允许包含字符 `$`

</TDesc></TRow>

</Table>

### bean-name {#opt_bean_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> bean-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>


</TDesc></TRow>

</Table>

### var-name {#opt_var_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> var-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

一般为中英文字母和数字、`_` 组成，不包含字符 `.` 和 `$`。
只能以 `_` 或字母开头

</TDesc></TRow>

</Table>

### prop-name {#opt_prop_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> prop-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

一般为中英文字母和数字、`_` 组成，不包含字符 `.` 和 `$`。
只能以 `_` 或字母开头

</TDesc></TRow>

</Table>

### prop-name-set {#opt_prop_name_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> prop-name-set </TCol><TCol>

`java.util.Set<String>`

</TCol><TDesc>


</TDesc></TRow>

</Table>

### prop-path {#opt_prop_path}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> prop-path </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由一个或者多个 [prop-name](#opt_prop_name) 构成，并通过字符 `.` 来分隔

</TDesc></TRow>

</Table>

### conf-name {#opt_conf_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> conf-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由英文字母、数字、`_`、`-` 和 `.` 构成，
不包含 `$` 等特殊字符

</TDesc></TRow>

</Table>

### xml-name {#opt_xml_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> xml-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由英文字母、数字、`_`、`-`、`:` 和 `.` 构成，不包含 `$` 等特殊字符。
名字只能以 `_` 或字母开头，并且 `-`、`:`、`.` 不能连续出现。

**注**：其校验逻辑见 `StringHelper#isValidXmlName`。

</TDesc></TRow>

</Table>

### ns-name {#opt_ns_name}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> ns-name </TCol><TCol>

`java.lang.String`

</TCol><TDesc>

由英文字母、数字、`_`、`-` 构成，不包含 `$`、`:` 和 `.` 等特殊字符。
名字只能以 `_` 或字母开头，并且 `-` 不能连续出现。

**注**：其实现逻辑见 `SimpleStdDomainHandlers.NsNameType`，校验逻辑见
`StringHelper#isValidXmlNamespaceName`。

</TDesc></TRow>

</Table>

### xpl {#opt_xpl}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> xpl </TCol><TCol>

Xpl 片段

</TCol><TDesc>

其输出模式 `outputMode` 为 `none`，不允许副作用输出。
其内容最终编译成 `IEvalAction` 类型。

**注**：其实现逻辑见 `XplStdDomainHandlers.XplNoneType`。

</TDesc></TRow>

</Table>

### xpl-node {#opt_xpl_node}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> xpl-node </TCol><TCol>

输出 XNode 的 Xpl 片段

</TCol><TDesc>

其输出模式 `outputMode` 为 `node`，执行的过程中会输出 `XNode` 节点。
其内容最终编译成 `IXNodeGenerator` 类型。

**注**：其实现逻辑见 `XplStdDomainHandlers#XPL_NODE_TYPE`。

</TDesc></TRow>

</Table>

### xpl-fn {#opt_xpl_fn}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> xpl-fn </TCol><TCol>

Xpl 函数

</TCol><TDesc>

自定义的 Lambda 函数，以 `xpl-fn: (arg1: Arg1, arg2: Arg2) => any`
包含函数签名的形式定义数据类型，如：

```xml
<!-- 可以忽略参数类型 -->
<validator xdef:value="xpl-fn: (value) => boolean" />
```

在编写其函数体时，可以通过 `${xxx}` 形式引用指定的命名参数，如：

```xml {2}
<validator><![CDATA[
  return ${value} != 0;
]]></validator>
```

若是使用 Xpl 来输出 `XNode` 节点，则需要一个设置了
`xpl:outputMode` 为 `node` 的节点包装一下：

```xml {3}
<!-- <filter xdef:value="xpl-fn: (filter, query) => io.nop.core.lang.xml.XNode" /> -->
<filter>
  <and xpl:outputMode="node">
    <eq name="status" value="0" />
    <gt name="age" value="20" />
  </and>
</filter>
```

**注**：其实现逻辑见 `XplStdDomainHandlers.XplFnType`。

</TDesc></TRow>

</Table>

### csv-set {#opt_csv_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> csv-set </TCol><TCol>

逗号分隔的字符串集合（无重复）

</TCol><TDesc>

以 `,` 分隔的字符串集合，最终转换为 `LinkedHashSet<String>` 类型。
若逗号之间为空白，则该项将被忽略，同时，分隔的每一项都会去掉首尾的空白。

**注**：其处理逻辑见 `SimpleStdDomainHandlers.CsvSetType#parseProp`。

</TDesc></TRow>

</Table>

### csv-list {#opt_csv_list}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> csv-list </TCol><TCol>

逗号分隔的字符串集合（可重复）

</TCol><TDesc>

以 `,` 分隔的字符串集合，最终转换为 `List<String>` 类型。
若逗号之间为空白，则该项将被忽略，同时，分隔的每一项都会去掉首尾的空白。

**注**：其处理逻辑见 `SimpleStdDomainHandlers.CsvListType#parseProp`。

</TDesc></TRow>

</Table>

### multi-csv-set {#opt_multi_csv_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> multi-csv-set </TCol><TCol>

含与/或关系的字符串集合

</TCol><TDesc>

以 `,` 和 `|` 分隔的字符串集合，如 `a,b|c|e,f`，最终转换为 `List<LinkedHashSet<String>>`
类型，用以表达简单的`与`（`,` 列表）和`或`（`|` 列表）的关系，
`List<?>` 内的元素之间为`或`的关系，`LinkedHashSet<?>` 内的元素之间为`与`的关系。

**注**：其处理逻辑见 `SimpleStdDomainHandlers.MultiCsvSetType#parseProp`。

</TDesc></TRow>

</Table>

### word-set {#opt_word_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> word-set </TCol><TCol>

逗号分隔的字符串集合

</TCol><TDesc>

与 [csv-set](#opt_csv_set) 要求相同，
只是，其不能存在包含空白字符的项，否则，将会抛出校验异常。

**注**：其校验逻辑见 `SimpleStdDomainHandlers.WordSetType#isValidItem`。

</TDesc></TRow>

</Table>

### tag-set {#opt_tag_set}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> tag-set </TCol><TCol>

逗号分隔的字符串集合

</TCol><TDesc>

与 [csv-set](#opt_csv_set) 要求相同。

**注**：其校验逻辑见 `SimpleStdDomainHandlers.TagSetType#parseProp`。

</TDesc></TRow>

</Table>

### filter-bean {#opt_filter_bean}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> filter-bean </TCol><TCol>

过滤条件

</TCol><TDesc>

由过滤运算符标签组成的过滤条件，其为 xml 结构，并且条件可嵌套，如：

```xml
<and>
  <eq name="status" value="1" />
  <gt name="age" value="10" />
</and>
```

</TDesc></TRow>

</Table>

### field-selection {#opt_field_selection}

<Table head={['名称', '目标数据类型']}>

<TRow><TCol> field-selection </TCol><TCol>

GraphQL 字段选择集合

</TCol><TDesc>

[GraphQL Field Selection](https://www.graphql-java.com/documentation/field-selection/)
集合，用于指定可返回的字段，如：

```graphql
userId, userName, status, relatedRoleList{ roleId, roleName, permissionList{ id, name } }
```

</TDesc></TRow>

</Table>

## 附录 {#appendix}
