---
title: XDef
description: 有关 XDef 的使用说明
asDraft: trues
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import {CodeDocs, Code, Doc} from '@site/src/components/CodeDocs';
import Header from '@site/docs/\_header.md';

<Header />

在 Nop 中，所有的 DSL 均由其 XDef 元模型定义其结构，以用于校验和解析 DSL 的结构。

<CodeDocs>

## 示例代码 {#demo}

定义如下结构的工作流 DSL：

<Code>

```xml
<workflow
  xmlns:x="/nop/schema/xdsl.xdef" x:schema="/nop/schema/xdef.xdef"
  name="!string"
>
  <xdef:define xdef:name="WorkflowStepModel"
    id="!string" displayName="string"
    joinType="enum:io.nop.wf.core.model.WfJoinType" next="string"
  >
    <source xdef:value="xpl" />
  </xdef:define>

  <steps xdef:body-type="list" xdef:key-attr="id">
    <step xdef:ref="WorkflowStepModel" id="!string" />
  </steps>
</workflow>
```

</Code>

## 配置说明 {#doc}

### 属性类型 {#attr_type}

<Doc href="#attr_type" title="属性类型" match={({value, types}) => !value.endsWith('.xdef') && types.includes('attr-value')}>

> 可参考[《注册并使用属性类型》](#appendix_register_and_use_attr_type)自定义不同领域的属性类型。

在 XDef 文件中的所有属性（除去 `xdef` 和 `x` 名字空间中的内置属性）的值都是
`def-type` 类型（对应解析器 `SimpleStdDomainHandlers.DefTypeType`），
其内容格式为 `(!~#)?{stdDomain}(:{options})?(={defaultValue})?`，如，
`!dict:core/some-dict=dict1`，其各部分的意义如下：

- `!~#` 为属性修饰符，修饰符可根据需要同时使用多个
  - `!` 表示该属性必填
  - `~` 表示该属性为内部属性或者已经被废弃
  - `#` 表示可以使用编译期表达式，也就是该属性可以赋值 `#{xxx}`
    形式，以支持获取编译期注入的 `xxx` 变量值
- `{stdDomain}` 为在 `StdDomainRegistry` 中注册的数据域的名字，如 `dict`，具体值详见以
  `XDefConstants#STD_DOMAIN_` 开头的常量，使用手册见[《标准数据域》](../dict/std-domain)
- `{options}` 为传递给解析器接口 `IStdDomainHandler#parseOptions`
  的参数，如 `enum:xxx.yyy`，其解析器 `EnumStdDomainHandler`
  将通过 `{options}` 来得到对应的枚举类，最终，该属性的值必须为该枚举类中的枚举项
- `{defaultValue}` 为属性的缺省值

其中，`{defaultValue}` 作为缺省值，其可以是 `@attr:{attrNames}` 形式，如 `@attr:name`，
表示从当前节点的 `name` 属性中取其缺省值：

```xml {4-5} title="/nop/schema/xui/simple-component.xdef"
<component>
  <imports xdef:body-type="list" xdef:key-attr="as">
    <import
      as="!var-name=@attr:name"
      name="var-name"
      from="!string"
    />
  </imports>
</component>
```

> `{attrNames}` 可以是逗号分隔的多个属性名，最终的缺省值为这些属性的值以
> `|` 组合而成的字符串，具体处理逻辑详见 `XDslValidator#addDefaultAttrValue`。

</Doc>

### xdef:name {#attr_xdef_name}

<Doc token="xdef:name" href="#attr_xdef_name">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:name </TCol><TCol>

[var-name](../dict/std-domain#opt_var_name)

</TCol><TCol> 否 </TCol><TDesc>

将本节点注册为 xdef 片段，其他节点可以通过 [xdef:ref](#attr_xdef_ref)
来引用该片段。一般对应于 Java 类名，会根据它和根节点上的
[xdef:bean-package](#attr_xdef_bean_package) 设置
自动生成 [xdef:bean-class](#attr_xdef_bean_class) 属性。

**注意**：若未设置 `xdef:bean-package` 或 `xdef:bean-class`，
则不会[生成节点的 class 模型](#appendix_generate_node_class)。

</TDesc></TRow>

</Table>

</Doc>

### xdef:ref {#attr_xdef_ref}

<Doc token="xdef:ref" href="#attr_xdef_ref">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol id="attr_xdef_ref"> xdef:ref </TCol><TCol>

[xdef-ref](../dict/std-domain#opt_xdef_ref)

</TCol><TCol> 否 </TCol><TDesc>

用于引用当前文件中定义的 xdef 片段或者外部 xdef 定义。
引用相当于是继承已有定义。如果再增加属性或者子节点则表示在已有定义基础上扩展：

```xml {2,7} title="wf.xdef"
<workflow ...>
  <xdef:define xdef:name="WorkflowStepModel" ...>
    ...
  </xdef:define>

  <steps xdef:body-type="list" xdef:key-attr="id">
    <step xdef:ref="WorkflowStepModel" id="!string" />
  </steps>
</workflow>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:body-type {#attr_xdef_body_type}

<Doc token="xdef:body-type" href="#attr_xdef_body_type">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:body-type </TCol><TCol>

`io.nop.xlang.xdef.XDefBodyType`

</TCol><TCol> 否 </TCol><TDesc>

可选值如下：

- `union`: 最多只允许一个子节点
- `list`: 将当前节点解析为 `List`。若在当前节点上指定了 [xdef:key-attr](#attr_xdef_key_attr)，
  则该节点解析后对应 `KeyedList` 类型，可通过 [xdef:key-attr](#attr_xdef_key_attr)
  指定的子节点属性的值作为 `key`
- `map`: 将当前节点解析为 `Map`，且以子节点的标签名作为 `key`

若在当前节点上设置 `xdef:body-type="map"`，则将按照标签名对子节点做
[x:prototype](./xdsl#attr_x_prototype) 扩展（节点间的继承），
即，为 `x:prototype` 设置的值为子节点的标签名：

```xml
<!-- styles 的 xdef 定义 -->
<styles xdef:body-type="map">
  <xdef:unknown-tag xdef:unknown-attr="enum:StyleAttrType" />
</styles>

<!-- styles 的 dsl 定义 -->
<styles>
  <border-base x:abstract="true" size="Size" color="Color" />

  <border-left x:prototype="border-base" />
  <border-right x:prototype="border-base" />
</styles>
```

而若是其他值，则需要按照当前节点上 `xdef:key-attr` 指定的子节点的属性值作为扩展目标的引用名字：

```xml
<!-- xmeta 的 xdef 定义 -->
<xmeta>
  <props xdef:body-type="list" xdef:key-attr="name">
    <prop name="!prop-path" />
  </props>
</xmeta>

<!-- xmeta 的 dsl 定义 -->
<xmeta>
  <props>
    <prop x:abstract="true" name="base-prop" />

    <prop name="some" x:prototype="base-prop" />
  </props>
</xmeta>
```

**注意**：若需要为当前节点[生成 class 模型](#appendix_generate_node_class)，
则不能在该节点上指定 `xdef:body-type`，而需要为其定义一个子节点，再在该子节点上设置该属性，
因为，该属性对应的模型必须是一个集合类型，而 Nop 不能构造集合类型的 class（生成的 class 模型为
`IComponentModel` 的实现）。

</TDesc></TRow>

</Table>

</Doc>

### xdef:key-attr {#attr_xdef_key_attr}

<Doc token="xdef:key-attr" href="#attr_xdef_key_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:key-attr </TCol><TCol>

[xml-name](../dict/std-domain#opt_xml_name)

</TCol><TCol> 否 </TCol><TDesc>

在当前节点被设置为 list 类型时（`xdef:body-type="list"`），
需要同时设置 `xdef:key-attr` 以指定用于**唯一定位**其同名标签子节点的**节点属性**：

```xml {3-4,7} title="/nop/schema/xmeta.xdef"
<meta xdef:name="ObjMetaImpl">
  <props
    xdef:body-type="list"
    xdef:key-attr="name"
  >
    <prop xdef:name="ObjPropMetaImpl"
          name="!prop-path"
    />
  </props>
</meta>
```

> `xdef:key-attr` 指定的是其所在节点的**子节点**上的属性名。

在生成的 class 模型中，该节点的子节点将被放在一个 `KeyedList` 类型的属性中：

```java {4} title="_ObjMetaImpl.java"
public abstract class _ObjMetaImpl extends ObjSchemaImpl {
  private KeyedList<ObjPropMetaImpl> _props = KeyedList.emptyList();

  public java.util.List<ObjPropMetaImpl> getProps() {
    return _props;
  }
}
```

在 DSL 中便可通过 `xdef:key-attr` 指定属性的值对子节点做差量运算：

```xml title="_NopAuthUser.xmeta"
<meta ...>
  <props>
    <prop name="userName" ... />
    <prop name="email" ... />
  </props>
</meta>
```

```xml title="NopAuthUser.xmeta"
<meta ... x:extends="_NopAuthUser.xmeta">
  <props>
    <prop name="userName" allowFilterOp="eq,contains" ui:filterOp="contains"/>
    <prop name="email" x:override="remove" />
  </props>
</meta>
```

**注意**：对于非[集合类型](#attr_xdef_body_type)的节点，需要通过
[xdef:unique-attr](#attr_xdef_unique_attr) 唯一定位其同名标签子节点。

</TDesc></TRow>

</Table>

</Doc>

### xdef:unique-attr {#attr_xdef_unique_attr}

<Doc token="xdef:unique-attr" href="#attr_xdef_unique_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:unique-attr </TCol><TCol>

[xml-name](../dict/std-domain#opt_xml_name)

</TCol><TCol> 否 </TCol><TDesc>

当非[集合类型](#attr_xdef_body_type)的节点下允许有多个**同名标签**时，
需通过 `xdef:unique-attr` 指定用于**唯一定位**这些同名标签节点的**节点属性**：

```xml {5-6} title="/nop/schema/biz/xbiz.xdef"
<biz ...>
  <actions ...>
    <query xdef:name="BizActionModel">
      <arg xdef:name="BizActionArgModel"
            xdef:unique-attr="name"
            name="!var-name" />
    </query>
  </actions>
</biz>
```

> `xdef:unique-attr` 指定的是其所在节点上的属性名。

在生成的 class 模型中，所有该类型的节点都会被放在一个 `KeyedList` 类型的属性中：

```java {4} title="_BizActionModel.java"
public abstract class _BizActionModel extends AbstractComponentModel {
  private KeyedList<BizActionArgModel> _args = KeyedList.emptyList();

  public List<BizActionArgModel> getArgs() {
    return _args;
  }
}
```

在 DSL 中便可通过 `xdef:unique-attr` 指定属性的值对子节点做差量运算：

```xml title="NopRuleDefinition.xbiz"
<biz ...>
  <actions>
    <query name="getOutputFieldsEditSchema">
      <arg name="ruleId" mandatory="true" type="String" />
    </query>
  </actions>
</biz>
```

```xml title="ExtNopRuleDefinition.xmeta"
<biz ... x:extends="NopRuleDefinition.xbiz">
  <actions>
    <query name="getOutputFieldsEditSchema">
      <arg name="ruleId" mandatory="false" />
    </query>
  </actions>
</biz>
```

**注意**：对于[集合类型](#attr_xdef_body_type)的节点，需要通过
[xdef:key-attr](#attr_xdef_key_attr) 唯一定位其同名标签子节点。

</TDesc></TRow>

</Table>

</Doc>

### xdef:unknown-attr {#attr_xdef_unknown_attr}

<Doc token="xdef:unknown-attr" href="#attr_xdef_unknown_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:unknown-attr </TCol><TCol>

[def-type](../dict/std-domain#opt_def_type)

</TCol><TCol> 否 </TCol><TDesc>

在 DSL 节点的属性名不确定但类型可确定时，可通过该配置项定义这些属性：

```xml
<!-- styles 的 xdef 定义 -->
<styles xdef:body-type="map">
  <xdef:unknown-tag xdef:unknown-attr="enum:StyleAttrType" />
</styles>

<!-- styles 的 dsl 定义 -->
<styles>
  <border-left size="Size" color="Color" />
</styles>
```

**注意**：名称不确定但类型确定的属性集合只能定义一个，
也就是，不能定义多种类型的**非具名属性**。
若是需要定义多个类型的非具名属性，则可以通过固定的标签名进行定义，例如：

```xml
  <props xdef:body-type="list" xdef:key-attr="name">
    <prop name="!prop-path" type="generic-type" />
  </props>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:transformer-class {#attr_xdef_transformer_class}

<Doc token="xdef:transformer-class" href="#attr_xdef_transformer_class">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:transformer-class </TCol><TCol>

[class-name-set](../dict/std-domain#opt_class_name_set)

</TCol><TCol> 否 </TCol><TDesc>

在加载得到 DSL 的 XNode 根节点之后，将调用这个列表中的转换器进行格式转换，
可以通过转换器转换得到标准格式，或者执行版本迁移等。

转换器为 `IXNodeTransformer` 的实现类，且多个转换器为串联的，
即，前一个的转换结果将作为下一个转换器的参数。

> 转换器的解析和调用逻辑详见 `io.nop.xlang.xdsl.XDslExtender#transformNode`。

例如，通过 `io.nop.xlang.xdsl.transformer.InOutNodeTransformer`
可以自动识别标签中 `in:` 和 `out:` 前缀标记的属性，并把它们自动转换为
`input` 和 `output` 子节点：

```xml title="task.xdef"
<task xdef:transformer-class="io.nop.xlang.xdsl.transformer.InOutNodeTransformer"
  ...>
  <steps>
    <xpl ... />
  </steps>
</task>
```

```xml title="common.task.xml"
<task>
  <steps>
    <xpl name="step1" in:x="1" out:RESULT="x+y">
      <in:y mandatory="true">2</in:y>
    </xpl>

    <!-- 等价于 -->
    <xpl name="step1">
      <input name="x">
        <source>1</source>
      </input>
      <input name="y" mandatory="true">
        <source>2</source>
      </input>

      <output name="RESULT">
        <source> x + y</source>
      </output>
    </xpl>
  </steps>
</task>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-class {#attr_xdef_bean_class}

<Doc token="xdef:bean-class" href="#attr_xdef_bean_class">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-class </TCol><TCol>

[class-name](../dict/std-domain#opt_class_name)

</TCol><TCol> 否 </TCol><TDesc>

指定节点所生成的 class 模型的全名称（= 包名 + 类名）。
默认由 [xdef:bean-package](#attr_xdef_bean_package)
和 [xdef:name](#attr_xdef_name) 组合而成。

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-package {#attr_xdef_bean_package}

<Doc token="xdef:bean-package" href="#attr_xdef_bean_package">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-package </TCol><TCol>

[package-name](../dict/std-domain#opt_package_name)

</TCol><TCol> 否 </TCol><TDesc>

**[仅根节点]** 指定根节点及其子节点所生成的 class 模型的包名。

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-child-name {#attr_xdef_bean_child_name}

<Doc token="xdef:bean-child-name" href="#attr_xdef_bean_child_name">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-child-name </TCol><TCol>

[var-name](../dict/std-domain#opt_var_name)

</TCol><TCol> 否 </TCol><TDesc>

为 [xdef:body-type](#attr_xdef_body_type) 的列表元素指定属性名，并在其所属的
class 模型中创建对应的 getter/has 方法：

```xml title="xlib.xdef"
<lib xdef:name="XplTagLib">
  <tags xdef:body-type="map" xdef:bean-child-name="tag">
    <xdef:unknown-tag xdef:name="XplTag" ... />
  </tags>
</lib>
```

```java title="_XplTagLib.java"
public class _XplTagLib extends AbstractDslModel {
  private Map<String, XplTag> _tags = Collections.emptyMap();

  public XplTag getTag(String name){
    return this._tags.get(name);
  }

  public boolean hasTag(String name){
    return this._tags.containsKey(name);
  }
}
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-unknown-attrs-prop {#attr_xdef_bean_unknown_attrs_prop}

<Doc token="xdef:bean-unknown-attrs-prop" href="#attr_xdef_bean_unknown_attrs_prop">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-unknown-attrs-prop </TCol><TCol>

[package-name](../dict/std-domain#opt_package_name)

</TCol><TCol> 否 </TCol><TDesc>

</TDesc></TRow>

</Table>

</Doc>

</CodeDocs>

## 附录 {#appendix}

### 生成节点 class 模型 {#appendix_generate_node_class}

```java title="src/main/java/xx/xx/xx/SchemaCodeGen.java"
public class SchemaCodeGen {

  public static void main(String[] args) {
    AppConfig.getConfigProvider()
            .updateConfigValue(CoreConfigs.CFG_CORE_MAX_INITIALIZE_LEVEL,
                              CoreConstants.INITIALIZER_PRIORITY_ANALYZE);

    CoreInitialization.initialize();
    try {
      run();
    } finally {
      CoreInitialization.destroy();
    }
  }

  public static void run() {
    File projectDir = MavenDirHelper.projectDir(SchemaCodeGen.class);

    // 运行项目根目录下 precompile 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPrecompile(projectDir, "/", false);
    // 运行项目根目录下 precompile2 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPrecompile2(projectDir, "/", false);
    // 运行项目根目录下 postcompile 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPostcompile(projectDir, "/", false);
  }
}
```

```xml title="precompile2/gen-xxx-xdsl.xgen"
<c:script xmlns:c="c"><![CDATA[
  codeGenerator.renderModel('/vfs/to/schema/xxx.xdef', '/nop/templates/xdsl', '/', $scope);
]]></c:script>
```

### 注册并使用属性类型 {#appendix_register_and_use_attr_type}

首先，注册 `ICoreInitializer` 的实现类，如 `XuiCoreInitializer`：

```ini title="src/main/resources/META-INF/services/io.nop.core.initialize.ICoreInitializer"
io.nop.xui.initialize.XuiCoreInitializer
```

> `io.nop.core.initialize.ICoreInitializer` 为固定的文件名，其最终由
> `java.util.ServiceLoader#load` 加载，在该文件内可以放置多行 `ICoreInitializer`
> 的实现类的全名。

在 `ICoreInitializer` 的实现类 `XuiCoreInitializer` 中调用
`StdDomainRegistry#registerStdDomainHandler` 以注册自定义属性类型的解析器，如
`VueNodeStdDomainHandler`：

```java title="io.nop.xui.initialize.XuiCoreInitializer"
public class XuiCoreInitializer implements ICoreInitializer {
  private final Cancellable cancellable = new Cancellable();

  @Override
  public int order() {
    return CoreConstants.INITIALIZER_PRIORITY_REGISTER_XLANG;
  }

  @Override
  public void initialize() {
    IStdDomainHandler handler = VueNodeStdDomainHandler.INSTANCE;
    StdDomainRegistry
      .instance()
      .registerStdDomainHandler(handler);

    cancellable.appendOnCancelTask(() -> {
      StdDomainRegistry
        .instance()
        .unregisterStdDomainHandler(handler);
    });
  }

  @Override
  public void destroy() {
    cancellable.cancel();
  }
}
```

最后，实现自定义属性类型解析器 `VueNodeStdDomainHandler` 即可：

```java title="io.nop.xui.initialize.VueNodeStdDomainHandler"
public class VueNodeStdDomainHandler extends SimpleStdDomainHandlers.XmlType {
  public static final VueNodeStdDomainHandler INSTANCE = new VueNodeStdDomainHandler();

  @Override
  public String getName() {
    return "vue-node";
  }

  @Override
  public IGenericType getGenericType(
    boolean mandatory, IStdDomainOptions options
  ) {
    return ReflectionManager.instance().buildRawType(VueNode.class);
  }

  @Override
  public Object parseProp(
    IStdDomainOptions options, SourceLocation loc,
    String propName, Object text,
    XLangCompileTool cp
  ) {
    return null;
  }

  @Override
  public Object parseXmlChild(
    IStdDomainOptions options, XNode body,
    XLangCompileTool cp
  ) {
    return new VueTemplateParser().parseTemplate(body);
  }
}
```

> 各种类型的转换处理逻辑可以参考 `io.nop.xlang.xdef.domain.SimpleStdDomainHandler`
> 的实现类。

这样，便可以在定义 XDef 时，为相关属性指定其类型为 `vue-node` 了：

```xml {4} title="src/main/resources/_vfs/nop/schema/xui/simple-component.xdef"
<component ...>
  <!-- ... -->

  <template xdef:value="vue-node" />
</component>
```
