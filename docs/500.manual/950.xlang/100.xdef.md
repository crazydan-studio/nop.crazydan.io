---
title: XDef
description: 有关 XDef 的使用说明
authors:
  - flytreleft
---

import {Table, TRow, TCol, TDesc} from '@site/src/components/Table';
import {CodeDocs, Code, Doc} from '@site/src/components/CodeDocs';
import Header from '@site/docs/\_header.md';

<Header />

<CodeDocs>

## 示例代码 {#demo}

在 Nop 中，所有的 DSL 均由其 XDef 元模型定义其结构，以用于校验和解析 DSL 的结构。
例如，定义如下结构的工作流 DSL：

<Code>

```xml
<workflow
  xmlns:x="/nop/schema/xdsl.xdef" x:schema="/nop/schema/xdef.xdef"
  name="!string"
>
  <xdef:define xdef:name="WorkflowStepModel"
    id="!string" displayName="string"
    joinType="enum:io.nop.wf.core.model.WfJoinType" next="string"
  >
    <source xdef:value="xpl" />
  </xdef:define>

  <steps xdef:body-type="list" xdef:key-attr="id">
    <step xdef:ref="WorkflowStepModel" id="!string" />
  </steps>
</workflow>
```

</Code>

## 配置说明 {#doc}

### xdef:name {#attr_xdef_name}

<Doc token="xdef:name" href="#attr_xdef_name">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:name </TCol><TCol>

[var-name](../dict/std-domain#opt_var_name)

</TCol><TCol> 否 </TCol><TDesc>

将本节点注册为 xdef 片段，其他节点可以通过 [xdef:ref](#attr_xdef_ref)
来引用该片段。一般对应于 Java 类名，会根据它和根节点上的
[xdef:bean-package](#attr_xdef_bean_package) 设置
自动生成 [xdef:bean-class](#attr_xdef_bean_class) 属性。

**注意**：若未设置 `xdef:bean-package` 或 `xdef:bean-class`，
则不会[生成节点的 class 模型](#appendix_generate_node_class)。

</TDesc></TRow>

</Table>

</Doc>

### xdef:ref {#attr_xdef_ref}

<Doc token="xdef:ref" href="#attr_xdef_ref">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol id="attr_xdef_ref"> xdef:ref </TCol><TCol>

[xdef-ref](../dict/std-domain#opt_xdef_ref)

</TCol><TCol> 否 </TCol><TDesc>

用于引用当前文件中定义的 xdef 片段或者外部 xdef 定义。
引用相当于是继承已有定义。如果再增加属性或者子节点则表示在已有定义基础上扩展：

```xml {2,7} title="wf.xdef"
<workflow ...>
  <xdef:define xdef:name="WorkflowStepModel" ...>
    ...
  </xdef:define>

  <steps xdef:body-type="list" xdef:key-attr="id">
    <step xdef:ref="WorkflowStepModel" id="!string" />
  </steps>
</workflow>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:body-type {#attr_xdef_body_type}

<Doc token="xdef:body-type" href="#attr_xdef_body_type">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:body-type </TCol><TCol>

`io.nop.xlang.xdef.XDefBodyType`

</TCol><TCol> 否 </TCol><TDesc>

可选值如下：

- `union`: 最多只允许一个子节点
- `list`: 将当前节点解析为 `List`。若在当前节点上指定了 [xdef:key-attr](#attr_xdef_key_attr)，
  则该节点解析后对应 `KeyedList` 类型，可通过 [xdef:key-attr](#attr_xdef_key_attr)
  指定的子节点属性的值作为 `key`
- `map`: 将当前节点解析为 `Map`，且以子节点的标签名作为 `key`

若在当前节点上设置 `xdef:body-type="map"`，则将按照标签名对子节点做
[x:prototype](./xdsl#attr_x_prototype) 扩展（节点间的继承），
即，为 `x:prototype` 设置的值为子节点的标签名：

```xml
<!-- styles 的 xdef 定义 -->
<styles xdef:body-type="map">
  <xdef:unknown-tag xdef:unknown-attr="enum:StyleAttrType" />
</styles>

<!-- styles 的 dsl 定义 -->
<styles>
  <border-base x:abstract="true" size="Size" color="Color" />

  <border-left x:prototype="border-base" />
  <border-right x:prototype="border-base" />
</styles>
```

而若是其他值，则需要按照当前节点上 `xdef:key-attr` 指定的子节点的属性值作为扩展目标的引用名字：

```xml
<!-- xmeta 的 xdef 定义 -->
<xmeta>
  <props xdef:body-type="list" xdef:key-attr="name">
    <prop name="!prop-path" />
  </props>
</xmeta>

<!-- xmeta 的 dsl 定义 -->
<xmeta>
  <props>
    <prop x:abstract="true" name="base-prop" />

    <prop name="some" x:prototype="base-prop" />
  </props>
</xmeta>
```

**注意**：若需要为当前节点[生成 class 模型](#appendix_generate_node_class)，
则不能在该节点上指定 `xdef:body-type`，而需要为其定义一个子节点，再在该子节点上设置该属性，
因为，该属性对应的模型必须是一个集合类型，而 Nop 不能构造集合类型的 class（生成的 class 模型为
`IComponentModel` 的实现）。

</TDesc></TRow>

</Table>

</Doc>

### xdef:key-attr {#attr_xdef_key_attr}

<Doc token="xdef:key-attr" href="#attr_xdef_key_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:key-attr </TCol><TCol>

[xml-name](../dict/std-domain#opt_xml_name)

</TCol><TCol> 否 </TCol><TDesc>

</TDesc></TRow>

</Table>

</Doc>

### xdef:unique-attr {#attr_xdef_unique_attr}

<Doc token="xdef:unique-attr" href="#attr_xdef_unique_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:unique-attr </TCol><TCol>

[xml-name](../dict/std-domain#opt_xml_name)

</TCol><TCol> 否 </TCol><TDesc>

</TDesc></TRow>

</Table>

</Doc>

### xdef:unknown-attr {#attr_xdef_unknown_attr}

<Doc token="xdef:unknown-attr" href="#attr_xdef_unknown_attr">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:unknown-attr </TCol><TCol>

[def-type](../dict/std-domain#opt_def_type)

</TCol><TCol> 否 </TCol><TDesc>

在 DSL 节点的属性名不确定但类型可确定时，可通过该配置项定义这些属性：

```xml
<!-- styles 的 xdef 定义 -->
<styles xdef:body-type="map">
  <xdef:unknown-tag xdef:unknown-attr="enum:StyleAttrType" />
</styles>

<!-- styles 的 dsl 定义 -->
<styles>
  <border-left size="Size" color="Color" />
</styles>
```

**注意**：名称不确定但类型确定的属性集合只能定义一个，
也就是，不能定义多种类型的**非具名属性**。
若是需要定义多个类型的非具名属性，则可以通过固定的标签名进行定义，例如：

```xml
  <props xdef:body-type="list" xdef:key-attr="name">
    <prop name="!prop-path" type="generic-type" />
  </props>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:transformer-class {#attr_xdef_transformer_class}

<Doc token="xdef:transformer-class" href="#attr_xdef_transformer_class">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:transformer-class </TCol><TCol>

[class-name-set](../dict/std-domain#opt_class_name_set)

</TCol><TCol> 否 </TCol><TDesc>

在加载得到 DSL 的 XNode 根节点之后，将调用这个列表中的转换器进行格式转换，
可以通过转换器转换得到标准格式，或者执行版本迁移等。

转换器为 `IXNodeTransformer` 的实现类，且多个转换器为串联的，
即，前一个的转换结果将作为下一个转换器的参数。

> 转换器的解析和调用逻辑详见 `io.nop.xlang.xdsl.XDslExtender#transformNode`。

例如，通过 `io.nop.xlang.xdsl.transformer.InOutNodeTransformer`
可以自动识别标签中 `in:` 和 `out:` 前缀标记的属性，并把它们自动转换为
`input` 和 `output` 子节点：

```xml title="task.xdef"
<task xdef:transformer-class="io.nop.xlang.xdsl.transformer.InOutNodeTransformer"
  ...>
  <steps>
    <xpl ... />
  </steps>
</task>
```

```xml title="common.task.xml"
<task>
  <steps>
    <xpl name="step1" in:x="1" out:RESULT="x+y">
      <in:y mandatory="true">2</in:y>
    </xpl>

    <!-- 等价于 -->
    <xpl name="step1">
      <input name="x">
        <source>1</source>
      </input>
      <input name="y" mandatory="true">
        <source>2</source>
      </input>

      <output name="RESULT">
        <source> x + y</source>
      </output>
    </xpl>
  </steps>
</task>
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-class {#attr_xdef_bean_class}

<Doc token="xdef:bean-class" href="#attr_xdef_bean_class">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-class </TCol><TCol>

[class-name](../dict/std-domain#opt_class_name)

</TCol><TCol> 否 </TCol><TDesc>

指定节点所生成的 class 模型的全名称（= 包名 + 类名）。
默认由 [xdef:bean-package](#attr_xdef_bean_package)
和 [xdef:name](#attr_xdef_name) 组合而成。

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-package {#attr_xdef_bean_package}

<Doc token="xdef:bean-package" href="#attr_xdef_bean_package">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-package </TCol><TCol>

[package-name](../dict/std-domain#opt_package_name)

</TCol><TCol> 否 </TCol><TDesc>

**[仅根节点]** 指定根节点及其子节点所生成的 class 模型的包名。

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-child-name {#attr_xdef_bean_child_name}

<Doc token="xdef:bean-child-name" href="#attr_xdef_bean_child_name">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-child-name </TCol><TCol>

[var-name](../dict/std-domain#opt_var_name)

</TCol><TCol> 否 </TCol><TDesc>

为 [xdef:body-type](#attr_xdef_body_type) 的列表元素指定属性名，并在其所属的
class 模型中创建对应的 getter/has 方法：

```xml title="xlib.xdef"
<lib xdef:name="XplTagLib">
  <tags xdef:body-type="map" xdef:bean-child-name="tag">
    <xdef:unknown-tag xdef:name="XplTag" ... />
  </tags>
</lib>
```

```java title="_XplTagLib.java"
public class _XplTagLib extends AbstractDslModel {
  private Map<String, XplTag> _tags = Collections.emptyMap();

  public XplTag getTag(String name){
    return this._tags.get(name);
  }

  public boolean hasTag(String name){
    return this._tags.containsKey(name);
  }
}
```

</TDesc></TRow>

</Table>

</Doc>

### xdef:bean-unknown-attrs-prop {#attr_xdef_bean_unknown_attrs_prop}

<Doc token="xdef:bean-unknown-attrs-prop" href="#attr_xdef_bean_unknown_attrs_prop">

<Table head={['名称', '类型', '必填？']}>

<!-- -->

<TRow><TCol> xdef:bean-unknown-attrs-prop </TCol><TCol>

[package-name](../dict/std-domain#opt_package_name)

</TCol><TCol> 否 </TCol><TDesc>

</TDesc></TRow>

</Table>

</Doc>

</CodeDocs>

## 附录 {#appendix}

### 生成节点 class 模型 {#appendix_generate_node_class}

```java title="src/main/java/xx/xx/xx/SchemaCodeGen.java"
public class SchemaCodeGen {

  public static void main(String[] args) {
    AppConfig.getConfigProvider()
            .updateConfigValue(CoreConfigs.CFG_CORE_MAX_INITIALIZE_LEVEL,
                              CoreConstants.INITIALIZER_PRIORITY_ANALYZE);

    CoreInitialization.initialize();
    try {
      run();
    } finally {
      CoreInitialization.destroy();
    }
  }

  public static void run() {
    File projectDir = MavenDirHelper.projectDir(SchemaCodeGen.class);

    // 运行项目根目录下 precompile 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPrecompile(projectDir, "/", false);
    // 运行项目根目录下 precompile2 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPrecompile2(projectDir, "/", false);
    // 运行项目根目录下 postcompile 目录中的 *.xgen 脚本：目录必须存在，但可为空目录
    XCodeGenerator.runPostcompile(projectDir, "/", false);
  }
}
```

```xml title="precompile2/gen-xxx-xdsl.xgen"
<c:script xmlns:c="c"><![CDATA[
  codeGenerator.renderModel('/vfs/to/schema/xxx.xdef', '/nop/templates/xdsl', '/', $scope);
]]></c:script>
```
